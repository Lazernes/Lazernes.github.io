---
title: "프로그래밍 언어 활용 3장 응용 SW 기초 기술 활용"
excerpt: "응용 SW 기초 기술 활용"

wirter: Myeongwoo Yoon
categories:
  - 정보처리기사
tags:
  - 정보처리기사

toc: true
toc_sticky: true
use_math: true

date: 2024-02-28
last_modified_at: 2024-02-28
---

운영체제의 개념
======

운영체제(OS; Operating System)의 정의
------
　운영체제는 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임이다. 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종으로, 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 제공해준다.

운영체제의 목적
------
　운영체제의 목적에는 처리능력 향상, 사용 가능도 향상, 신뢰도 향상, 반환 시간 단축 등이 있다. 처리 능력, 반환 시간, 사용 가능도, 신뢰도는 운영체제의 성능을 평가하느데 기준이 된다.
* 처리능력(Throughput): 일정 시간 내에 시스템이 처리하는 일의 양
* 반환 시간(Trun Around Time): 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간
* 사용 가능도(Availability): 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도
* 신뢰도(Reliability): 시스템이 주어진 문제를 정확하게 해결하는 정도

운영체제의 구성
------
* 제어 프로그램
  - 제어 프로그램(Control Program)은 컴퓨터 전체의 작동 상태 감시, 작업의 순서 지정, 작업에 사용되는 데이터 관리 등의 역할을 수행하는 것으로 다음과 같이 구분할 수 있다.
  - **감시 프로그램(Supervisor Program)**: 제어 프로그램 중 가장 핵심적인 역할을 하는 것으로, 자원의 할당 및 시스템 전체의 작동 상태를 감시하는 프로그램
  - **작업 관리 프로그램(Job Management Program)**: 작업이 정상적으로 처리될 수 있도록 작업의 순서와 방법을 관리하는 프로그램
  - **데이터 관리 프로그램(Data Management Program)**: 작업에 사용되는 데이터와 파일의 표준적인 처리 및 전송을 관리하는 프로그램
* 처리 프로그램
  - 처리 프로그램(Processing Program)은 제어 프로그램의 지시를 받아 사용자가 요구한 문제를 해결하기 위한 프로그램으로, 다음과 같이 구분할 수 있다.
  - **언어 번역 프로그램**: 사용자가 고급언어로 작성한 원시 프로그램을 기계어 형태의 목적 프로그램으로 변환시키는 것으로, 컴파일러, 어셈블로, 인터프리너 등이 있음
  - **서비스 프로그램**: 사용자가 컴퓨터를 더욱 효율적으로 사용할 수 있도록 제작된 프로그램, 분류/병합(Sort/Merge), 유틸리티 프로그램 등이 여기에 해당됨

운영체제의 기능
------
* 프로시저(처리기, Processor), 기억장치(주기억장치, 보조기억장치), 입•출력장치, 파일 및 정보 등의 자원을 관리한다.
* 자원을 효율적으로 관리하기 위해 자원의 스케줄링 기능을 제공한다.
* 사용자와 시스템 간의 편리한 인터페이스를 제공한다.
* 시스템의 각종 하드웨어와 네트워크를 관리•제어한다.
* 데이터를 관리하고, 데이터 및 자원의 공유 기능을 제공한다.
* 시스템의 오류를 감시하고 복구한다.
* 자원 보호 기능을 제공한다.
* 입•출력에 대한 보조 기능을 제공한다.
* 가상 계산기 기능을 제공한다.

Windows
======

Windows의 개요
------
　Windows의 주요 특징에는 GUI, 선점형 멀티태스킹, OLE, PnP 등이 있다.

그래픽 사용자 인터페이스(GUI; Graphic User Interface)
------
　**그래픽 사용자 인터페이스**는 키보드로 명령어를 직접 입력하지 않고, 마우스로 아이콘이나 메뉴를 선택하여 모든 작업을 수행하는 방식이다. 초보자도 쉽게 사용할 수 있는 그래픽 사용자 인터페이스(GUI)를 채용하였다.

선점형 멀티태스킹(Preemptive Multi-Tasking)
------
　**선점형 멀티태스킹**은 동시에 여러 개의 프로그램을 실행하는 멀티태스킹을 하면서 운영체제가 각 작업의 CPU 이용 시간을 제어햐여 응용 프로그램 실행중 문제가 발생하면 해당 프로그램을 강제 종료시키고 모든 시스템 자원을 반환하는 방식을 말한다. 하나의 응용 프로그램이 CPU를 독점하는 것을 방지할 수 있어 시스템 다운 현상 없이 더욱 안정적인 작업을 할 수 있다.

PnP(Plug and Play, 자동 감지 기능)
------
　**PnP**는 컴퓨터 시스템에 프린터나 사운드 카드 등의 하드웨어를 설치했을 때, 해당 하드웨어를 사용하는 데 필요한 시스템 환경을 운영체제가 자동으로 구성해 주는 기능이다. 운영체제가 하드웨어의 규격을 자동으로 인식하여 동작하게 해주므로 PC 주변장치를 연결할 때 사용자가 직접 환경을 설정하지 않아도 된다. PnP 기능을 활용하기 위해서는 하드웨어와 소프트웨어 모두 PnP를 지원해야 한다.

OLE(Object Linking and Embedding)
------
　**OLE**는 다른 여러 응요 프로그램에서 작성된 문서나 그림등의 개체(Object)를 현재 작성 중인 문서에 자유롭게 연결(Linking)하거나 삽입(Embedding)하여 편집할 수 있게 하는 기능이다. OLE로 연결된 이미지를 원본 프로그램에서 수정하거나 편집하면 그 내용이 그대로 해당 문서에 반영된다.

255자의 긴 파일명
------
　Windows에서는 파일 이름을 지정할 때 VFAT(Virtual File Allocation Table)를 이용하여 최대 255자까지 지정할 수 있다. 파일 이름으로는 특정 특수문자를 제외한 모든 문자 및 공백을 사용할 수 있으며, 한글의 경우 127자까지 지정할 수 있다.

Single-User 시스템
------
　컴퓨터 한 대를 한 사람만이 독접해서 사용한다.

UNIX/LINUX/MacOS
======

UNIX의 개요 및 특징
------
　UNIX는 시분할 시스템(Time Sharing System)을 위해 설계된 대화식 운영체제로, 소스가 공개된 개방형 시스템(Open System)이다. 대부분 C언어로 작성되어 있어 이식성이 높으며, 장치, 프로세스 간의 호환성이 높다. 크기가 작고 이해하기 쉬우며 다중 사용자(Multi-User), 다중 작업(Multi-Tasking)을 지원한다. 많은 네트워크 기능을 제공하므로 통신망(Network) 관리용 운영체제로 적합하다 트리 구조의 파일 시스템을 갖고, 전문적인 프로그램 개발에 용이하고, 다양한 유틸리티 프로그램들이 존재한다.

UNIX 시스템의 구성
------
<p align="center"><img src="/assets/img/정보처리기사/프로그래밍 언어 활용/응용 SW 기초 기술 활용/3-1.jpeg" width="300"></p>

* 커널(Kernel)
  - UNIX의 가장 핵심적인 부분이다.
  - 컴퓨터가 부팅될 때 주기억장치에 적재된 후 상주하면서 실행된다.
  - 하드웨어를 보호하고, 프로그램과 하드웨어 간의 인터페이스 역할을 한다.
  - 프로세스(CPU 스케줄링) 관리, 기억장치 관리, 파일 관리, 입•출력 관리, 프로세스간 통신, 데이터 전송 및 변환 등 여러 가지 기능을 수행한다.
* 쉘(Shell)
  - 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기이다.
  - 시스템과 사용자 간의 인터페이스를 담당한다.
  - DOS와 COMMAND.COM과 같은 기능을 수행한다.
  - 주기억장치에 상주하지 않고, 명령어가 포함된 파일 형태로 존재하며 보조 기억장치에서 교체 처리가 가능하다.
  - 파이프라인 기능을 지원하고 입•출력 재지정을 통해 출력과 입력의 방향을 변경할 수 있다.
  - 공용 Shell(Bourne Shell, C Shell, Korn Shell)이나 사용자 자신이 만든 Shell을 사용할 수 있다.
* Utility Program
  - 일반 사용자가 작성한 응용 프로그램을 처리하는 데 사용한다.
  - DOS에서의 외부 명령어에 해당된다.
  - 유틸리티 프로그램에는 에디터, 컴파일러, 인터프리터, 디버거 등이 있다.

LINUX의 개요 및 특징
------
　LINUX는 프로그램 소스 코드가 무료로 공개되어 있기 때문에 프로그래머가 원하는 기능을 추가할 수 있고, 다양한 플랫폼에 설치하여 가능하며, 재배포가 가능하다. UNIX와 완벽하게 호환되고 대부분의 특징이 UNIX와 동일하다.

MacOS의 개요 및 특징
------
　MacOS는 아이맥(iMac)과 맥북(MacBook) 등 애플 사에서 생산하는 제품에서만 사용이 가능하다. 드라이버 설치 및 install과 uninstall의 과정이 단순하다.

파일 디스크립터(File Descriptor, 파일 서술자)
------
　파일을 관리하기 위한 시스템(운영체제)이 필요로 하는 파일에 대한 정보를 가진 제어 블록을 의미하며, 파일 제어 블록(FCB; File Control Block)이라고도 한다. 파일 디스크립터는 파일마다 독립적으로 존재하며, 시스템에 따라 해당 파일이 Open될 때 주기억장치로 옮겨진다. 파일 디스크립터는 파일 시스템이 관리하므로 사용자가 직접 참조할 수 없다.

기억장치 관리의 개요
======

기억장치 계층 구조의 특징
------
　기억장치는 레지스터, 캐시 기억장치, 주기억장치, 보조기억장치를 다음과 같이 계층 구조로 분류할 수 있다.
<p align="center"><img src="/assets/img/정보처리기사/프로그래밍 언어 활용/응용 SW 기초 기술 활용/4-1.jpeg" width="300"></p>

* 계층 구조에서 상위의 기억장치일수록 접근 속도와 접근 시간이 빠르지만, 기억 용량이 적고 고가이다.
* 주기억장치는 각기 자신의 주소를 갖는 워드 또는 바이트들로 구성되어 있으며, 주소를 이용하여 액세스할 수 있다.
* 레지스터, 캐시 기억장치, 주기억장치의 프로그램과 데이터는 CPU가 직접 액세스 할 수 있으나 보조기억장치에 있는 프로그램이나 데이터는 직접 엑세스 할 수 없다.
* 보조기억장치에 있는 데이터는 주기억장치에 적재된 후 CPU에 의해 엑세스될 수 있다.

기억장치의 관리 전략의 개요
------
　기억장치의 관리 전략은 보조기억장치의 프로그램이나 데이터를 주기억장치에 적재시키는 시기, 적재 위치 등을 지정하여 한정된 주기억장치의 공간을 효율적으로 사용하기 위한 것으로 반입(Fetch) 전략, 배치(Placement) 전략, 교체(Replacement) 전략이 있다.

반입(Fetch) 전략
------
　반입 전략은 보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인지를 결정하는 전략이다.
* 요구 반입(Demend Fetch): 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재하는 방법이다.
* 예상 반입(Anticipatory Fetch): 실행중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재하는 방법이다.

배치(Placement) 전략
------
　배치 전략은 새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정하는 전략이다.
* 최초 적합(First Fit): 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 첫 번째 분할 영역에 배치시키는 방법
* 최적 적합(Best Fit): 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치시키는 방법
* 최악 적합(Worst Fit): 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치시키는 방법

교체(Replacement) 전략
------
　교체 전략은 주기억장치의 모든 영역이 이미 사용중인 상태에서 새로운 프로그램이나 데이터를 주기억장치에 배치하려고 할 때, 이미 사용되고 있는 영역 중에서 어느 영역을 교체하여 사용할 것인지를 결정하는 전략이다. 교체 전략에는 FIFO, OPT, LRU, NUR, SCR 등이 있다.

가상기억장치 구현 기법/페이지 교체 알고리즘
======

가상기억장치의 개요
------
　가상기억장치는 보조기억장치(하드디스크)의 일부를 주기억장치처럼 사용하는 것으로, 용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용하는 기법이다. 프로그램을 여러 개의 작은 블록 단위로 나누어서 가상기억장치에 보관해 놓고, 프로그램 실행 시 요구되는 블록만 주기억장치에 불연속적으로 할당하여 처리한다. 주기억장치의 용량보다 큰 프로그랭믈 실행하기 위해 사용한다. 주기억장치의 이용률과 다중 프로그래밍의 효율을 높일 수 있다. 가상기억장치에 저장된 프로그램을 실행하려면 가상기억장치의 주소를 주기억장치의 주소로 바꾸는 주소 변환 작업이 필요하다. 블록 단위로 나누어 사용하므로 연속 할당 방식에서 발생할 수있는 단편화를 해결할 수 있다. 가상기억장치의 일반적인 구현 방법에는 블록의 종류에 따라 페이징 기법과 세그먼테이션 기법으로 나눌 수 있다.

페이징(Paging)기법
------
　페이징 기법은 가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램(페이지)을 동일하게 나눠진 주기억장치의 영역(페이지 프레임)에 적재시켜 실행하는 기법이다. 프로그램을 일정한 크기로 나눈 단위를 페이지(Page)라고 하고, 페이지 크기로 일정하게 나누어진 주기억장치의 단위를 페이지 프레임(Page Frame)이라고 한다. 외부 단편화는 발생하지 않으나 내부 단편화는 발생할 수 있다. 주소 변환을 위해서 페이지의 위치 정보를 가지고 있는 페이지 맵 테이블(Page Map Table)이 필요하다

세그먼테이션(Segmentation)기법
------
　세그먼테이션 기법은 가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행하는 기법이다. 프로그램을 배열이나 함수 등과 같은 논리적인 크기로 나눈 단위를 세그먼트(Segment)라고 하며, 각 세그먼트는 고유한 이름과 크기를 갖는다. 기억장치의 사용자 관점을 보존하는 기억장치 관리 기법으로 세그먼테이션 기법을 이용하는 궁극적인 이유는 기억공간을 절약하기 위해서이다. 주소 변환을 위해서 세그먼트가 존재하는 위치 정보를 가지고 있는 세그먼트 맵 테이블(Segment Map Table)이 필요하다. 세그먼트가 주기억장치에 적재될 때 다른 세그먼트에게 할당된 영역을 침범할 수 었으며, 이를 위해 기억장치 보호키(Storage Protection Key)가 필요하다. 내부 단편화는 발생하지 않으나 외부 단편화는 발생할 수 있다.<br/>
　세그먼테이션 기법의 일반적인 주소 변환은 다음과 같다.
* 주소 형식에 따른 주소와 세그먼트 맵 테이블의 구성
  - 가상주소는 세그먼트 번호를 나타내는 s와 세그먼트 내에 실제 내용이 위치하고 있는 곳까지의 거리를 나타내는 변위값 d로 구성된다.
  - 실기억주소는 완전주소 형태를 사용하며 이는 세그먼트의 기준번지와 변위값을 더함으로써 얻을 수 있다.
  - 세그먼트 맵 테이블(Segment Map Table)은 세그먼트 번호 s와 세그머트의 크기 L(한계번지), 주기억장치 상의 기준번지(시작주소) b로 구성된다.
* 주소 변환 순서
  1. 가상주소의 세그먼트 번호로 세그먼트 맵 테이블에서 해당 세그먼트의 기준번지와 시그먼트 크기를 구한다. 세그먼트 번호는 세그먼트 맵 테이블에 대한 색인으로 사용된다.
  2. 가상주소의 변위값과 세그먼트의 크기를 비교한다.
  3. 변위값이 작거나 같으면 기준번지와 변위값을 더하여 실기억주소를 만들어 주기억장치를 액세스한다.
  4. 변위값이 크면 다른 영역을 침범하게 되므로 실행 권한을 운영체제에게 넘기고 트랩을 발생시킨다.
    - 변위값이 크다는 것은 현재 찾는 세그먼트의 위치가 해당 세그먼트의 크기(한계번지)를 초과하였다는 의미이다.

페이지 교체 알고리즘
------
　페이지 교체 알고리즘은 페이지 부재(Page Fault)가 발생했을 때 가상기억장치의 필요한 페이지를 주기억장치에 적재해야 하는데, 이때 주기억장치의 모든 페이지 프레임이 사용중이면 어떤 페이지 프레임을 선택하여 교페할 것인지를 결정하는 기법이다. 페이지 교체 알고리즘에는 OPT, FIFO, LRU, LFU, NUR, SCR 등이 있다.
* OPT(OPTimal replacement, 최적 교체)
  - OPT는 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 것이다.
  - 페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘이다.
* FIFO(First In First Out)
  - FIFO는 각 페이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법이다.
  - 이해하기 쉽고, 프로그래밍 및 설계가 간단하다.
* LRU(Least Recently Used)
  - LRU는 최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법이다.
  - 각 페이지마다 계수기(Counter)나 스택(Stack)을 두어 현 시점에서 가장 오랫동안 사용하지 않은, 즉 가장 오래 전에 사용된 페이지를 교체한다.
* LFU(Least Frequently Used)
  - LFU는 사용 빈도가 가장 적은 페이지를 교체하는 기법이다.
  - 활발하게 사용되는 페이지는 사용 횟수가 많아 교체되지 않고 사용된다.
* NUR(Not Used Recently)
  - NUR은 LRU와 비슷한 알고리즘으로, 최근에 사용하지 않은 페이지를 교체하는 기법이다.
  - 최근에 사용되지 않은 페이지는 향후에도 사용되지 않을 가능성이 높다는 것을 전제로, LRU에서 나타나는 시간적인 오버헤드를 줄일 수 있다.
  - 최근의 사용 여부를 확인하기 위해서 각 페이지마다 두 개의 비트, 즉 참조 비트(Reference Bit)와 변형 비트(Modified Bit, Dirty Bit)가 사용된다.
  |참조 비트|0|1|0|1|
  |변형 비트|0|0|0|0|
  |교체 순서|1|2|3|4|
* SCR(Second Chance Replacement, 2회 기회 교체)
  - SCR은 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 것으로, FIFO 기법의 단점을 보환하는 기법이다.

가상기억장치 기타 관리 사항
======

페이지 크기
------
　페이징 기법을 사용하면 프로그램을 페이지 단위로 나누게 되는데, 페이지의 크기에따라 시스템에 미치는 영향이 다르다. 페이지 크기에 따른 특징은 다음과 같다.
* 페이지 크기가 작을 경우
  - 페이지 단편화가 감소되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 줄어든다.
  - 불필요한 내용이 주기억장치에 적재될 확률이 적으므로 효율적인 워킹 셋을 유지할 수 있다.
  - Locality에 더 일치할 수 있기 때문에 기억장치 효율이 높아진다.
  - 페이지 정보를 갖는 페이지 맵 테이블의 크기가 커지고, 매핑 속도가 늦어진다.
  - 디스크 접근 횟수가 많아져서 전체적인 입출력 시간은 늘어난다.
* 페이지 크기가 클 경우
  - 페이지 정보를 갖는 페이지 맵 테이블의 크기가 작아지고, 매팽 속도가 빨라진다.
  - 디스크 접근 횟수가 줄어들어 전체적인 입출력의 효율성이 증가된다.
  - 페이지 단편화가 증가되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 늘어난다.
  - 프로세르(프로그램) 수행에 불필요한 내용까지도 주기억장치에 적재될 수 있다.

Locality
------
　Locality(국부성, 지역성, 구역성, 국소성)는 프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론이다. 스레싱을 방지하기 위한 워킹 셋 이론의 기반이 되었다. 프로세스가 집중적으로 사용하는 페이지를 알아내는 방법 중 하나로, 가상기억장치 관리의 이론적인 근거가 된다. 구역성의 개념이 증명되었으며, 캐시 메모리 시스템의 이론적 근거이다. Locality의 종류에는 시간 구역성(Temporal Locality)과 공간 구역성(Spatial Locality)이 있다.
* 시간 구역성(Temporal Locality)
  - 시간 구역성은 프로세스가 실행되면서 하나의 페이지를 일정 시간동안 집중적으로 액세스하는 현상이다.
  - 한 번 참조한 페이지는 가까운 시간 내에 계속 참조할 가능성이 높음을 의미한다.
  - 시간 구역성이 이루어지는 장소: Loop(반복, 순환), 스택(Stack), 부 프로그램(Sub Routine), Counting(1씩 증김), 집계(Totaling)에 사용되는 변수(기억장소)
* 공간 구역성(Spatial Locality)
  - 공간 구역성은 프로세스 실행 시 일정 위치의 페이지를 집중적으로 액세스하는 현상이다.
  - 어느 하나의 페이지를 참조하면 그 근처의 페이지를 계속 참조할 가능성이 높음을 의미한다.
  - 공간 구역성이 이루어지는 장소: 배열 순회(Array Traversal, 배열 순례), 순차적 코드의 실행, 프로그래머들이 관련된 변수들을 서로 근처에 선언하여 할당되는 기억장소, 같은 영역에 있는 변수를 참조할 때

웨킹 셋(Working Set)
------
　워킹 셋은 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합으로 프로그램의 Locality 특징을 이용한다. 자주 참조되는 워킹 셋을 주기억장치에 상주시킴으로써 페이지 부재 및 페이지 교체 현상이 줄어들어 프로세스의 기억장치 사용이 안정된다. 시간이 지남에 따라 자주 참조하는 페이지들의 집합이 변화하기 때문에 워킹 셋은 시간에 따라 변한다.

페이지 부재 빈도 방식
------
　페이지 부재(Page Fault)는 프로세스 실행 시 참조할 페이지가 주기억장치에 없는 현상이며, 페이지 부재 빈도(PFP; Page Fault Frequency)에 따라 주기억장치에 있는 페이지 프레임의 수를 늘리거나 줄여 페이지 부재율을 적정 수숮느오 유지하는 방식이다. 운영체제는 프로세스 실행 초기에 임의의 페이지 프레임을 할당하고, 페이지 부재율을 지속적으로 감시하고 있다가 부재율이 상한선을 넘어가면 좀더 많은 페이지 프레임을 할당하고, 부재율이 하한선을 넘어가면 페이지 프레임을 회수하는 방식을 사용한다.

프리레이징(Prepaging)
------
　프리페이징은 처음의 괴도한 페이지 부재를 방지하기 위해 필요할 것 같은 모든 페이지를 한꺼번에 페이지 프레임에 적재하는 기법이다. 기억장체이 들어온 페이지들 중에서 사용되지 않는 페이지가 많을 수도 있다.

스래싱(Thrashing)
------
　스레싱은 프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상이다. 다중 프로그래밍 시스템이나 가상기억장치를 사용하는 시스템에서 하나의 프로세스 수행 과정중 자주 페이지 부재가 발생함으로써 나타나는 현상으로, 전체 시스템의 성능이 저하된다. 다중 프로그래밍의 정도가 높아짐에 따라 CPU의 이용률은 어느 특정 시점까지는 높아지지만, 다중 프로그램의 정도가 더욱 커지면 스레싱이 나타나고, CPU의 이용률은 급격히 감소하게 된다.<br/>
　스레싱 현상 방지 방법은 다음과 같다.
* 다중 프로그래밍의 정도를 적정 수준으로 유지한다.
* 페이지 부재 빈도(Page Fault Freauency)를 조정하여 사용한다.
* 워킹 셋을 유지한다.
* 부족한 자원을 증설하고, 일부 프로세스를 중단시킨다.
* CPU 성능에 대한 자료의 지속적 관리 및 분석으로 임계치를 예상하여 운영한다.

프로세스의 개요
======

프로세스(Process)의 정의
------
　프로세스는 일반적으로 프로세서(처리기, CPU)에 의해 처리되는 사용자 프로그램, 시스템 프로그램, 즉 실행중인 프로그램을 의미하며, 작업(Job), 테스크(Task)라고도 한다. 프로세스는 다음과 같이 여러 형태로 정의할 수 있다.
* PCB를 가진 프로그램
* 실기억장치에 저장된 프로그램
* 프로세서가 할당되는 실체로서, 디스패치가 가능한 단위/
* 프로시저가 활동중인 것
* 비동기적 행위를 일으키는 주체
* 지정된 결과를 얻기 위한 일련의 계통적 동작
* 목적 또는 결과에 따라 발생되는 사건들의 과정
* 운영체제가 관리하는 실행 단위

PCB(Process Control Block, 프로세스 제어 블록)
------
　PCB는 운영체제가 프로세스에 대한 중요한 정보를 저장해 놓는 곳으로, Task Control Block 또는 Job Control Block이라고도 한다. 각 프로세스가 생성될 때마다 고유의 PCB가 생성되고, 프로세스가 완료되면 PCB는 제거된다. PCB에 저장되어 있는 정보는 다음과 같다.
* 프로세스의 현재 상태
  - 준비, 대기, 실행 등의 프로세스 상태
* 포인터
  - 부모 프로세스에 대한 포인터: 부모 프로세스의 주소 기억
  - 자식 프로세스에 대한 포인터: 자식 프로세스의 주소 기억
  - 프로세스가 위치한 메모리에 대한 포인타: 현재 프로세스가 위차한 주소 기억
  - 할당된 자원에 대한 포인터: 프로세스에 할당된 각 자원에 대한 주소 기억
* 프로세스 고유 식별자
  - 프로세스를 구분할 수 있는 고유 번호
* 스케줄링 및 프로세스의 우선순위
  - 스케줄링 정보 및 프로세스가 실행될 우선순위
* CPU 레지스터 정보
  - Accumulator(누산기), 인덱스 레지스터, 범용 레지스터, 프로그램 카운터(PC) 등에 대한 정보
* 주기억장치 관리 정보
  - 기준 레지스터(Base Register), 페이지 테이블(Page Table)에 대한 정보
* 입출력 상태 정보
  - 입출력장치, 개방된 파일 목록
* 계정 정보
  - CPU 사용시간, 실제 사용 시간, 한정된 시간

프로세스 상태 전이
------
　프로세스 상태 전이는 프로세스가 시스템 내에 존재하는 동안 프로세스의 상태가 변하는 것을 의미하며, 프로세스의 상태는 다음과 같이 상태 전이도로 표시할 수 있다.
<p align="center"><img src="/assets/img/정보처리기사/프로그래밍 언어 활용/응용 SW 기초 기술 활용/7-1.jpeg" width="400"></p>

　프로세스의 상태는 제출, 접수, 준비, 실행, 대기 상태로 나눌 수 있으며, 이 중 주요 세 가지 상태는 준비, 실행, 대기 상태이다.
* 제출(Submit)
  - 작업을 처리하기 위해 사용자가 작업을 시스템에 제출한 상태이다.
* 접수(Hold)
  - 제출된 작업이 스풀 공간인 디스크의 할당 위치에 저장된 상태이다.
* 준비(Ready)
  - 프로세스가 프로세서를 할당받기 위해 기다리고 있는 상태이다.
  - 프로세스는 준비상태 큐에서 실행을 준비하고 있다.
  - 접수 상태에서 준비 상태로의 전이는 Job 스케줄러에 의해 수행된다.
* 실행(Run)
  - 준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태이다.
  - 프로세스 수행이 완료되기 전에 프로세스에게 주어진 프로세서 할당 시간이 종료(Timer Run Out)되면 프로세스는 준비 상태로 전이된다.
  - 실행중인 프로세서에 입출력(IO) 처리가 필요하면 실행중인 프로세스는 대기 상태로 전이된다.
  - 준비 상태에서 실행 상태로의 전이는 CPU(프로세서) 스케줄러에 의해 수행된다.
* 대기(Wait), 보류, 블록(Block)
  - 프로세스에 입출력 처리가 필요하면 현재 실행 중인 프로세스가 중단되고, 입출력 처리가 완료될 때까지 대기하고 있는 상태이다.
* 종료(Terminated, Exit)
  - 프로세스의 실행이 끝나고 프로세스 할당이 해제된 상태이다.

프로세스 관련 용어
------
* Dispatch: 준비 상태에서 대기하고 있는 프로세스 중 하나가 프로세서를 할당받아 실행 상태로 전이되는 과정이다.
* Wake Up: 입출력 작업이 완료되어 프로세스가 대기 상태에서 준비 상태로 전이되는 과정이다.
* Spooling: 입출력 장치의 공유 및 상대적으로 느린 입출력장치의 처리 속도를 보완하고 다중 프로그래밍 시스템의 성능을 향상시키기 위해 입출력할 데이터를 직접 입출력장치에 보내지 않고 나중에 한꺼번에 입출력하기 위해 디스크에 저장하는 과정이다.
* 교통량 제어기(Traffic Controller): 프로세스의 상태에 대한 조사와 통보를 담당한다.

스레드(Thread)
------
　스레드는 프로세스 내에서의 작업 단위로서 시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위이다. 하나의 프로세스에 하나의 스레드가 존재하는 경우에는 단일 스레드, 하나 이상의 스레드가 존재하는 경우에는 다중 스레드라고 한다. 프로세스의 일부 특성을 갖고 있기 때문에 경량(Light Weight) 프로세스라고도 한다. 스레드 기반 시스템에서 스레드는 독립적인 스케줄링의 최소 단위로서 프로세스의 역할을 담당한다. 동일 프로세스 환경에서 서로 독립적인 다중 수행이 가능하다.<br/>
　스레드의 종류는 다음과 같다.
* 사용자 수준의 스레드
  - 사용자가 만든 라이브러리를 사용하여 스레드를 운용한다.
  - 커널 모드로의 전환이 없어 오버헤드가 줄어든다.
  - 속도는 빠르지만 구현이 어렵다.
* 컬널 수준의 스레드
  - 운영체제의 커널에 의해 스레드를 운용한다.
  - 한 프로세스가 운영체제를 호출할 때 전체 프로세스가 대기하지 않으므로 시스템의 성능을 높일 수 있다.
  - 여러 스레드가 커널에 동시에 접근할 수 있다.
  - 스레드의 독립적인 스케줄링이 가능하다.
  - 구현이 쉽지만 속도가 느리다.
　스레드 사용의 장점은 다음과 같다.
* 하나의 프로세스를 여러 개의 스레드로 생성하여 병행성을 증진시킬 수 있다.
* 하드웨어, 운영체제의 성능과 응용 프로그램의 처리율을 향상시킬 수 있다.
* 응용 프로그래의 응답 시간(Response Time)을 단축시킬 수 있다.
* 실행 환경을 공유시켜 기억장소의 낭비가 줄어든다.
* 프로세스들 간의 통신이 향상된다.
* 스레드는 공통적으로 접근 가능한 기억장치를 통해 효율적으로 통신한다.

스케줄링
======

스케줄링(Scheduling)의 개요
------
　스케줄링은 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업을 의미한다. 프로세스가 생성되어 완료될 때까지 프로세스는 여러 종류의 스케줄링 과정을 거치게 된다.
* 장기 스케줄링
  - 어떤 프로세스가 시스템의 자원을 차지할 수 있도록 할 것인가를 결정하여 준비상태로 큐를 보내는 작업을 의미한다.
  - 작업 스케줄링(Job Scheduling), 상위 스케줄링이라고도 하며, 작업 스케줄러에 의해 수행된다.
* 중기 스케줄링
  - 어떤 프로세스들이 CPU를 할당받을 것인지 결정하는 작업을 의미한다.
  - CPU를 할당받으려는 프로세스가 많을 경우 프로세스를 일시 보류시킨 후 활성화해서 일시적으로 부하를 조절한다
* 단기 스케줄링
  - 프로세스가 실행되기 위해 CPU를 할당받는 시기와 특정 프로세스를 지정하는 작업을 의미한다.
  - 프로세서 스케줄링(Processor Scheduing), 하위 스케줄링이라고도 한다.
  - 프로세서 스케줄링 및 문맥 교환은 프로세서 스케줄러에 의해 수행된다.

프로세스 스케줄리의 기법
------
* 비선점(Non-Preemptive) 스케줄링
  - 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법이다.
  - 프로세스가 CPU를 할당받으면 해당 프로세스가 완료될 때까지 CPU를 사용한다.
  - 모든 프로세스에 대한 요구를 공정하게 처리할 수 있다.
  - 프로세스 응답 시간의 예측이 용이하며, 일괄 처리 방식에 적합하다.
  - 중요한 작업(짧은 작업)이 중요하지 않은 작업(긴 작업)을 기다리는 경우가 발생할 수 있다.
  - 비선점 스케줄링의 종류에는 FCFS, SJF, 우선순위, HRN, 기한부 등의 알고리즘이 있다.
* 선점(Preempitve) 스케줄링
  - 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법이다.
  - 우선순위가 높은 프로세스를 빠르게 처리할 수 있다.
  - 주로 빠른 응답 시간을 요구하는 대화식 시분할 시스템에 사용된다.
  - 많은 오버헤드(Overhead)를 초래한다.
  - 선점이 가능하도록 일정 시간 배당에 대한 인터럽트용 타이머 클록(Clock)이 필요하다,.
  - 선점 스케줄링의 종류에는 Round Robin, SRT, 선점 우선순위, 다단계 큐, 다단계 피드백 큐 등의 알고리즘이 있다.

주요 스케줄링 알고리즘
======

FCFS(First Come First Service, 선입 선출, FIFO)
------
　FCFS는 준비상태 큐(대기 큐, 준비 완료 리스트, 작업준비 큐, 스케줄링 큐)에 도착한 순서에 따라차례로 CPU를 할당하는 기법으로, 가장 간단한 알고리즘이다. 먼저 도착한 것이 먼저 처리되어 공평성은 유지되지만 짧은 작업이 긴 작업을, 중요한 작업이 중요하지 않은 작업을 기다리게 된다.

SJF(Shortest Job First, 단기 작업 우선)
------
　SJF는 준비상태 큐에서 기다리고 있는 프로세스들 중에서 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 기법이다. 가장 작은 평균 대기 시간을 제공하는 최적 알고리즘이다. 실행 시간이 긴 프로세스는 실행 시간이 짧은 프로세스에게 할당 순위가 밀려 무한 연기 상태가 발생될 수 있다.

HRN(Highest Pesponse-ratio Next)
------
　실행 시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위한 것으로, 대기 시간과 서비스(실행) 시간을 이용하는 기법이다. 우선순위 계산 공식을 이용하여 서비스(실행) 시간이 짧은 프로세스나 대기 시간이 긴 프로세스에게 우선순위를 주어 CPU를 할당한다. 서비스 실행 시간이 짧거나 대기 시간이 긴 프로세스의 경우 우선순위가 높아진다. 우선순위를 계산하여 그 숫자가 높은 것부터 낮은 순으로 우선순위가 부여된다. 우선순위 계산식은 **우선순위 계산식 = (대기시간 + 서비스시간)/서비스시간**이다.

환경 변수
======

환경 변수의 개요
------
　환경 변수(Environment Variable)란 시스템 소프트웨어의 동작에 영향을 미치는 동적인 값들의 모임을 의미한다. 환경 변수는 변수명과 같은 값으로 구성되고 시스템의 기본 정보를 저장한다. 환경 변수는 자식 프로세스에 상속되고 시스템 전반에 걸쳐 적용되는 시스템 환경 변수의 사용자 계정 내에서만 적용되는 사용자 환경 변수로 구분된다.

Windows의 주요 환경 변수
------
　Windows에서 환경 변수를 명령어나 스크립트에서 사용하려면 변수명 앞뒤에 '%'를 입력해야 한다. Windows에서 set을 입력하면 모든 환경 변수와 값을 출력한다.

UNIX/LINUX의 주요 환경 변수
------
　UNIX나 LINUX에서 환경 변수를 명령어나 스크립트에서 사용하려면 변수명 앞에 '$'를 입력해야 한다. UNIX나 LINUX에서는 set, env, printenv, setenv 중 하나를 입력하면 모든 환경 변수와 값을 표시한다.

운영체제 기본 명령어
======

운영체제 기본 명령어의 개요
------
　운영체제를 제어하는 방법은 크기 CLI와 GUI로 구분할 수 있다. CLI(Command Line Interface)는 키보드로 명려어를 직접 입력하여 작업을 수행하는 사용자 인터페이스를 의미한다. GUI(Graphic User Interface)는 키보드로 명령어를 직접 입력하지 않고, 마우스로 아이콘이나 메뉴를 선택하여 작업을 수행하는 그래픽 사용자 인터페이스를 의미한다.

Windows 기본 명령어
-------
* CLI 기본 명령어: 명령 프롬프트(Commamd) 창에 명령어를 입력하여 작업을 수행하는 것이다.
* GUI 기본 명령어: 바탕 화면이나 Windows 탐색기에서 마우스로 아이콘을 더블클릭하여 프로그램 실행, 파일의 복사 및 이동, 제어판의 기능 실행 등 모든 작업이 GUI 명령어에 해당된다.

UNIX/LINUX 기본 명령어
------
* CLI 기본 명령어: 쉘(Shell)에 명령어를 입력하여 작업을 수행하는 것이다.
  - fork: 새로운 프로세스를 생성한다.(하위 프로세스 호출, 프로세스 복제 명령)
  - uname: 시스템의 이름과 버전, 네트워크 호스트명 등의 시스템 정보를 표시한다.
* GUI 기본 명령어: UNIX와 LINUX는 기본적으로 CLI를 기반으로 운영되는 시스템이지만 X Windows라는 별도의 프로그램을 설치하여 GU 방식으로 운영할 수 있다.

인터넷
======

인터넷(Internet)의 개요
------
　인터넷이란 TCP/IP 프로토콜을 기반으로 하여 전 세계 컴퓨터아 네트워크들이 연결된 광범위한 컴퓨터 통신망이다. 인터넷은 미 국방성의 ARPANET에서 시작되었다. 인터넷은 유닉스 운영체제를 기반으로 한다. 통신망과 컴퓨터가 있는 곳이라면 시간과 장소에 구애받지 않고 정보를 교환할 수 있다.<br/>
　인터넷에 연결된 모든 컴퓨터는 고유한 IP주소를 갖는다. 컴퓨터 또는 네트워크를 서로 연결하기 위해서는 브리지, 라우터, 게이트웨이가 사용된다. 다른 네트워크 또는 같은 네트워크를 연결하여 중추적 역할을 하는 네트워크로, 보통의 인터넷의 주가 되는 기간망을 일걷는 용어를 백본(Backbone)이라고 한다.

IP 주소(Internet Protocol Address)
------
　IP 주소는 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소이다. 숫자로 8비트씩 4부분, 총 32비트로 구성되어 있다. IP 주소는 네트워크 부분의 길이에 따라 다음과 같이 A 클래스에서 E 클래스까지 총 5단계로 구성되어 있다.
* A Class
  - 국가나 대형 통신망에 사용(0~127로 시작)
  - $2^{24}$개의 호스트 사용 가능
* B Class
  - 중대형 통신망에 사용(128~191로 시작)
  - $2^{16}$개의 호스트 사용 가능
* C Class
  - 소규모 통신망에 사용(192~223으로 시작)
  - $2^{8}$개의 호스트 사용 가능
* D Class
  - 멀티캐스트 용으로 사용(224~239로 시작)
* E Class
  - 실험적 주소이며 공용되지 않음

서브네팅(Subnetting)
------
　서브네팅은 할당된 네트워크 주소를 다시 여러 개의 작은 네트워크로 나누어 사용하는 것을 말한다. 4바이트의 IP 주소 중 네트워크 주소와 호스트 주소를 구분하기 위한 비트를 서브넷 마스크(Subnet Mask)라고 하며, 이를 변경하여 네트워크 주소를 여러 개로 분할하여 사용한다. 서브넷 마스크는 각 클래스마다 다르게 사용된다.

IPv6(Internet Protocol version 6)의 개요
------
　IPv6은 현재 사용하고 있는 IP 주소 체계인 IPv6의 주소 부족 문제를 해결하기 위해 개발되었다. 128비트의 긴 주소를 사용하여 주소 부족 문제를 해결할 수 있으며, IPv6에 비해 자료 전송 속도가 빠르다. 인증성, 기밀성, 데이터 무결성의 지원으로 보안 문제를 해결할 수 있다. IPv4와 호환성이 뛰어나다. 주소의 확장성, 융통성, 연동성이 뛰어나며, 실시간 흐름 제어로 향상된 멀티미디어 기능을 지원한다.<br/>
　Traffic Class, Flow Label을 이용하여 등급별, 서비스별로 패킷을 구분할 수 있어 품질 보장이 용이하다. 패킷 크기를 확장할 수 있으므로 패킷 크기에 제한이 없다. 기본 헤더 뒤에 확장 헤더를 더함으로써 더욱 다양한 정보의 저장이 가능해져 네트워크 기능 확장이 용이하다. 미리 예약된 알고리즘을 통해 고유성이 보장된 주소를 자동으로 구성할 수 있다. 즉 자동으로 네트워크 환경 구성이 가능하다.
* IPv4를 IPv6로 전환하는 전략
  - 듀얼 스택(Dual Stack): 호스트에서 IPv4와 IPv6을 모두 처리할 수 있도록 구 개의 스택을 구성하는 것
  - 터널링(Tunneling): IPv6 망에서 인접한 IPv4 망을 거쳐 다른 IPv6 망으로 통신할 때 IPv4 망에 터널을 만들어 IPv6 패킷이 통과할 수 있도록 하는 것
  - IPv4/IPv6 변환: 헤더 변환, 전송 계층 릴레이 방식, 응용 계층 게이트웨이 방식

IPv6의 구성
------
* 16비트씩 8부분, 총 128비트로 구성되어 있다.
* 각 부분을 16진수로 표현하고, 클론(:)으로 구분한다.
* IPv6은 다음과 같이 세 가지 주소 체계로 나누어진다.
  - 유니캐스트(Unicast): 단일 송신자와 단일 수신자 간의 통신(1 대 1 통신에 사용)
  - 멀티캐스트(Multicast): 단일 송신자와 다중 수신자 간의 통신(1 대 다 통신에 사용)
  - 애니캐스트(Antcast): 단일 송신자와 가까이 있는 단일 수신자 간의 통신(1 대 1 통신에 사용)

도메인 네임(Domain Name)
------
　도메인 네임은 숫자로 된 IP 주소를 사람이 이해하기 쉬운 문자 형태로 표현한 것이다. 호스트 컴퓨터 이름, 소속 기관 이름, 소속 기관의 종류, 소속 국가명 순으로 구성되며, 왼쪽에서 오른쪽으로 갈수록 상위 도메인을 의미한다. 문자로 된 도메인 네임을 컴퓨터가 이해할 수 있는 IP 주소로 변환하는 역할을 하는 시스템을 DNS(Domain Name System)라고 하며 이런 역할을 하는 서버를 DNS 서버라고 한다.

OSI 참조 모델
======

OSI(Open System Interconnection) 참조 모델의 개요
------
　OSI 참조 모델은 다른 시스템 간의 원할한 통신을 위해 ISO(국제표준화기구)에서 제안한 통신 규약(Protocol)이다. 개방형 시스템(Open System) 간의 데이터 통신 시 필요한 장비 및 처리 방법 등을 7단계로 표준화하여 규정했다. OSI 7계층은 1~3 계층을 하위 계층, 4~7 계층을 상위 계층이라고 한다.
* 하위 계층: 물리 계층 -> 데이터 링크 개층 -> 네트워크 계층
* 상위 계층: 전송 계층 -> 세션 계층 -> 표현 계층 -> 응용 계층

<p align="center"><img src="/assets/img/정보처리기사/프로그래밍 언어 활용/응용 SW 기초 기술 활용/13-1.jpeg" width="400"></p>

OSI 참조 모델의 목적
------
* 서로 다른 시스템 간을 상호 접속하기 위한 개념을 규정한다.
* OSI 규격을 개발하기 위한 범위를 정한다.
* 관련 규정의 적합성을 조절하기 위한 공통적 기반을 제공한다.

OSI 참조 모델에서의 데이터 단위
------
* 프로토콜 데이터 단위(PDU; Protocol Data Unit)
  - 프로토콜 데이터 단위는 동일 계층 간에 교환되는 정보의 단위이다.
  - 물리 계층: 비트
  - 데이터 링크 계층: 프레임
  - 네트워크 계층: 패킷
  - 전송 계층: 세그먼트
  - 세션, 표현, 응용 계층: 메시지
* 서비스 데이터 단위(SDU; Service Data Unit)
  - 서비스 데이터 단위는 서비스 접근점(SAP)을 통해 상•하위 계층끼리 주고받는 경보의 단위이다.

물리 계층(Physical Layer)
------
　**물리 계층**은 전송에 필요한 두 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙을 정의한다. 물리적 전속 매체와 전송 신호 방식을 정의하며, RS-232C, X.21 등의 표준이있다.
* 관련 장비: 리피터, 허브

데이터 링크 계층(Data Link Layer)
------
　**데이터 링크 계층**은 두 개의 인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 시스템 간 연결 설정과 유지 및 종료를 담당한다. 송신 측과 수신 측의 속도 차이를 해결하기 위한 흐름 제어 기능을 한다. 프레임의 시작과 끝을 구분하기 위한 프레임의 동기화 기능을 한다. 오류의 검출과 회복을 위한 오류 제어 기능을 한다. 프레임의 순서적 전송을 위한 순서 제어 기능을 한다. HDLC, LAPB, LLC, MAC, LAPD, PPP 등의 표준이 있다.
* 관련 장비: 랜카드, 브리지, 스위치

네트워크 계층(Network Layer, 망 계층)
------
　**네트워크 계층**은 개방 시스템들 간의 네트워크 연결을 관리하는 기능과 데이터의 교환 및 중계 기능을 한다. 네트워크 연결을 설정, 유지, 해제하는 기능을 한다. 발신지와 목적지의 논리 주소가 추가된 패킷을 최종 목적지까지 전달하는 책임을 진다. 경로 설정(Routing), 데이터 교환 및 중계, 트래픽 제어, 패킷 정보 전송을 수행한다. X.25, IP 등의 표준이 있다.
* 관련 장비: 라우터

전송 계층(Transport Layer)
------
　**전송 계층**은 논리적인 안정과 균일한 데이터 전송 서비스를 제공함으로써 종단 시스템(End-to-End) 간에 투명한 데이터 전송을 가능하게 한다. OSI 7계층 중 하위 3계층과 상위 2계층의 인터페이스(Interface)를 담당한다. 종단 시스템(End-to-End) 간의 전송 연결, 데이터 전송, 연결 해제 기능을 한다. 주소 설정, 다중화(분할 및 재조립), 오류 제어, 흐름 제어를 수행한다. TCP, UDP 등의 표준이 있다.
* 관련 장비: 게이트 웨이

세션 계층(Session Layer)
------
　**세션 계층**은 송•수신 측 간의 관련성을 유지하고 대화 제어를 담당한다. 대화(회화) 구성 및 동기 제어, 데이터 교환 관리 기능을 한다. 송•수신 측 간의 데이터 전속, 연결 해제, 동기 처리 등의 대화를 관리하기 위해 토큰이 사용된다. 송•수신 측 가늬 대화 동기를 위해 전송하는 정보의 일정한 부분에 체크점을 두어 정보의 수신 상태를 체크하며, 이때의 체크점을 동기점(Synchronization Point)이라고 한다. 동기점은 오류가 있는 데이터의 회복을 위해 사용하는 것으로 종류에는 소동기점과 대동기점이 있다.

표현 계층(Presentation Layer)
------
　**표현 계층**은 응용 계층으로부터 받은 데이터를 세션 계층으로 보내기 전에 통신에 적당한 형태로 변환하고, 세션 계층에서 받은 데이터는 응용 계층에서 맞게 변환하는 기능을 한다. 서로 다른 데이터 표현 형태를 갖는 시스템 간의 상호 접속을 위해 필요한 계층이다. 코드 변환, 데이터 암호화, 데이터 압축, 구문 검색, 정보 형식(포멧) 변환, 문맥 관리 기능을 한다.

응용 계층(Application Layer)
------
　**응용 계층**은 사용자(응용 프로그램)가 OSI 환경에 접근할 수 있도록 서비스를 제공한다. 응용 프로세스 간의 정보 교환, 전자 서사함, 파일 전송, 가상 터미널 등의 서비스를 제공한다.

네트워크 관련 장비
======

네트워크 인터페이스 카드(NIC; Network Interface Card)
------
　네트워크 인터페이스 카드는 컴퓨터와 컴퓨터 또는 컴퓨터와 네트워크를 연결하는 장치로, 정보 전송 시 정보가 케이블을 통해 전송될 수 있도록 정보 형태를 변경한다. 이더넷 카드(LAN 카드) 혹은 네트워크 어댑터라고도 한다.

허브(Hub)
------
　허브는 한 사무실이나 가까운 거리의 컴퓨터들을 연결하는 장치로, 각 회선을 통합적으로 관리하며, 신호 증폭 기능을 하는 리피터의 역할도 포함한다.
* 더비 허브(Dummy Hub)
  - 네트워크에 흐르는 모든 데이터를 단순히 연결하는 기능만을 제공한다.
  - LAN이 보유한 대역포을 컴퓨터 수만큼 나누어 제공한다.
  - 네트워크에 연결된 각 노드를 물리적인 성형 구조로 연결한다.
* 스위치 허브(Switchong Hub)
  - 네트워크상에 흐르는 데이터의 유무 및 흐름을 제어하여 각각의 노드가 허브의 최대 대역폭을 사용할 수 있는 지능형 허브이다.
  - 최근에 사용되는 허브는 대부분 스위칭 허브이다.

리피터(Repeater)
------
　리피터는 전송되는 신호가 전송 선로의 특성 및 외부 충격 등의 요인으로 인해 원래의 형태와 다르게 외곡되거나 약해질 경우 원래의 신호 형태로 재생하여 다시 전송하는 작업을 수행한다. OSI 참조 모델의 물리 계층에서 동작하는 장비이다. 근접한 네트워크 사이에 신호를 전송하는 역할로, 전송 거리의 연장 또는 배선의 자유도를 높이기 위한 용도로 사용한다.

브리지(Bridge)
------
　브리지는 LAN과 LAN을 연결하거나 LAN 안에서의 컴퓨터 그룹(세그먼트)을 연결하는 기능을 수행한다. 데이터 링크 계층 중 MAC(Media Access Control) 계층에서 사용되므로 MAC 브리지라고도 한다. 네트워크 상의 많은 단말기들에 의해 발생되는 트래픽 병목 현상을 줄일 수 있다. 네트워크를 분산적으로 구성할 수 있어 보안성을 높일 수 있다. 브리즈를 이용한 서브넷(Subnet) 구성 시 전속 가능한 회선 수는 브리지가 n개일 때, n(n-1)/2 개이다.

스위치(Switch)
------
　스위치는 브리지와 같이 LAN과 LAN을 연결하여 훨씬 더 큰 LAN을 만드는 장치이다. 하드웨어를 기반으로 처리하므로 전속 속도가 빠르다. 포트마다 각기 다른 전송 속도를 지원하도록 제어할 수 있고, 수십에서 수백 개의 포트를 제공한다. OSI 참조 모델의 데이터 링크 계층에서 사용된다.

라우터(Router)
------
　라우터는 브리지와 같이 LAN과 LAN의 연결 기능에 데이터 전송의 최적 경로를 선택할 수 있는 기능이 추가된 것으로, 서로 다른 LAN이나 LAN과 WAN의 연결도 수행한다. OSI 참조 모델의 네트워크 계층에서 동작하는 장비이다. 접속 가능한 경로에 대한 정보를 라우팅 제어표(Routng Table)에 저장하여 보관한다. 3계층(네트워크 계층)까지의 프로토콜 구조가 다른 네트워크 간의 연결을 위해 프로토콜 변환 기능을 수행한다.
* 브라우터(Brouter): 브리지와 라우터의 기능을 모두 수행하는 장치로, 브리지 기능은 내부 네트워크를 분리하는 용도로 사용하고 라우터 기능은 외부 네트워크에 연결하는 용도로 사용한다.

게이트워이(Gateway)
------
　게이트웨이는 전 계층(1~7 계층)의 프로토콜 구조가 다른 네트워크의 연결을 수행한다. 세선 계층, 표현 계층, 응요 계층 간을 연결하여 데이터 형식 변환, 주소 변환, 프로토콜 변환 등을 수행한다. LAN에서 다른 네트워크에 데이터를 보내거나 다른 네트워크로부터 데이터를 받아들이는 출입구 역할을 한다.
* 전처리기(FEP; Front End Processor)
  - 통신 회선 및 단말장치 제어, 메시지의 조립과 분해, 전송 메시지 검사 등을 미리 수행하여, 컴퓨터의 부담을 줄여주는 역할을 한다.
  - 호스트 컴퓨터와 다날장치 사이에 고속 통신 회선으로 설치된다.


TCP/IP
======

TCP/IP의 개요(Transmission Control Protocol/Internet Protocol)
------
　TCP/IP는 인터넷에 연결된 서로 다른 기종의 컴퓨더들이 데이터를 주고받을 수 있도록 하는 표준 프로토콜이다. TCP/IP는 UNIX의 기본 프로토콜로 사용되었고, 현재 인터넷 범용 프로토콜로 사용된다. TCP/IP는 다음과 같은 성능을 수행하는 TCP 프로토콜과 IP 프로토콜이 결합된 것을 의미한다.
* TCP(Transmission Control Protocol)
  - OSI 7계층의 전송 계층에 해당한다.
  - 신뢰성 있는 연결형 서비스를 제공한다.
  - 패킷의 다중화, 순서 제어, 흐름 제어 기능을 제공하다.
  - 스트림(Stream) 전송 기능을 제공한다.
  - TCP 헤더에는 Source/Destination Port Number, Sequence Number, Acknoledgment, Checksum 등이 포함된다.
* IP(Internet Protocol)
  - OSI 7계층의 네트워크 계층에 해당한다.
  - 데이터그램을 기반으로 하는 비연결형 서비스를 제공한다.
  - Best Effort 원칙에 따른 전송 기능을 제공한다.
  - 패킷의 분해/조립, 주소 지정, 경로 선택 기능을 제공한다.
  - 헤더의 길이는 최소 20Byte에서 최대 60Byte이다.
  - IP 헤더는 Version, Header Length, Total Packet Length, Header Checksum, Source IP Address, Destination IP Address 등이 포함된다.

TCP/IP의 구조
------
　TCP/IP는 응용 계층, 전송 계층, 인터넷 계층, 네트워크 계층, 엑세스 계층으로 이루어져있다.
|OSI|TCP/IP|기능|
|---|---|---|
|응용 계층, 표현 계층, 세션 계층|응용 계층|응용 프로그램 간의 데이터 송•수신이 제공된다.<br/>TELNET, FTP, SMTP, DNS, HTTP 등|
|전송 계층|전송 계층|호스트들 간의 신뢰성 있는 통신을 제공한다.<br/>TCP, UDP|
|네트워크 계층|인터넷 계층|데이터 전송을 위한 주소 지정, 경로 설정을 제공한다.<br/>IP, ICMP, IGMP, ARP, RARP|
|데이터 링크 계층, 물리 계층|네트워크 엑세스 계층|실제 데이터(프레임)를 송•수신하는 역할을 한다<br/>Ethernet, IEEE 802, HDLC, X.25, RS-232C, ARQ 등|

응용 계층의 주요 프로토콜
------
* **FTP(File Transfer Protocol)**
  - 컴퓨터와 컴퓨터 또는 컴퓨터와 인터넷 사이에서 파일을 주고받을 수 있도록 하는 원격 파일 전송 프로토콜이다.
* **SMTP(Simple Mail Transfer Protocol)**
  - 전자 우편을 전송하는 프로토콜이다.
* **TELNET**
  - 멀리 떨어져 있는 컴퓨터에 접속하여 자신의 컴퓨터처럼 사용할 수 있도록 해주는 서비스이다.
  - 프로그램을 실행하는 등 시스템 관리 작업을 할 수 있는 가상의 터미널(Virtual Terminal) 기능을 수행한다.
* **SNMP(Simple Network Management Protocol)**
  - TCP/IP의 네트워크 관리 프로토콜로, 라우터나 허브 등 네트워크 기기의 네트워크 정보를 네트워크 관리 시스템에 보내는 데 사용되는 표준 통신 규약이다.
* **DNS(Domain Name System)**
  - 도메인 네임을 IP 주소로 매핑(Mapping)하는 시스템이다
* **HTTP(Hyper Text Transfer Protocol)**
  - 월드 와이드 웹(WWW)에서 HTML 문서를 송수신 하기 위한 표준 프로토콜이다.
* **MQTT(Message Queuinf Telemetry Transport)**
  - 발행-구독 기반의 메시징 프로토콜로, IoT 환경에서 주로 사용된다.

전송 계층의 주요 프로토콜
------
* **TCP(Transmisson Control Protocol)**
  - 양뱡향 연결(Full Duplex Connection)형 서비스를 제공한다.
  - 가상 회선 연결(Virtual Circuit Connection) 형태의 서비스를 제공한다.
  - 스트림 위주의 전달(패킷 단위)을 한다.
  - 신뢰성 있는 경로를 확립하고 메시지 전송을 감독한다.
  - 순서 제어, 오류 제어, 흐름 제어 기능을 한다.
  - 패킷의 분실, 손상, 지연이나 순서가 틀린 것 등이 발생할때 투명성이 보장되는 통신을 제공한다.
  - TCP 프로토콜의 헤더는 기본적으로 20Byte에서 60Byte까지 사용할 수 있는데, 선택적으로 40Byte를 더 추가할 수 있으므로 최대 100Byte까지 크기를 확장할 수 있다.
* **UDP(User Datagram Protocol)**
  - 데이터 전송 전에 연결을 설정하지 않는 비연결형 서비스를 제공한다.
  - TCP에 비해 상대적으로 단순한 헤더 구조를 가지므로, 오버헤드가 적고, 흐름 제어나 순서 제어가 없어 전송 속도가 빠르다.
  - 고속의 안전성이 있는 전송 매체를 사용하여 빠른 속도를 필요로 하는 경우, 동시에 여러 사용자에게 데이터를 전달할 경우, 정기적으로 반복해서 전송할 경우에 사용한다.
  - 실시간 전송에 유리하며, 신뢰성보다는 속도가 중요시되는 네트워크에서 사용된다.
  - UDP 헤더에는 Source Port Number, Destination Port Number, Length, Checksum 등이 포함된다.
* **RTCP(Real-Time Control Protocol)**
  - RTP(Real-time Transport Protocol) 패킷의 전송 품질을 제어하기 위한 제어 프로토콜이다.
  - 세션(Session)에 참여한 각 참여자들에게 주기적으로 제어 정보를 전송한다.
  - 하위 프로토콜은 데이터 패킷과 제어 패킷의 다중화(Multiplexing)를 제공한다.
  - 데이터 전송을 모니터링하고 최소한의 제어와 인증 기능만을 제공한다.
  - RTCP 패킷은 항상 32비트의 경계로 끝난다.

인터넷 계층의 주요 프로토콜
------
* **IP(Internet Protocol)**
  - 전송할 데이터에 주소를 지정하고, 경로를 설정하는 기능을 한다.
  - 비연결형인 데이터그램 방식을 사용하는 것으로 신뢰성이 보장되지 않는다.
* **ICMP(Internet Control Message Protocol, 인터넷 제어 메시시 프로토콜)**
  - IP와 조합하여 통신중에 발생하는 오류의 처리와 전송 경로 변경 등을 위한 제어 메시지를 관리하는 역할을 하며, 헤더는 8Byte로 구성된다.
* **IGMP(Internet Group Management Protocol, 인터넷 그룹 관리 프로토콜)**
  - 멀티케스트를 지원하는 호스트나 라우터 사이에서 멀티케스트 그룹 유지를 위해 사용된다.
* **ARP(Address Resolution Protocol, 주소 분석 프로토콜)**
  - 호스트와 IP 주소를 호스트와 연결된 네트워크 접속 장치의 물리적 주소(MAC Address)로 바꾼다.
* **RARP(Reverse Address Resolution Protocol)**
  - ARP와 반대로 물리적 주소를 IP주소로 변경하는 기능을 한다.

네트워크 엑세스 계층의 주요 프로토콜
------
* **Etherner(IEEE 802.3)**
  - CSMA/CD 방식의 LAN
* **IEEE 802**
  - LAN을 위한 표준 프로토콜
* **HDLC**
  - 비트 위주의 데이터 링크 제어 프로토콜
* **X.25**
  - 패킷 교환망을 통한 DTE와 DCE간의 인터페이스를 제공하는 프로토콜
* **RS-232C**
  - 공중 전화 교환망(PSTN)을 통한 DTE와 DCE 간의 인터페이스를 제공하는 프로토콜