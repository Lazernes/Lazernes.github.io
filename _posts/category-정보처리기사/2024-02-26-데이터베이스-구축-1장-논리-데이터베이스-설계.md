---
title: "데이터베이스 구축 1장 논리 데이터베이스 설계"
excerpt: "논리 데이터베이스 설계"

wirter: Myeongwoo Yoon
categories:
  - 정보처리기사
tags:
  - 정보처리기사

toc: true
toc_sticky: true
use_math: true
 
date: 2024-02-26
last_modified_at: 2024-02-26
---

데이터베이스 설계
======

데이터베이스 설계의 개념
------
　데이터베이스 설계란 사용자의 요구를 분석하여 그것들을 컴퓨터에 저장할 수 있는 데이터베이스의 구조에 맞게 변형한 후 특정 DBMS로 데이터베이스를 구현하여 일반 사용자들이 사용하게 하는 것이다.

데이터베이스 설계 시 고려사항
------

* **무결성**: 삽입, 삭제, 갱신 등의 연산 후에도 데이터베이스에 저장된 데이터가 정해진 제약 조건을 항상 만족해야 한다.
* **일관성**: 데이터베이스에 저장된 데이터들 사이나, 특정 질의에 대한 응답이 처음부터 끝까지 변함없이 일정해야 한다.
* **회복**: 시스템에 장애가 발생했을 때 장애 발생 직전의 상태로 복구할 수 있어야 한다.
* **보안**: 불법적인 데이터의 노출 또는 병경이나 손실로부터 보호할 수 있어야 한다.
* **효율성**: 응답시간의 단축, 시스템의 생산성, 저장 공간의 최적화 등이 가능해야 한다.
* **데이터베이스 확장**: 데이터베이스 운영에 영향을 주지 않으면서 지속적으로 데이터를 추가할 수 있어야 한다.

데이터베이스 설계 순서
------
* 요구 조건 분석: 요구 조건 명세서 작성
* 개념적 설계: 개념 스키마, 트랜잭션 모델링, E-R 모델
* 논리적 설계: 목표 DBMS에 맞는 논리 스키마 설계, 트랜잭션 인터페이스 설계
* 물리적 설계: 목표 DBMS에 맞는 물리적 구조의 데이터로 변환
* 구현: 목표 DBMS의 DDL(데이터 정의어)로 데이터베이스 생성, 트랜잭션 작성

요구 조건 분석
------
　요구 조건 분석은 데이터베이스를 사용할 사람들로부터 필요한 용도를 파악하는 것이다. 데이터베이스 사용자에 따른 수행 업무와 필요한 데이터의 종류, 용도, 처리 형태, 흐름, 제약 조건 등을 수집한다. 수집된 정보를 바탕으로 요구 조건 명세를 작성한다.

개념적 설계(정보 모델링, 개념화)
------
　개념적 설계란 정보의 구조를 얻기 위하여 현실 세계의 무한성과 게속성을 이해하고, 다른 사란과 통신하기 위하여 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정이다. 개념적 설계 단계에서는 개념 스키마 모델링과 트랜잭션 모델링을 병행 수행한다. 개념적 설계 단계에서는 요구 분석 단계에서 나온 결과인 요구 조건 명세를 DBMS에 독립적인 E-R 다이어그램을 작성한다. DBMS에 독립적인 스키마를 작성한다.

논리적 설계(데이터 모델링)
------
　논리적 설계 단계란 현실 세계에서 발생하는 자료를 컴퓨터가 이해하고 처리할 수 있는 물리적 저장장치에 저장할 수 있도록 변환하기 위해 특정 DBMS가 지원하는 논리적 자료 구조로 변환(mapping)시키는 과정이다. 개념 세계의 데이터를 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계로 표현되는 논리적 구조의 데이터로 모델화 한다. 개념적 설계가 개념 스키마를 설계하는 단계라면 논리적 설계에서는 개념 스키마를 평가 및 정재하고 DBMS에 따라 서로 다른 논리적 스키마를 설계하는 단계이다. 트랜잭션의 인터페이스를 설계한다. 관계형 데이터베이스라면 테이블을 설계하는 단계이다.

물리적 설계(데이터 구조화)
------
　물리적 설계란 논리적 설계 단계에서 논리적 구조로 표현된 데이터를 디스크 등의 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정이다. 물리적 설계 단계에서는 다양한 데이터베이스 응용에 대해 처리 성능을 얻기 위해 데이터베이스 파일의 저장 구조 및 액세스 경로를 결정한다. 저장 레코드의 양식, 순서, 접근 경로, 조회가 집중되는 레코드와 같은 정보를 사용하여 데이터가 컴퓨터에 저장되는 방법을 묘사한다. 트랜잭션 처리량, 응답 시간, 디스크 용량, 저장 공간의 효율화 등을 고려한다.

데이터베이스 구현
------
　데이터베이스 구현 단계란 논리적 설계 단계와 물리적 설계 단계에서 도출된 데이터베이스 스키마를 파일로 생성하는 것이다. 사용하려는 특정 DBMS의 DDL(데이터 정의어)을 이용하여 데이터베이스 스키마를 기술한 후 컴파일하여 빈 데이터베이스 파일을 생성한다. 생성된 빈 데이터베이스 파일에 데이터를 입력한다. 응용 프로그램을 위한 트랜잭션을 작성한다. 데이터베이스 접근을 위한 응용 프로그램을 작성한다.

데이터 모델의 개념
======

데이터 모델의 정의
------
　데이터 모델은 현실 세계의 정보들을 컴퓨터에 표현하기 위해 단순화, 추상화하여 체계적으로 표현한 개념적 모형이다. 데이터 모델은 데이터, 데이터의 관계, 데이터의 의미 및 일관성, 제약 조건 등을 기술하기 위한 개념적 도구들의 모임이다. 현실 세계를 데이터베이스에 표현하는 중간 과정, 즉 데이터베이스 설계 과정에서 데이터의 구조(Schema)를 논리적으로 표현하기 위해 사용되는 지능적 도구이다.
* **데이터 모델의 구성 요소**: 개체, 속성, 관계
* **데이터 모델 종류**: 개념적 데이터 모델, 논리적 데이터 모델, 물리적 데이터 모델
* **데이터 모델에 표시할 요소**: 구조, 연산, 제약 조건

데이터 모델의 구성 요소
-----
* **개체(Entity)**: 데이터베이스에 표현하려는 것으로, 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체이다.
* **속성(Attribute)**: 데이터의 가장 작은 논리적 단위로서 파일 구조상의 데이터 항목 또는 데이터 필드에 해당한다.
* **관계(Relationship)**: 개체 간의 관계 또는 속성 간의 논리적인 연결을 의미한다.

개념적 데이터 모델
------
　개념적 데이터 모델은 현실 세계에 대한 인간의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정이다. 개념적 데이터 모델은 속성들로 기술된 개체 타입과 이 개체 타입들 간의 관계를 이용하여 현실 세계를 표현한다. 개념적 데이터 모델은 현실 세계에 존재하는 개체를 인간이 이해할 수 있는 정보 구조로 표현하기 때문에 정보 모델이라고도 한다. 대표적인 개념적 데이터 모델로는 E-R 모델이 있다.

논리적 데이터 모델
------
　논리적 데이터 모델은 개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터가 이해하고 처리할 수 있는 컴퓨터 세계의 환경에 맞도록 변환하는 과정이다. 논리적 데이터 모델은 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계를 이용하여 현실 세계를 표현한다. 단순히 데이터 모델이라고 하면 논리적 데이터 모델을 의미한다. 특정 DBMS는 특정 논리적 데이터 모델 하나만 선정하여 사용한다. 논리적 데이터 모델은 데이터 간의 관계를 어떻게 표현하느냐에 따라 관계 모델, 계층 모델, 네트워크 모델로 구분한다.

데이터 모델에 표시할 요소
------
* **구조(Structure)**: 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질을 표현한다.
* **연산(Operation)**: 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 데이터베이스를 조작하는 기본 도구이다.
* **제약 조건(Constraint)**: 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건이다.

E-R(개체-관계) 모델
======

E-R(Entity-Relationship, 개체-관계) 모델의 개요
------
　**E-R 모델**은 개념적 데이터 모델의 가장 대표적인 것으로 개체와 개체 간의 관계를 기본 요소로 이용하여 현실 세계의 무질서한 데이터를 개념적인 논리 데이터로 표현하기 위한 방법으로 많이 사용되고 있다. E-R 모델은 개체 타입(Entity Type)와 이들 간의 관계 타입(Relationship Type)을 이용해 현실 세계를 개념적으로 표현하고 데이터를 개체(Entity), 관계(Relationship), 속성(Attribute)으로 묘사한다. E-R 모델은 특정 DBMS를 고려한 것은 아니고 다이어그램으로 표현하며, 1:1, 1:N, N:M 등의 관계 유형을 제한 없이 나타낼 수 있다.

E-R 다이어그램(Entity-Relationship Diagram)
------
　**E-R 다이어그램**은 E-R 모델의 기본 아이디어를 시각적으로 표현하기 위한 그림으로, 실체 간의 관계는 물론 조직, 사용자, 프로그램, 데이터 등 시스템 내에서 역할을 가진 모든 실체들을 표현한다.
<p align="center"><img src="/assets/img/정보처리기사/데이터베이스 구축/논리 데이터베이스 설계/3-1.jpeg" width="500"></p>

관계형 데이터베이스의 구조
======

관계형 데이터베이스의 개요
------
　관계형 데이터베이스를 구성하는 개체(Entity)나 관계(Relationship)를 모두 릴레이션(Relation)이라는 표(Table)로 표현한다. 릴레이션은 개체를 표현하는 개체 릴레이션, 관계를 나타내는 관계 릴레이션으로 구분할 수 있다. 장점으로는 간결하고 보기 편리하며, 다른 데이터베이스로의 변환이 용이하지만, 단점으로는 성능이 다소 떨어진다.

관계형 데이터베이스의 Relation 구조
------
　릴레이션은 데이터들을 표(Table)의 형태로 표현한 것으로 구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레이션 인스턴스로 구성된다.
<p align="center"><img src="/assets/img/정보처리기사/데이터베이스 구축/논리 데이터베이스 설계/4-1.jpeg" width="600"></p>

* **튜플(Tuple)**
  - 튜플은 릴레이션을 구성하는 각각의 행을 말한다.
  - 튜플은 속성의 모임으로 구성된다.
  - 파일 구조에서 레코드와 같은 의미이고 튜플의 수를 카디널리티(Cardinality) 또는 기수, 대응수라고 한다.
* **속성(Attribute)**
  - 속성은 데이터베이스를 구성하는 가장 작은 논리적 단위이다.
  - 파일 구조상의 데이터 항목 또는 데이터 필드에 해당한다.
  - 속성은 개체의 특성을 기술하고 속성의 수를 디그리(Degree) 또는 차수라고 한다.
* **도메인(Domain)**
  - 도메인은 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자(Atomic)값들의 집합이다.
  - 도메인은 실제 애트리뷰트 값이 나타날 때 그 값의 합법 여부를 시스템이 검사하는데에도 이용된다.

릴레이션의 특징
------
* 한 릴레이션에는 똑같은 튜플이 포함될 수 없으므로 릴레이션에 포함된 튜플들은 모두 상이하다.
* 한 릴레이션에 포함된 튜플 사이에는 순서가 없다.
* 튜플들의 삽입, 삭제 등의 작업으로 릴레이션은 시간에 따라 변한다.
* 릴레이션 스키마를 구성하는 속성들 간의 순서는 중요하지 않다.
* 속성의 유일한 식별을 위해 명칭은 유일해야 하지만, 속성을 구성하는 값은 동일한 값이 있을 수 있다.
* 릴레이션을 구성하는 튜플을 유일하게 식별하기 위해 속성들의 부분집합을 키(Key)로 성절한다.
* 속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자값만을 저장한다.

관계형 데이터베이스의 제약 조건 - 키(Key)
======
　제약 조건이란 데이터베이스에 저장되는 데이터의 정확성을 보장하기 위하여 키(Key)를 이용하여 입력되는 데이터에 제한을 주는 것으로 개체 무결성 제약, 참조 무결성 제약 등이 해당된다.

키(Key)의 개념 및 종류
------
　키는 데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 튜플들을 서로 구분할 수 있는 기준이 되는 애트리뷰트를 말한다. 키의 종류에는 후보키, 기본티, 대체키, 외래키 등이 있다.

후보키(Candidate Key)
------
　**후보키**는 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합, 즉 기본키로 사용될 수 있는 속성들을 말한다. 하나의 릴레이션내에서는 중복된 튜플들이 있을 수 없으므로 모든 릴레이션에는 반드시 하나 이상의 후보키가 존재한다. 후보키는 릴레이션에 있는 모든 튜플에 대해서 유일성과 최소 식별성을 만족시켜야 한다.
* **유일성(Unique)**: 하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 한다.
* **최소성(Minimality)**: 모든 레코드들을 유일하게 식별하는 데 꼭 필요한 속성으로만 구성되어야 한다.

기본키(Primary Key)
------
　**기본키**는 후보키 중에서 특별히 선정된 주키(Main Key)로 중복된 값을 가질 수 없다. 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성이다. 기본키는 후보키의 성질을 갖는다. 즉, 유일성과 최소헝을 가지며 튜플을 식별하기 위해 반드시 필요한 키이다. 기본키는 NULL 값을 가질 수 없다. 즉, 튜플에서 기본키로 설정된 속성에는 NULL 값이 있어서는 안된다.

대체키(Alternate Key)
------
　**대체키**는 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키를 의미하고 보조키라고도 한다.

슈퍼키(Super Key)
------
　**슈퍼키**는 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로서 릴레이션을 구성하는 모든 튜플들 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않는다. 슈퍼키는 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족시키지만, 최소성은 만족시키지 못한다.

외래키(Foreign Key)
------
　**외래키**는 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합을 의미한다. 외래키는 참조되는 릴레이션의 기본키와 대응되어 릴레이션 간에 참조 관계를 표현하는데 중요한 도구이다. 한 릴레이션에 속한 속성 A와 참조 릴레이션의 기본키인 B가 동일한 도메인 상에서 정의되었을 때의 속성 A를 외래키라고 한다. 외랰로 지정되면 참조 릴레이션의 기본키에 없는 값은 입력할 수 없다.

관계형 데이터베이스의 제약 조건 - 무결성
======

무결성(Integrity)의 개념 및 종류
------
　**무결성**이란 데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제 값이 항상 일치하는 정확성을 의미한다. 무결성 제약 조건은 데이터베이스에 들어있는 데이터의 정확성을 보장하기 위해 부정확한 자료가 데이터베이스 내에 저장되는 것을 방지하기 위한 제약 조건을 말한다. 무결성의 종류에는 개체 무결성, 도메인 무결성, 참조 무결성, 사용자 정의 무결성 등이 있다.

개체 무결성(Entity Integrity, 실체 무결성)
------
　**개체 무결성**은 기본 테이블의 기본키를 구성하는 어떤 속성도 NULL 값이나 중복값을 가질 수 없다는 규정이다.

도메인 무결성(Domain Integrity, 영역 무결성)
------
　**도메인 무결성**은 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정이다.

참조 무결성(Referential Integrity)
------
　**참조 무결성**은 외래키 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일해야 한다. 외래키와 참조하려는 테이블의 기본키는 도메인과 속성 개수가 같아야 한다.

사용자 정의 무결성(User-Defined Integrity)
------
　**사용자 정의 무결성**은 속성 값들이 사용자가 정의한 제약조건에 만족해야 한다는 규정이다.

데이터 무결성 강화
------
　데이터 무결성은 데이터 품질에 직접적인 영향을 미치므로 데이터 특성에 맞는 적절한 무결성을 정의하고 강화해야 한다. 프로그램이 완성되고 데이터가 저장된 상태에서 무결성을 정의할 경우 많은 비용이 발생하므로 데이터베이스 구축 과정에서 정의한다. 데이터 무결성은 애플리케이션, 데이터베이스 트리거, 제약 조건을 이용하여 강화할 수 있다.
* 애플리케이션
  - 데이터 생성, 수정, 삭제 시 무결성 조건을 검증하는 코드를 데이터를 조작하는 프로그램 내에 추가한다.
  - 코드를 이용한 복잡한 규칙 등을 검토하는 무결성 검사는 데이터베이스에서 수행하기 어려우므로 애플리케이션 내에서 처리한다.
  - 장점: 사용자 정의 같은 복잡한 무결성 조건의 구현이 가능하다.
  - 단점: 소스 코드에 분산되어 있어 관리가 힘들고, 개별적인 시행으로 인해 적정성 검토가 어렵다.
* 데이터베이스 트리거
  - 트리거 이벤트에 무결성 조건을 실행하는 절차형 SQL을 추가한다.
  - 장점: 통합 관리가 가능하고, 복잡한 요구 조건의 구현이 가능하다.
  - 단점: 운영 중 변경이 어렵고, 사용상 주의가 필요하다.
* 제약 조건
  - 데이터베이스에 제약 조건을 설정하여 무결성을 유지한다.
  - 장점: 통합 관리 기능, 간단한 선언으로 구현 가능, 변경 용이, 오류 데이터 발생 방지 등이 있다.
  - 단점: 복잡한 제약 조건의 구현과 예외적인 처리가 불가능하다.

관계대수 및 관계해석
======

관계대수의 개요
------
　**관계대수**는 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어이다. 관계대수는 릴레이션을 처리하기 위해 연산자와 연산규칙을 제공하는 언어로 피연산자가 릴레이션이고, 결과도 릴레이션이다. 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시한다. 관계대수에는 관계 데이터베이스에 적용하기 위해 특별히 개발한 순수 관계 연산자와 수학적 집합 이론에서 사용하는 일반 집합 연산자가 있다.
* 순수 관계 연산자: Select, Project, Join, Division
* 일반 집합 연산자: UNION(합집합), INTERSECTION(교집합), DIFERENCE(차집합), CARTESIAN PRODUCT(교차곱)

Select
------
　Select는 릴레이션에 존재하는 튜플 중에서 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산이다. 릴레이션의 행(가로)에 해당하는 튜플을 구하는 것이므로 수평 연산이라고도 한다. 연산자의 기호는 그리스 문자 시그마($\sigma$)를 사용한다.
* 표기 형식: $\sigma_{(조건)}(R)$
  - R은 리레이션 이름이다.
  - 조건에서는 $=, \ne, <, \le, >, \ge$ 등의 기호를 사용한 비교 연산이 허용되며, AND($\land$), OR($\lor$), NOT($\lnot$) 등의 논리 연산자를 사용하여 여러 개의 조건들을 하나의 조건으로 결합시킬 수도 있다.

Project
------
　Project는 주어진 릴레이션에서 속성 리스트(Attribute List)에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산이다. 단 연산 결과에 중복이 발생하면 중복이 제거된다. 릴레이션의 열(세로)에 해당하는 Attribute를 추출하는 것이므로 수직 연산자라고도 한다. 연산자의 기호는 그리스 문자로 파이($\pi$)를 사용한다.
* 표기 형식: $\pi_{(속성리스트)}(R)$
  - R은 릴레이션 이름이다.

Join
------
　Join은 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산이다. Join의 결과로 만들어진 릴레이션의 차수는 조인된 두 릴레이션의 차수를 합한 것과 같다. Join의 결과는 Cartesian Product(교차곱)을 수행한 다음 Select를 수행한 것과 같다. 연산자의 기호는 $\bowtie$를 사용한다.
* 표기형식: $R \bowtie_{키속성_r = 키속성_s} S$
  - 키 속성 r은 릴레이션 R의 속성이고, 키 속성 s는 릴레이션 S의 속성이다.

Division
------
　Division은 $X \subset Y$인 두 개의 릴레이션 R(X)와 S(Y)가 있을 때, R의 속성이 S의 속성 값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산이다. 연산자의 기호는 $\div$를 사용한다.
* 표기형식: $R[속성r \div 속성s]S$
  - 속성 r은 릴레이션 R의 속성, 속성 s는 릴레이션 S의 속성, 속성r과 속성s는 동일한 속성값을 가지는 속성이어야 한다.

일반 집합 연산자
------
　일반 집합 연산자는 수학적 집합 이론에서 사용하는 연산자로서 릴레이션 연산에도 그대로 적용할 수 있다. 일반 집합 연산자 중 UNION(합집합), INTERSECTION(교집합), DIFERENCE(차집합)을 처리하기 위해서는 합병 조건을 만족해야 한다.

|연산자|기능 및 수학적 표현|카디널리티|
|---|---|---|
|합집합(UNION, $\cup$)|두 릴레이션에 존재하는 튜플의 합집합을 구하되, 결과로 생성된 릴레이션에서 중복되는 튜플은 제거되는 연산이다.<br/>$R \cup S$|합집합의 카디널리티는 두 릴레이션 카디널리티의 합보다 크지 않다.|
|교집합|두 릴레이션에 존재하는 튜플의 교집합을 구하는 연산이다.<br/>$R \cap S$|교집합의 카디널리티는 두 릴레이션 중 카디널리티가 적은 릴레이션의 카디널리티보다 크지 않다.|
|차집합|두 릴레이션에 존재하는 튜플의 차집합을 구하는 연산이다.<br/>$R - S$|차집합의 카디널리티는 릴레이션 R의 카디널리티 보다 크지 않다.|
|교차곱|두 릴레이션에 있는 튜플들의 순서쌍을 구하는 연산이다.<br/>$R \times S$|교차곱의 디그리는 두 릴레이션의 디그리를 더한 것과 같고, 카디널리티는 두 릴레이션의 카디널리티를 곱한 것과 같다.|

관계해석(Relational Calculus)
------
　관계해석은 관계 데이터의 연산을 표현하는 방법으로, 원하는 정보를 정의할 때는 계산 수식을 사용한다. 관계해석은 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성을 지닌다. 튜플 관계해석과 도메인 관계해석이 있다.<br/>
　기본적으로 관계해석과 관계대수는 관계 데이터베이스를 처리하는 기능과 능력면에서 동등하며, 관계대수로 표현한 식은 관계해석으로 표현할 수 있다. 질의어로 표현된다. 주요 논리 기호는 다음과 같다.

|기호|구성 요소|설명|
|---|---|---|
|$\forall$|전칭 정량자|가능한 모든 튜플에 대하여(For All)|
|$\exists$|존재 전량자|하나라도 일치하는 튜플이 있음(There Exists)|


정규화(Nomalization)
======

정규화의 개요
------
　**정규화**란 함수적 종속성 등의 종속성 이론을 이용하여 잘못 설계된 관계형 스키마를 더 작은 속성의 세트로 쪼개어 바람직한 스키마로 만들어 가는 과정이다. 하나의 종속성이 하나의 릴레이션에 포현될 수 있도록 분해하는 과정이라고 할 수 있다.<br/>
　정규형에는 제1정규형, 제2정규형, 제3정규형, BCNF형, 제4정규형, 제5정규형이 있으며, 차수가 높아질수록 만족시켜야 할 제약 조건이 늘어난다. 정규화는 데이터베이스의 논리적인 설계 단계에서 수행되고 논리적 처리 및 품질에 큰 영향을 미친다. 정규화된 데이터 모델은 일관성, 정확성, 단순성, 비중복성, 안정성 등을 보장한다. 정규화 수준이 높을수록 유연한 데이터 구축이 가능하고 데이터의 정확성이 높아지는 반면 물리적 접근이 복잡하고 너무 많은 조인으로 인해 조회 성능이 저하된다.

정규화의 목적
------
* 데이터 구조의 안정성 및 무결성을 유지한다.
* 어떠한 릴레이션이라고 데이터베이스 내에서 표현 가능하게 만든다.
* 효과적인 검색 알고리즘을 생성할 수 있다.
* 데이터 중복을 배제하여 이상(Anomaly)의 발생 방지 및 자료 저장 공간의 최소화가 가능하다.
* 데이터 삽입 시 릴레이션을 재구성할 필요성을 줄인다.
* 데이터 모형의 단순화가 가능하다.
* 속성의 배열 상태 검증이 가능하다.
* 개체와 속성의 누락 여부 확인이 가능하다.
* 자료 검색과 추출의 효율성을 추구한다.

이상(Anomaly)의 개념 및 종류
------
　정규화를 거치지 않으면 데이터베이스 내에 데이터들이 불필요하게 중복되어 릴레이션 조작 시 예기치 못한 곤란한 형상이 발생하는데, 이를 이상(Anomaly)이라 하며 삽입 이상, 삭제 이상, 갱신 이상이 있다.

* 삽입 이상(Insert Anomaly): 릴레이션에 데이터를 삽입할 때 의도와는 상관없이 원하지 않은 값들도 함께 삽입되는 현상이다.
* 삭제 이상(Delete Anomaly): 릴레이션에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 연쇄가 일어나는 현상이다.
* 갱신 이상(Update Anomaly): 릴레이션에서 튜플에 있는 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상이다.

정규화의 원칙
------
* 정보의 무손실 표현, 즉 하나의 스키마를 다른 스키마로 변환할 때 정보으 손실이 있어서는 안된다.
* 분리의 원칙, 즉 하나의 독립된 관계성은 하나의 독립된 릴레이션으로 분리시켜 표현해야 한다.
* 데이터의 중복성이 감소되어야 한다.

정규화 과정
------
* **1NF(제1정규형)**
  - 1NF는 릴레이션에 속한 모든 도메인(Domain)이 원자값(Atomic Value)만으로 되어 있는 정규형이다. 즉, 릴레이션의 모든 속성 값이 원자 값으로만 되어 있는 정규형이다. 릴레이션의 모든 속성이 단순 영역에서 정의된다.
* **2NF(제2정규형)**
  - 2NF는 릴레이션 R이 1NF이고, 기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족하는 정규형이다.
* **3NF(제3정규형)**
  - 3NF는 릴레이션 R이 2NF이고, 기본키가 아닌 모든 속성이 기본키에 대해 이행적 종속을 만족하지 않는 정규형이다. 무손실 조인 또는 종속성 보존을 저해하지 않고도 항상 3NF 설계를 얻을 수 있다.
* **BCNF(Boyce-Code 정규형)**
  - BCNF는 릴레이션 R에서 결정자가 모두 후보키(Candidate Key)인 정규형이다. 3NF에서 후보키가 여러 개 존재하고 서로 중첩되는 경우에 적용하는, 강한 제3정규형이라고도 한다. 모든 BCNF가 종속성을 보존하는 것은 아니다.
  - BCNF의 제약 조건: 키가 아닌 모든 속성은 각 키에 대하여 완전 종속해야 한다. 키가 아닌 모든 속성은 그 자신이 부분적으로 들어가 있지 않은 모든 키에 대하여 완전 종속해야 한다. 어떤 속성도 키가 아닌 속성에 대해서는 완전 종속할 수 없다.
* **4NF(제4정규형)**
  - 4NF는 릴레이션 R에 다치 종속 A$\twoheadrightarrow$B가 성립하는 경우 R의 모든 속성이 A에 함수적 종속 관계를 만족하는 정규형이다.
* **5NF(제5정규형)**
  - 5NF는 릴레이션 R의 모든 조인 종속이 R의 후보키를 통해서만 성립되는 정규형이다.

<p align="center"><img src="/assets/img/정보처리기사/데이터베이스 구축/논리 데이터베이스 설계/8-1.jpeg" width="400"></p>

반정규화(Denormalization)
======

반정규화의 개요
------
　**반정규화**란 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로, 의도적으로 정규화 원칙을 위배한는 행위이다. 반정규화를 수행하면 시스템의 성능이 향상되고 괸리 효율성은 증가하지만 데이터의 일관성 및 정합성이 저하될 수 있다. 과도한 벙정규화는 오히려 성능을 저하시킬 수 있다.<br/>
　반정규화를 위해서는 사전에 데이터의 일관성과 무결성을 우선으로 할지, 데이터베이스의 성능과 단순화를 우선으로 할지를 결정해야 한다. 반정규화 방법에는 데이터 통합, 데이터 분할, 중복 테이블 추가 등이 있다.

테이블 통합
------
　테이블 통합은 두 개의 테이블이 조인(Join)되는 경우가 많아 하나의 테이블로 합쳐 사용하는 것이 성능 향상에 도움이 될 경우 수행한다. 두 개의 테이블에서 발생하는 프로세스가 동일하게 자주 처리되는 경우, 두 개의 테이블을 이용하여 항상 조회를 수행하는 경우 테이블 통합을 고려한다.<br/>
　테이블 통합의 종류에는 1:1 관계 테이블 통합, 1:N 관계 테이블 통합, 슈퍼타입/서브타입 테이블 통합이 있다. 테이블 통합 시 고려 사항은 다음과 같다.
* 테이터 검색은 간편하지만 레코드 증가로 인해 처리량이 증가한다.
* 테이블 통합으로 인한 입력, 수정, 삭제 규칙이 복잡해질 수 있다.
* Not Null, Default, Check 등의 제약조건(Constraint)을 설계하기 어렵다.

테이블 분할
------
　테이블 분할은 테이블을 수직 또는 수평으로 분리하는 것이다.
* 수평 분할(Horizontal Partitioning)
  - 수평 분할은 레코드(Record)를 기준으로 테이블을 분할하는 것이다.
  - 레코드별로 사용 빈도의 차이가 큰 경우 사용 빈도에 따라 테이블을 분할한다. 
* 수직 분할(Vertical Partitioning)
  - 수직 분할은 하나의 테이블에 속성이 너무 많을 경우 속성을 기준으로 테이블을 분할하는 것이다.
  - 갱신 위주의 속성 분할: 데이터 갱신 시 레코드 잠금으로 인해 다른 작업을 수행할 수 없으므로 갱신이 자주 일어나는 속성들을 수직 분할하여 사용한다.
  - 자주 조회되는 속성 분할: 테이블에서 자주 조회되는 속성이 극히 일부일 경우 자주 사용되는 속성들을 수직 분할하여 사용한다.
  - 크기가 큰 속성 분할: 이미지나 2GB 이상 저장될 수 있는 텍스트 형식 등으로 된 속성들을 수직 분할하여 사용한다.
  - 보안을 적용해야 하는 속성 분할: 테이블 내의 특정 속성에 대해 보안을 적용할 수 없으므로 보안을 적용해야 하는 속성들을 수직 분할하여 사용한다.

　테이블 분할 시 고려 사항은 다음과 같다.
* 기본키의 유일성 관리가 어려워진다.
* 데이터 양이 적거나 사용 빈도가 낮은 경우 테이블 분할이 필요한지를 고려해야 한다.
* 분할된 테이블로 인해 수행 속도가 느려질 수 있다.
* 데이터 검색에 중점을 두어 테이블 분할 여부를 결정해야 한다.

중복 테이블 추가
------
　여러 테이블에서 데이터를 추출해서 사용해야 하거나 다름 서버에 저장된 테이블을 이용해야 하는 경우 중복 테이블을 추가하여 작업의 효율성을 향상시킬 수 있다. 중복 테이블을 추가하는 경우는 다음과 같다.
* 정규화로 인해 수행 속도가 느려지는 경우
* 많은 범위의 데이터를 자주 처리해야 하는 경우
* 특정 범위의 데이터만 자주 처리해야 하는 경우
* 처리 범위를 줄이지 않고는 수행 속도를 개선할 수 없는 경우

　중복 테이블을 추가하는 방법은 다음과 같다.
* 집계 테이블의 추가: 집계 데이터를 위한 테이블을 추가하는 테이블을 생성하고, 각 원본 테이블에 트리거(Trigger)를 설정하여 사용하는 것으로, 트리거의 오버헤드(Overhead)에 유의해야 한다.
* 집행 테이블의 추가: 이력 관리 등의 목적으로 추가하는 테이블로, 적절한 데이터 양의 유지와 활용도를 높이기 위해 기본키를 적절히 설정한다.
* 특정 부분만을 포함하는 테이블의 추가: 데이터가 많은 테이블의 특정 부분만을 사용하는 경우 해당 부분만으로 새로운 테이블을 생성한다.

중복 속성 추가
------
　중복 속성 추가는 조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 하나 더 추가하는 것이다. 중복 속성을 추가하면 데이터의 무결성 확보가 어렵고, 디스크 공간이 추가로 필요하다. 중복속성을 추가하는 경우는 다음과 같다.
* 조인이 자주 발생하는 속성인 경우
* 접근 경로가 복잡한 속성인 경우
* 엑세스의 조건으로 자주 사용되는 속성인 경우
* 기본키의 형태가 적절하지 않거나 여러 개의 속성으로 구성된 경우

　중복 속성 추가 시 고려 사항
* 테이블 중복과 속성의 중복을 고려한다.
* 데이터 일관성 및 무결성에 유의해야 한다.
* SQL 그룹 함수를 이용하여 처리할 수 있어야 한다.
* 저장 공간의 지나친 낭비를 고려한다.

시스템 카탈로그
======

시스템 카탈로그(System Catalog)의 의미
------
　**시스템 카탈로그**는 시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스이다. 시스템 카탈로그 내의 각 테이블은 사용자를 포함하여 DBMS에서 지원하는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블이다. 카탈로그들이 생성되면 데이터 사전(Data Dictionary)에 저장되기 때문에 좁은 의미로는 카탈로그를 데이터 사전이라고도 한다.

시스템 카탈로그 저장 정보
------
　시스템 카탈로그에 저장된 정보를 메타 데이터(Meta-Data)라고 한다.
* 메타 데이터의 유형
  - 데이터베이스 객체 정보: 테이블(Table), 인덱스(Index), 뷰(View) 등의 구조 및 통계 정보
  - 사용자 정보: 아이디, 패스워드, 접근 권한 등
  - 테이블의 무결성 제약 조건 정보: 기본키, 외래키, NULL 값 허용 여부 등
  - 함수, 프로시저, 트리거 등에 대한 정보

카탈로그의 특징
------
　카탈로그 자체도 시스템 테이블로 구성되어 있어 일반 이용자도 SQL을 이용하여 내용을 검색해 볼 수 있다. INSERT, DELETE, UPDATE문으로 카탈로그를 갱신하는 것은 허용되지 않는다. 데이터베이스 시스템에 따라 상이한 구조를 갖고, 카탈로그는 DBMS가 스스로 생성하고 유지한다.
* 카탈로그의 갱신: 사용자가 SQL문을 실행시켜 기본 테이블, 뷰, 인덱스 등에 변화를 주면 시스템이 자동으로 갱신한다.
* 분산 시스템에서의 카탈로그: 보통의 릴레이션, 인덱스, 사용자 등의 정보를 포함할 뿐 아니라 위치 투명성 및 중복 투명성을 제공하기 위해 필요한 모든 제어 정보를 가져야 한다.

카탈로그/데이터 사전을 참조하기 위한 DBMS 내의 모듈 시스템
------
* 데이터 정의어 번역기(DDL Compiler)
  - DDL을 메타 데이터를 갖는 테이블(카탈로그)로 변환하여 데이터 사전에 저장시킨다.
* 데이터 조작어 번역기(DML Compiler)
  - 응용 프로그램에 삽입된 DML문을 주 언어로 표현한 프로시저 호출로 변환하여 질의 처리기와 상호 통신한다.
* Data Directory
  - 데이터 사전에 수록된 데이터를 실제로 접근하는 데 필요한 정보를 관리 유지하는 시스템이다.
  - 시스템 카탈로그는 사용자와 시스템 모두 접근할 수 있지만 데이터 디렉터리는 시스템만 접근할 수 있다.
* 질의 최적화기
  - 사용자의 요구를 효율적인 형태로 변환하고 질의를 처리하는 좋은 전략을 모색한다.
* 트랜잭션 처리기
  - 복수 사용자 환경에서 평행으로 동시에 일어나는 트랜잭션 문제를 해결하여, 각각의 사용자가 데이터베이스 자원을 배타적으로 이용할 수 있도록 한다.
