---
title: "실기 2장 데이터 입출력"
excerpt: "데이터 입출력"

wirter: Myeongwoo Yoon
categories:
  - 정보처리기사
tags:
  - 정보처리기사

toc: true
toc_sticky: true
use_math: true

date: 2024-07-19
last_modified_at: 2024-07-19
---

데이터베이스 개요
======

&ensp;**데이터 저장소**는 데이터들을 논리적인 구조로 조직화하거나, 물리적인 공간에 구축한 것을 의미한다. 논리 데이터저장소는 데이터 및 데이터 간의 연관성, 제약조건을 식별하여 논리적인 구조로 조직화한 것이고, 물리 데이터저장소는 논리 데이터저장소를 소프트웨어가 운용될 환경의 물리적 특성을 고려하여 실제 저장장치에 저장한 것을 의미한다.<br/>
&ensp;**데이터베이스**는 여러 사람에 의해 **공동으로 사용될 데이터를 중복을 배제하여 통합하고**, 쉽게 접근하여 처리할 수 있도록 **저장장치에 저장하여 항상 사용할 수 있도록 운영하는 운영 데이터**이다. 데이터베이스는 다음과 같이 구분하여 정의할 수 있다.
* 통합된 데이터(Integrated Data): 자료의 중복을 배제한 데이터의 모임
* 저장된 데이터(Stored Data): 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료
* 운영 데이터(Operational Data): 조직의 고유한 업무를 수행하는 데 반드시 필요한 자료
* 공용 데이터(Shared Data): 여러 응용 시스템들이 공동으로 소유하고 유지하는 자료

&ensp;**DBMS(DataBase Management System, 데이터베이스 관리 시스템)**는 **사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해주는 소프트웨어**이다. 기존의 파일 시스템이 작는 데이터의 종속성과 중복성의 문제를 해결하기 위해 제안된 시스템이다. DBMS의 필수 3가지 기능은 다음과 같다.
* 정의(Definition) 기능: 데이터의 형과 구조에 대한 정의, 이용 방식, 제약 조건 등을 명시하는 기능
* 조작(Manipulation) 기능: 데이터 검색, 갱신, 삽입, 삭제 등을 위해 인터페이스 수단을 제공하는 기능
* 제어(Control) 기능: 데이터의 무결성, 보안, 권한 검사, 병행 제어를 제공하는 기능

&ensp;**데이터의 독립성**은 종속성에 대비되는 말로 논리적 독립성과 물리적 독립성이 있다.
* 논리적 독립성: 응용 프로그램과 데이터베이스를 독립시킴으로써, 데이터의 논리적 구조를 변경시키더라고 응용 프로그램은 영향을 받지 않음
* 물리적 독립성: 응용 프로그램과 보조기억장치 같은 물리적 장치를 독립시킴으로써, 디스크를 추가/변경하더라도 응용 프로그램은 영향을 받지 않음

&ensp;**스키마(Schema)**는 **데이터베이스의 구조와 제약조건에 관한 전반적인 명세를 기술한 것**이다.
* 외부 스키마: 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것
* 개념 스키마: 데이터베이스의 전체적인 논리적 구조, 모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스로, 하나만 존재한다.
* 내부 스키마: 물리적 저장장치의 입장에서 본 데이터베이스 구조, 실제로 저장될 레코드의 형식, 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타냄

데이터베이스 설계
======

&ensp;**데이터베이스 설계**는 사용자의 요구를 분석하여 그것들을 컴퓨터에 저장할 수 있는 데이터베이스의 구조에 맞게 변형한 후 DBMS로 데이터베이스를 구현하여 일반 사용자들이 사용하게 하는 것이다.<br/>
&ensp;**데이터베이스 설계 시 고려사항**으로 다음이 있다.
* 무결성: 삽입, 삭재, 갱신 등의 연산 후에도 데이터베이스에 저장된 데이터가 정해진 제약 조건을 항상 만족해야 함
* 일관성: 데이터베이스에 저장된 데이터들 사이나, 특정 질의에 대한 응답이 처음부터 끝까지 변함없이 일정해야 함
* 회복: 시스템이 장애가 발생했을 때 장애 발생 직전의 상태로 복구할 수 있어야 함
* 보안: 불법적인 데이터의 노출 또는 변경이나 손실로부터 보호할 수 있어야 함
* 효율성: 응답시간의 단축, 시스템의 생산성, 저장 공간의 최적화 등이 가능해야 함
* 데이터베이스 확장: 데이터베이스 운영에 영향을 주지 않으면서 지속적으로 데이터를 추가할 수 있어야 함

&ensp;**데이터베이스 설계 순서**는 다음과 같다.
1. 요구 조건 분석: 요구 조건 명세서 작성
2. 개념적 설계: 개념 스키마, 트랜잭션 모델링, E-R 모댈
3. 논리적 설계: 목표 DBMS에 맞는 논리 스키마 설계, 트랜잭션 인터페이스 설게
4. 물리적 설계: 목표 DBMS에 맞는 물리적 구조의 데이터로 변환
5. 구현: 목표 DBMS의 DDL(데이터 정의어)로 데이터베이스 생성, 트랜잭션 작성

&ensp;**요구 조건 분석**은 **데이터베이스**를 사용할 사람들로부터 **필요한 용도를 파악하는 것**이다. 데이터베이스 사용자에 따른 수행 업무와 필요한 데이터의 종류, 용도, 처리 형태, 흐름, 제약 조건 등을 수집한다. 수집된 정보를 바탕으로 요구 조건 명세를 작성한다.<br/>
&ensp;**개념적 설계(정보 모델링, 개념화)**는 정보의 구조를 얻기 위하여 현실 세계의 무한성과 계속성을 이해하고, 다른 사람과 통신하기 위하여 **현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정**이다. 개념적 설계에서는 개념 스키마 모델링과 트랜잭션 모델링을 병행 수행한다. 또한 요구 분석에서 나온 결과인 요구 조건 명세를 DBMS에 독집적인 E-R 다이어그램으로 작성한다. DBMS에 독립적인 개념 스키마를 설계한다.<br/>
&ensp;**논리적 설계(데이터 모델링)**는 **현실 세계에서 발생하는 자료를** 컴퓨터가 이해하고 처리할 수 있는 물리적 저장장치에 저장할 수 있도록 변환하기 위해 **특정 DBMS가 지원하는 논리적 구조로 변환(mapping)시키는 과정**이다. 개념 세계의 데이터를 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계로 표현되는 논리적 구조의 데이터로 모델화한다. 개념적 설게가 개념 스키마를 설계하는 단계라면, 논리적 설계에서는 개념 스키마를 평가 및 정제하고 DBMS에 따라 서로 다른 논리적 스키마를 설계하는 단계이다. 트랜잭션의 인터페이스를 설계한다.<br/>
&ensp;**물리적 설계(데이터 구조화)**에서 **논리적 구조롤 표현된 데이터**를 디스크 등의 물리적 저장장치에 저장할 수 있는 **물리적 구조의 데이터로 변환하는 과정***이다. 물리적 설계에서는 다양한 데이터베이스 응용에 대해 처리 성능을 얻기 위해 데이터베이스 파일의 저장 구조 및 액세스 경로를 결정한다. 또한 저장 레코드의 형식, 순서, 접근 집중 레코드 등의 정보를 사용하여 데이터가 컴퓨터에 저장되는 방법을 묘사한다.<br/>
&ensp;**데이터베이스 구현**은 **논리적 설계와 물리적 설계에서 도출된 데이터베이스 스키마를 파일로 생성하는 과정**이다. 사용하려는 특정 DBMS의 DDL을 이용항 데이터베이스 스키마를 기술한 후 컴파일하여 빈 데이터베이스 파일을 생성한다. 응용 프로그램을 위한 트랜잭션을 작성하고 데이터베이스 접근을 위한 응용 프로그램을 작성한다.

데이터 모델
======

&ensp;**데이터 모델**은 **현실 세계의 정보들을** 컴퓨터에 표현하기 위해서 단순화, 추상화하여 **체계적으로 표현한 개념적 모형**이다. 데이터 모델은 데이터, 데이터의 관계, 데이터의 의미 및 일관성, 제약 조건 등을 기술하기 위한 개념적 도구들로 구성되어 있다. 데이터베이스 설계 과정에서 데이터의 구조(Schema)를 논리적으로 표현하기 위해 지능적 도구로 사용된다.<br/>
&ensp;**데이터 모델 구성 요소**는 다음과 같다.
* **개체(Entity)**
  - **데이터베이스에 표현하려는 것**으로, 사람이 생각하는 **개념이나 정보 단위 같은 현실 세계의 대상체**이다.
  - 개체는 실세계에 독립적으로 존재하는 유형, 무형의 정보로서 서로 연관된 몇 개의 속성으로 구성된다.
  - 독립적으로 존재하거나 그 자체로서도 구별이 가능하며, 유일한 식별자(Unique Identifier)에 의해 식별된다.
  - 다른 개체와 하나 이상의 관계가 있다.
* **속성(Attribute)**
  - **데이터베이스를 구성하는 가장 작은 논리적 단위**이다.
  - 파일 구조상의 데이터 항목 또는 데이터 필드에 해당한다.
  - 속성은 개체를 구성하는 항목으로 게체의 특성을 기술한다.
  - 속성의 수를 디그리(Degree) 또는 차수라고 한다.
  - 속성은 속성의 특성과 개체 구성 방식에 따라 분류한다.
   + 기본 속성(Basic Attribute): 업무 분석을 통해 정의한 속성, 속성 중 가장 많고 일반적이다. 업무로부터 분석한 속성이라도 업무상 코드로 정의한 속성은 기본 속성에서 제외된다.
   + 설계 속성(Designed Attribute): 원래 업무상 존재하지 않고 설계 과정에서 도출해내는 속성, 업무에 필요한 데이터 외에 데이터 모델링을 위해 업무를 규칙화하려고 속성을 새로 만들거나 변형하여 정의하는 속성
   + 파생 속성(Derived Attribute): 다른 속성으로부터 계산이나 변형 등의 영향을 받아 발생하는 속성, 파생 속성은 되도록 적은 수를 정의하는 것이 좋다.
  - 예를 들면, 자동차면, 제조일, 연비는 "기본 속성", A01-세단, A02-SUV의 자동차 코드는 "설계 속성", 총판매수량 등의 계산 속성은 "파생 속성"이다.
  - **속성의 개체 구성 방식에 따라 분류**할 수 있다.
    + 기본키 속성(Primary Key Attribute): 개체를 유일하게 식별할 수 있는 속성
    + 외래키 속성(Foreign Key Attribute): 다른 개체와의 관계에서 포함된 속성
    + 일반 속성: 개체에 포함되어 있고 기본키, 외래키에 포함되지 않는 속성
* **관계(Relationship)**
  - **개체와 개체 사이의 논리적인 연결**을 의미한다.
  - 개체 간의 관계와 속성 간의 관계가 있다.
  - 관계의 형태는 다음과 같다.
    + 일 대 일: 개체 집합 A의 각 원소가 개체 집합 B의 원소 한 개와 대응하는 관계
    + 일 대 다: 개체 집합 A의 각 원소가 개체 집합 B의 원소 여러 개와 대응하고 있지만, 개체 집함 B의 각 원소는 개체 집합 A의 원소 한개와 대응하는 관계
    + 다 대 다: 개체 집합 A의 각 원소는 개체 집합 B의 원소 여러 개와 대응하고, 개체 집합 B의 각 원소도 개체 집합 A의 원소 여러 개와 대응하는 관계
  - 관계의 종류는 다음과 같다.
    + 종속 관계(Dependent Relationship): 두 개체 사이의 주종 관계를 표현한 것으로 식별 관계와 비식별 관계가 있음
    + 중복 관계(Redundant Relationship): 두 개체 사이에 2번 이상의 종속 관계가 발생하는 관계
    + 재귀 관계(Recursive Relationship): 개체가 자기 자신과 관계를 갖는 것으로, 순환 관계(Recursive Relationship)라고도 함
    + 배타 관계(Exclusive Relationship): 개체의 속성이나 구분자를 기준으로 개체의 특성을 분할하는 관계로, 배타 AND 관계와 배타 OR 관계로 구분함

&ensp;**데이터 모델의 종류**는 다음과 같다.
* **개념적 데이터 모델**
  - **현실 세계에 대한 인간의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정**이다.
  - 속성들로 기술된 개체 타입과 이 개체들 간의 관계를 이용하여 현실 세계를 표현한다.
  - 현실 세계에 존재하는 개체를 인간이 이해할 수 있는 정보 구조로 표현하기 때문에 정보 모델이라고도 한다.
  - 대표적으로 E-R 모델이 있다.
* **논리적 데이터 모델**
  - 개념적 모델링 과정에서 얻은 **개념적 구조**를 컴퓨터가 이해하고 처리할 수 있는 **컴퓨터 세계의 환경에 맞도록 변화하는 과정**이다.
  - 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계를 이용하여 현실 세계를 표현한다.
  - 단순히 데이터 모델이라고 하면 논리적 데이터 모델을 의미한다.
  - 특정 DBMS는 특정 논리적 데이터 모델 하나만 선정하여 사용한다.
  - 논리적 데이터 모델은 데이터 간의 관계를 어떻게 표현하느냐에 따라 관계 모델, 계층 모델, 네트워크 모델로 구분한다.
* 물리적 데이터 모델

&ensp;데이터 모델에 표시할 요소로는 구조, 연산, 제약 조건이 있다.
* 구조(Structure): 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질 표현
* 연산(Operation): 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 데이터베이스를 조작하는 기본 도구
* 제약 조건(Constraint): 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건

E-R(개체-관계) 모델
======

&ensp;**E-R(Entity-Relationship, 개체-관계) 모델**은 개체와 개체 간의 관계를 기본 요소로 이용하여 현실 세계의 무질서한 데이터를 개념적인 논리 데이터로 표현하기 위한 방법이다. 1976년 피터 첸(Peter Chen)에 의해 제안되고 기본적인 구성 요소가 정립되었다.<br/>
&ensp;E-R 모델은 개념적 데이터 모델의 가장 대표적인 것으로 개체 타입(Entity Type)과 이들 간의 관계 타입(Relationship Type)을 이용해 현실 세계를 개념적으로 표현한다. 또한 데이터를 개체(Entity), 관계(Relationship), 속성(Attribute)으로 묘사한다. E-R 다이어그램으로 표현하며, 1:1, 1:N, N:M 등의 관계 유형을 제한 없이 나타낼 수 있다.<br/>
&ensp;**E-R다이어그램**은 다음과 같다.<br/>
<p align="center"><img src="/assets/img/정보처리기사/데이터베이스 구축/논리 데이터베이스 설계/3-1.jpeg" width="500"></p>

관계형 데이터베이스
======

&ensp;**관계형 데이터베이스**는 **2차원적인 표(Table)를 이용해서 데이터 상호 관계를 정의하는 데이터베이스**로 1970년 IBM에 근무하던 코드(E. F. Codd)에 의해 처음 제안되었다. 개체(Entity)와 관계(Relationship)를 모두 릴레이션(Relation)이라는 표(Table)로 표현하기 때문에 개체를 표현하는 개체 릴레이션과 관계를 표현하는 관계 릴레이션이 존재한다. 장점으로 간결하고 보기 편리하며, 다른 데이터베이스로의 변환이 용이하지만 단점으로 성능이 다소 떨어진다.<br/>
&ensp;관계형 데이터베이스의 **릴레이션(Relation)**은 데이터들을 표(Table)의 형태로 표현한 것으로, 구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레이션 인스턴스로 구성된다.<br/>
<p align="center"><img src="/assets/img/정보처리기사/데이터베이스 구축/논리 데이터베이스 설계/4-1.jpeg" width="600"></p>

* **튜플(Tuple)**
  - 튜플은 **릴레이션을 구성하는 각각의 행**을 말한다.
  - 튜플은 속성의 모임으로 구성된다.
  - 파일 구조에서 레코드와 같은 의미이고 튜플의 수를 카디널리티(Cardinality) 또는 기수, 대응수라고 한다.
* **속성(Attribute)**
  - 속성은 **데이터베이스를 구성하는 가장 작은 논리적 단위**이다.
  - 파일 구조상의 데이터 항목 또는 데이터 필드에 해당한다.
  - 속성은 개체의 특성을 기술하고 속성의 수를 디그리(Degree) 또는 차수라고 한다.
* **도메인(Domain)**
  - 도메인은 **하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자(Atomic)값들의 집합**이다.
  - 도메인은 실제 애트리뷰트 값이 나타날 때 그 값의 합법 여부를 시스템이 검사하는데에도 이용된다.

&ensp;**릴레이션의 특징**은 다음과 같다.
* 한 릴레이션에는 똑같은 튜플이 포함될 수 없으므로 릴레이션에 포함된 튜플들은 모두 상이하다.
* 한 릴레이션에 포함된 튜플 사이에는 순서가 없다.
* 튜플들의 삽입, 삭제 등의 작업으로 릴레이션은 시간에 따라 변한다.
* 릴레이션 스키마를 구성하는 속성들 간의 순서는 중요하지 않다.
* 속성의 유일한 식별을 위해 명칭은 유일해야 하지만, 속성을 구성하는 값은 동일한 값이 있을 수 있다.
* 릴레이션을 구성하는 튜플을 유일하게 식별하기 위해 속성들의 부분집합을 키(Key)로 설정한다.
* 속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자값만을 저장한다.

&ensp;**관계형 데이터 모델(Relationship Data Model)**은 **2차원적인 표(Table)를 이용해서 데이터 상호 관계를 정의하는 DB구조** 이다. 가장 널리 사용되는 데이터 모델로 계층 모델과 망 모델의 복잡한 구조를 단순화시킨 모델이다. 파일 구조처럼 구성한 테이블들을 하나의 DB로 묶어서 데이블 내에 있는 속성들 간의 관계(Relationship)를 설정하거나 테이블 간의 관계를 설정하여 이용한다. 기본키(Primary Key)와 이를 참조하는 외래키(Foreign Key)로 데이터간의 관계를 표현한다. 대표적인 언어는 SQL이고 1:1, 1:N, N:M 관계를 자유롭게 표현할 수 있다.<br/>
&ensp;**관계형 데이터베이스의 제약조건 중 키(Key)**가 있다. **키**는 데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 기준이 되는 속성을 말한다. 키의 종류는 다음과 같다.
* **후보키(Candidate Key)**
  - 릴레이션을 구성하는 **속성들 중에서 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합**, 즉 기본키로 사용될 수 있는 속성들을 말한다.
  - 하나의 릴레이션내에서는 중복된 튜플들이 있을 수 없으므로 모든 릴레이션에는 반드시 하나 이상의 후보키가 존재한다.
  - 후보키는 릴레이션에 있는 모든 튜플에 대해서 유일성과 최소 식별성을 만족시켜야 한다.
    + 유일성(Unique): 하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 한다.
    + 최소성(Minimality): 모든 레코드들을 유일하게 식별하는 데 꼭 필요한 속성으로만 구성되어야 한다.
* **기본키(Primary Key)**
  - **후보키 중에서 특별히 선정된 주키(Main Key)**로 중복된 값을 가질 수 없다.
  - 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성이다.
  - 기본키는 NULL 값을 가질 수 없다. 즉, 튜플에서 기본키로 설정된 속성에는 NULL 값이 있어서는 안된다.
* **대체키(Alternate Key)**
  - **후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키**를 의미하고 보조키라고도 한다.
* **슈퍼키(Super Key)**
  - 한 릴레이션 내에 있는 **속성들의 집합으로 구성된 키**로서 릴레이션을 구성하는 모든 튜플들 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않는다.
  - 슈퍼키는 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족시키지만, 최소성은 만족시키지 못한다.
* **외래키(Foreign Key)**
  - **다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합**을 의미한다.
  - 한 릴레이션에 속한 속성 A와 참조 릴레이션의 기본키인 B가 동일한 도메인 상에서 정의되었을 때의 속성 A를 외래키라고 한다.
  - 외래키로 지정되면 참조 릴레이션의 기본키에 없는 값은 입력할 수 없다.

&ensp;관계형 데이터베이스의 제약 조건 중 **무결성(Integrity)**이란 **데이터베이스에 저장된 데이터 값과** 그것이 표현하는 **현실 세계의 실제 값이 항상 일치하는 정확성**을 의미한다. 무결성 제약 조건은 데이터베이스에 들어있는 데이터의 정확성을 보장하기 위해 부정확한 자료가 데이터베이스 내에 저장되는 것을 방지하기 위한 제약 조건을 말한다. 무결성의 종류는 다음과 같다.
* 개체 무결성
  - 기본 테이블의 기본키를 구성하는 어떤 속성도 NULL 값이나 중복값을 가질 수 없다는 규정
* 참조 무결성
  - 외래키 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일해야 함
  - 즉, 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정
* 도메인 무결성
  - 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정
* 사용자 정의 무결성
  - 속성 값들이 사용자가 정의한 제약조건에 만족해야 한다는 규정
* NULL 무결성
  - 릴레이션의 특정 속성 값이 NULL이 될 수 없도록 하는 규정
* 고유 무결성
  - 릴레이션의 특정 속성에 대해 각 튜플이 갖는 속성값들이 서로 달라야 한다는 규정
* 키 무결성
  - 하나의 릴레이션에는 적어도 하나의 키가 존재해야 한다는 규정
* 관계 무결성
  - 릴레이션에 어느 한 튜플의 삽입 가능 여부 또는 한 릴레이션과 다른 릴레이션의 튜플들 사이의 관계에 대한 적절성 여부를 지정한 규정

&ensp;**데이터 무결성**은 데이터 품질에 직접적인 영향을 미치므로 데이터 특성에 맞는 적절한 무결성을 정의하고 **강화**해야 한다. 데이터 무결성은 애플리케이션, 데이터베이스 트리거, 제약 조건을 이용하여 강화할 수 있다.
* 애플리케이션
  - 데이터 생성, 수정, 삭제 시 무결성 조건을 검증하는 코드를 데이터를 조작하는 프로그램 내에 추가함
* 데이터베이스 트리거
  - 트리거 이벤트에 무결성 조건을 실행하는 절차형 SQL을 추가함
* 제약 조건
  - 데이터베이스에 제약 조건을 설정하여 무결성을 유지함

관계대수 및 관계해석
======

&ensp;**관계대수**는 관계형 데이터베이스에서 **원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어**이다. 관계대수는 릴레이션을 처리하기 위해 연산자와 연산규칙을 제공하며, 피연산자가와 결과가 모두 릴레이션이다. 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시한다. 관계 데이터베이스에 적용하기 위해 특별히 개발한 순수 관계 연산자와 수학적 집합 이론에서 사용하는 일반 집합 연산자가 있다.<br/>
&ensp;**순수 관계 연산자**는 다음과 같다.
* Select($\sigma$)
  - 릴레이션에 존재하는 튜플 중에서 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산
  - 릴레이션의 행(가로)에 해당하는 튜플을 구하는 것이므로 수평 연산이라고도 한다.
* Project($\pi$)
  - 주어진 릴레이션에서 속성 리스트(Attribute List)에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산
  - 연산 결과에 중복이 발생하면 중복이 제거됨
  - 릴레이션의 열에 해당하는 속성을 추출하는 것이므로 수직 연산자라고도 함
* Join($\bowtie$)
  - 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산
  - Join의 결과는 Cartesian Product(교차곱)을 수행한 다음 Select를 수행한 것과 같음
* Division($\div$)
  - Division은 $X \subset Y$인 두 개의 릴레이션 R(X)와 S(Y)가 있을 때, R의 속성이 S의 속성 값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산
&ensp;**일반 집합 연산자**는 **수학적 집합 이론에서 사용하는 연산자**이다. 일반 집합 연산자 중 UNION(합집합), INTERSECTION(교집합), DIFERENCE(차집합)을 처리하기 위해서는 합병 조건을 만족해야 한다.

|연산자|기능 및 수학적 표현|카디널리티|
|---|---|---|
|합집합(UNION, $\cup$)|두 릴레이션에 존재하는 튜플의 합집합을 구하되, 결과로 생성된 릴레이션에서 중복되는 튜플은 제거되는 연산이다.<br/>$R \cup S$|합집합의 카디널리티는 두 릴레이션 카디널리티의 합보다 크지 않다.|
|교집합|두 릴레이션에 존재하는 튜플의 교집합을 구하는 연산이다.<br/>$R \cap S$|교집합의 카디널리티는 두 릴레이션 중 카디널리티가 적은 릴레이션의 카디널리티보다 크지 않다.|
|차집합|두 릴레이션에 존재하는 튜플의 차집합을 구하는 연산이다.<br/>$R - S$|차집합의 카디널리티는 릴레이션 R의 카디널리티 보다 크지 않다.|
|교차곱|두 릴레이션에 있는 튜플들의 순서쌍을 구하는 연산이다.<br/>$R \times S$|교차곱의 디그리는 두 릴레이션의 디그리를 더한 것과 같고, 카디널리티는 두 릴레이션의 카디널리티를 곱한 것과 같다.|

&ensp;**관계해석(Relational Calculus)**은 **관계 데이터의 연산을 표현하는 방법**이다. 관계 데이터 모델의 제안자인 코드(E. F. Codd)가 수학의 술어 해석에 기반을 두고 관계 데이터베이스를 위해 제안했다. 관계해석은 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성을 지닌다. 원하는 정보를 정의할 때는 계산 수식을 사용한다.<br/>

이상 / 함수적 종속
======

&ensp;**이상(Anomaly)**이란 **테이블에서** 일부 속성들의 종속으로 인해 **데이터의 중복이 발생하고, 이 중복(Redundancy)으로** 인해 테이블 조작 시 **문제가 발생하는 현상**을 의미한다. 이상의 종류는 다음과 같다.
* 삽입 이상(Insert Anomaly): 릴레이션에 데이터를 삽입할 때 의도와는 상관없이 원하지 않은 값들도 함께 삽입되는 현상이다.
* 삭제 이상(Delete Anomaly): 릴레이션에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 연쇄가 일어나는 현상이다.
* 갱신 이상(Update Anomaly): 릴레이션에서 튜플에 있는 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상이다.

&ensp;**함수적 종속(Functional Dependency)**은 데이터의 의미를 표현하는 것으로, 현실 세계를 표현하는 제약 조건이 되는 동시에 데이터베이스에서 항상 유지되어야 할 조건이다. 어떤 테이블 R에서 X와 Y를 각각 R의 속성 집합의 부분 집합이라 하자. 속성 X의 값 각각에 대해 시간에 관계없이 항상 속성 Y의 값이 오직 하나만 연관되어 있을 때 Y는 X에 함수적 종속 또는 X가 Y를 함수적으로 결정한다고 하고, $X \rightarrow Y$로 표기한다.<br/>
&ensp;$X \rightarrow Y$의 관계를 갖는 속성 X와 Y에서 X를 결정자(Determinant)라 하고, Y를 종속자(Dependent)라고 한다. 예를 들어 '학번 $\rightarrow$ 이름'에서는 학번이 결정자이고, 이름이 종속자이다.<br/>
* 완전 함수적 종속(Full Functional Dependency)
  - 어떤 테이블 R에서 속성 Y가 다른 속성 집합 X 전체에 대해 함수적 종속이면서 속성 집합 X의 어떤 진부분 집합 Z에도 함수적 종속이 아닐 때 속성 Y는 속성 집합 X에 완전 함수적 종속이라고 한다.
* 부분 함수적 종속(Partial Functional Dependency)
  - 어떤 테이블 R에서 속성 Y가 다른 속성 집합 X 전체에 대해 함수적 종속이면서 속성 집합 X의 어떤 진부분 집합 Z에도 함수적 종속일 때, 속성 Y는 속성 집합 X에 부분 함수적 종속이라고 한다.
* 완전 / 부분 함수적 종속의 이해
  - 완전 함수적 종속은 어떤 속성이 기본키에 대해 완전히 종속적일 때를 말한다.
  - <수강> 테이블은 (학번, 과목번호)가 기본키인데, 성적은 학번과 과목번호가 같을 경우에는 항상 같은 성적이 오므로, 즉 성적은 학번과 과목번호에 의해서만 결정되므로 성적은 키본키에 완전 함수적 종속이 되는 것이다.
  - 반면에 학년은 과목번호에 관계없이 학번이 같으면 항상 같은 학년이 오므로, 즉 기본키의 일부인 학번에 의헤서 학년이 결정되므로 학년은 부분 함수적 종속이라고 한다.
* 이행적 함수적 종속(Transitive Functional Dependency)
  - $X \rightarrow Y$이고 $Y \rightarrow Z$일 때, $X \rightarrow Z$를 만족하는 관계를 이행적 함수적 종속이라고 한다.

정규화(Normalization)
======

&ensp;**정규화(Normalization)**는 **테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용하여 테이블을 무손실 분해하는 과정**이다. 정규화의 목적은 가능한 한 중복을 제거하여 삽입, 삭제, 갱신 이상의 발생 가능성을 줄이는 것이다. 정규형에는 제1정규형, 제2정규형, 제3정규형, BCNF형, 제4정규형, 제5정규형이 있으며, 순서대로 정규화의 정도가 높아진다.<br/>
&ensp;**정규화 과정**을 다음과 같은 예로 보자. 아래의 <주문목록> 테이블을 가지고 정규화 과정을 살펴본다. <주문목록> 테이블의 기본키(Primary Key)는 제품번호이다.
<p align="center"><img src="/assets/img/정보처리기사/실기/2장 데이터 입출력 구현/39-1-주문목록.jpeg" width="450"></p>

* **1NF(제1정규형)**
  - 테이블 R에 속한 모든 속성의 도메인(Domain)이 원자값(Atomic Value)만으로 되어 있는 정규형이다.
  - 즉 테이블의 모든 속성 값이 원자 값으로만 되어 있는 정규형이다.
  - <주문목록> 테이블에서는 하나의 제품에 대해 여러 개의 주문 관련 정보(주문번호, 고객번호, 주소, 주문수량)가 발생하고 있다. 따라서 <주문목록> 테이블은 제 1정규형이 아니다.
<p align="center"><img src="/assets/img/정보처리기사/실기/2장 데이터 입출력 구현/39-2-제품, 제품주문.jpeg" width="450"></p>

  - 1차 정규화 과정으로 생성된 <제품주문> 테이블의 기본키는 (주문번호, 제품번호)이고, 다음과 같은 함수적 종속이 존재한다.
    + 주문번호, 제품번호 $\rightarrow$ 고객번호, 주소, 주문수량
    + 주문번호 $\rightarrow$ 고객번호, 주소
    + 고객번호 $\rightarrow$ 주소
* **2NF(제2정규형)**
  - 2NF는 릴레이션 R이 1NF이고, 기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족하는 정규형이다.
  - <주문목록> 테이블이 <제품> 테이블과 <제조주문> 테이블로 무손실 분해되면서 모두 1NF가 되었지만 그 중 <제품주문> 테이블에는 기본키인 (주문번호, 제품번호)에 완전 함수적 종속이 되지 않는 속성이 존재한다. 즉 주문수량은 기본키에 대해 완전 함수적 종속이지만 고객번호와 주소는 주문번호에 의해서도 결정될 수 있으므로, 기본키에 대해 완전 함수적 종속이 아니다. 따라서 <제품주문> 테이블은 2NF가 아니다.
  - 제 2정규화 과정을 거쳐 생성된 <주문> 테이블의 기본키는 주문번호이다. 그리고 <주문> 테이블에는 아직도 다음과 같은 함수적 종속들이 존재한다.
    + 주문번호 $\rightarrow$ 고객번호, 주소
    + 고객번호 $\rightarrow$ 주소
<p align="center"><img src="/assets/img/정보처리기사/실기/2장 데이터 입출력 구현/39-3-주문목록, 주문.jpeg" width="400"></p>

* **3NF(제3정규형)**
  - 3NF는 릴레이션 R이 2NF이고, 기본키가 아닌 모든 속성이 기본키에 대해 이행적 함수적 종속을 만족하지 않는 정규형이다.
  - <제품주문> 테이블이 <주문목록> 테이블과 <주문> 테이블로 무손실 분해되면서 모두 제 2정규형이 되었다. 그러나 <주문> 테이블에서 고객번호가 주문번호에 함수적 종속이고, 주소가 고객번호에 함수적 종속이므로 주소는 기본키인 주문번호에 대해 이행적 함수적 종속을 만족한다. 즉, 주분번호 $\rightarrow$ 고객번호이고, 고객번호 $\rightarrow$ 주소이므로 주문번호 $\rightarrow$ 주소는 이행적 함수적 종속이 된다. 따라서 <주문> 테이블은 제 3정규형이 아니다.
<p align="center"><img src="/assets/img/정보처리기사/실기/2장 데이터 입출력 구현/39-4-주문, 고객.jpeg" width="400"></p>

* **BCNF(Boyce-Code 정규형)**
  - BCNF는 릴레이션 R에서 결정자가 모두 후보키(Candidate Key)인 정규형이다.
  - 일반적으로 제 3정규형에 후보키가 여러 개 존재하고, 이러한 후보키들이 서로 중첩되어 나타나는 경우에 적용 가능하다.
  - 아래의 <수강_교수> 테이블(제 3정규형)은 함수적 종속{(학번, 과목명) $\rightarrow$ 담당교수, (학번, 담당교수) $\rightarrow$ 과목명, 담당교수 $\rightarrow$ 과목명}을 만족하고 있다.
  - <수강_교수> 테이블에서 결정자 중 후보키가 아닌 속성이 존재한다. 즉 함수적 종속 담당교수 $\rightarrow$ 과목명이 존재하는데, 담당교수가 <수강_교수> 테이블에서 후보키가 아니기 때문에 <수강_교수> 테이블은 BCNF이 아니다.
<p align="center"><img src="/assets/img/정보처리기사/실기/2장 데이터 입출력 구현/39-5-수강-교수.jpeg" width="300"></p>

<p align="center"><img src="/assets/img/정보처리기사/실기/2장 데이터 입출력 구현/39-6-수강, 교수.jpeg" width="400"></p>

* **4NF(제4정규형)**
  - 4NF는 릴레이션 R에 다중 값 종속 A$\twoheadrightarrow$B가 성립하는 경우 R의 모든 속성이 A에 함수적 종속 관계를 만족하는 정규형이다.
* **5NF(제5정규형)**
  - 5NF는 릴레이션 R의 모든 조인 종속이 R의 후보키를 통해서만 성립되는 정규형이다.

<p align="center"><img src="/assets/img/정보처리기사/데이터베이스 구축/논리 데이터베이스 설계/8-1.jpeg" width="300"></p>

반정규화(Denormalization)
======

&ensp;**반정규화(비정규화)**는 시스템의 성능을 향상하고 개발 및 운영의 편의성 등을 높이기 위해 **정규화된 데이터 모델을 의도적으로 통합, 중복, 분리하여 정규화 원칙을 위배하는 행위**이다. 반정규화를 수행하면 시스템의 성능이 향상되고 괸리 효율성은 증가하지만 데이터의 일관성 및 정합성이 저하될 수 있다. 과도한 벙정규화는 오히려 성능을 저하시킬 수 있다.<br/>
&ensp;반정규화 방법은 다음과 같다.
* **테이블 통합**
  - 두 개의 테이블이 조인(Join)되어 사용되는 경우가 많을 경우 성능 향상을 위해 아예 하나의 테이블로 만들어 사용하는 것이다.
  - 테이블 통합을 고려하는 경우
    + 두 개의 테이블에서 발생하는 프로세스가 동일하게 자주 처리되는 경우
    + 항상 두 개의 테이블을 이용하여 조회를 수행하는 경우
  - 테이블 통합의 종류
    + 1:1 관계 테이블 통합
    + 1:N 관계 테이블 통합
    + 슈퍼타입/서브타입 테이블 통합이 있다
* **테이블 분할**
  - 테이블을 수직 또는 수평으로 분리하는 것이다.
  - 수평 분할(Horizontal Partitioning)
    + 레코드(Record)를 기준으로 테이블을 분할하는 것
    + 레코드별로 사용 빈도의 차이가 큰 경우 사용 빈도에 따라 테이블을 분할함 
  - 수직 분할(Vertical Partitioning)
    + 하나의 테이블에 속성이 너무 많을 경우 속성을 기준으로 테이블을 분할하는 것
    + 종류: 갱신 위주의 속성 분할, 자주 조회되는 속성 분할, 크기가 큰 속성 분할, 보안을 적용해야 하는 속성 분할
* **중복 테이블 추가**
  - 작업의 효율성을 향상시키기 위해 테이블을 추가하는 것이다.
  - 중복 테이블을 추가하는 경우
    + 여러 테이블에서 데이터를 추출해서 사용해야 할 경우
    + 다른 서버에 저장된 테이블을 이용해야 하는 경우
  - 중복 테이블을 추가하는 방법
    + 집계 테이블의 추가: 집계 데이터를 위한 테이블을 추가하는 테이블을 생성하고, 각 원본 테이블에 트리거(Trigger)를 설정하여 사용하는 것
    + 집행 테이블의 추가: 이력 관리 등의 목적으로 추가하는 테이블
    + 특정 부분만을 포함하는 테이블의 추가: 데이터가 많은 테이블의 특정 부분만을 사용하는 경우 해당 부분만으로 새로운 테이블을 생성
* **중복 속성 추가**
  - 조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 하나 더 추가하는 것이다.
  - 중복 속성을 추가하면 데이터의 무결성 확보가 어렵고, 디스크 공간이 추가로 필요하다.
  - 중복속성을 추가하는 경우
    + 조인이 자주 발생하는 속성인 경우
    + 접근 경로가 복잡한 속성인 경우
    + 엑세스의 조건으로 자주 사용되는 속성인 경우
    + 기본키의 형태가 적절하지 않거나 여러 개의 속성으로 구성된 경우

시스템 카탈로그
======

&ensp;**시스템 카탈로그(System Catalog)**는 시스템 그 자체에 관련이 있는 **다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스**이다. 시스템 카탈로그 내의 각 테이블은 사용자를 포함하여 DBMS에서 지원하는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블이다. 카탈로그들이 생성되면 데이터 사전(Data Dictionary)에 저장되기 때문에 좁은 의미로는 카탈로그를 데이터 사전이라고도 한다.<br/>
&ensp;**시스템 카탈로그에 저장된 정보**를 **메타 데이터(Meta-Data)**라고 한다. 메타 데이터의 유형은 다음과 같다.
* 데이터베이스 객체 정보: 테이블(Table), 인덱스(Index), 뷰(View) 등의 구조 및 통계 정보
* 사용자 정보: 아이디, 패스워드, 접근 권한 등
* 테이블의 무결성 제약 조건 정보: 기본키, 외래키, NULL 값 허용 여부 등
* 함수, 프로시저, 트리거 등에 대한 정보

&ensp;**데이터 디렉터리(Data Directory)**는 **데이터 사전에 수록된 데이터에 접근하는 데 필요한 정보를 관리 유지하는 시스템**이다. 시스템 카탈로그는 사용자와 시스템 모두 접근할 수 있지만 데이터 디렉터리는 시스템만 접근할 수 있다.

트랜잭션 분석 / CRUD 분석
======

&ensp;**트랜잭션(Transaction)**은 데이터베이스의 상태를 변환시키는 하나의 **논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산**들을 의미한다. 트랜잭션은 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위로 사용된다. 트랜잭션은 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업 단위로 사용된다.<br/>
&ensp;**트랜잭션의 특성**은 다음과 같다.
* Atomicity(원자성)
  - 트랜잭션의 연산은 데이터베이스에 모두 반영되도록 완료(Commit)되든지 아니면 전혀 반영되지 않도록 복구(Pollback)되어야 한다.
* Consistency(일관성)
  - 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.
* Isolation(독립성, 격리성, 순차성)
  - 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없다.
* Durability(영속성, 지속성)
  - 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.

&ensp;**CRUD분석**은 **프로세스와 테이블 간에 CRUD 매트릭스를 만들어서 트랜잭션을 분석하는 것**이다. CRUD 분석을 통해 많은 트랜잭션이 몰리는 테이블을 파악할 수 있으므로 디스크 구성 시 유용한 자료로 활용할 수 있다.<br/>
  * **CRUD 매트릭스**는 2차원 형태의 표로서, 행(Row)에는 프로세스를, 열(Column)에는 테이블을, 행과 열이 만나는 위치에는 프로세스가 테이블에 발생시키는 변화를 표시하는 업무 프로세스와 데이터 간 상관 분석표이다.
  * CRUD 매트릭스를 통해 프로세스의 트랜잭션이 테이블에 수행하는 작업을 검증한다.
  * CRUD 매트릭스의 각 셀에는 Create, Read, Update, Delete의 앞 글자가 들어가며, 복수의 변화를 줄 때는 기본적으로 'C > D > U > R'의 우선순위를 적용하여 한가지만 적지만, 활용 목적에 따라 모두 기록할 수 있다.
  * CRUD 매트릭스가 완성되었다면 C, R, U, D 중 어느 것도 적히지 않은 행이나 열, C나 R이 없는 열을 확인하여 불필요하거나 누락된 테이블 또는 프로세스를 찾는다.
&ensp;**트랜잭션 분석**은 CRUD 매트리스를 기반으로 테이블에 발생하는 트랜잭션 양을 분석하여 테이블에 저장되는 테이터의 양을 유추하고 이를 근거로 DB 용량을 산정하고 DB 구조를 최적화하는 것이다. 트랜잭션 분석은 업무 개발 담장자가 수행한다. 트랜잭션 분석을 통해 프로세스가 과도하게 접근하는 테이블을 확인하여 여러 디스크에 배치함으로써 디스크 입•출력 분산을 통한 성능 향상을 가져올 수 있다.
* 트랜잭션 분석서는 단위 프로세스와 CRUD 매트릭스를 이용하여 작성하며, 구성 요소에는 단위 프로세스, CRUD 연산, 테이블명, 컬럼명, 테이블 참조 횟수, 트랜잭션 수, 발생 주기 등이 있다.

인덱스
======

&ensp;**인덱스(Index)**는 **데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되는 데이터 구조**로 레코드가 저장된 물리적 구조에 접근하는 방법을 제공한다. 인덱스를 통해서 파일의 레코드에 대한 액세스를 빠르게 수행할 수 있다. 레코드의 삽입과 삭제가 수시로 일어나는 경우에는 인덱스의 개수를 최소로 하는것이 효율적이다.<br/>
&ensp;**인덱스의 종류**는 다음과 같다.
* 트리 기반 인덱스
  - 인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것
* 비트맵 인덱스
  - 인덱스 컬럼의 데이터를 Bit 값인 0 또는 1로 변환하여 인덱스 키로 사용하는 방법
* 함수 기반 인덱스
  - 컬럼의 값 대신 컬럼에 특정 함수(Function)나 수식(Expression)을 적용하여 산출된 값을 사용하는 것
* 비트맵 조인 인덱스
  - 다수의 조인된 객체로 구성된 인덱스
* 도메인 인덱스
  - 개발자가 필요한 인덱스를 직접 만들어 사용하는 것

&ensp;**클러스터드 인덱스(Clustered Index)**는 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식으로 실제 데이터가 순서대로 저장되어 있어 인덱스를 검색하지 않아도 원하는 데이터를 빠르게 찾을 수 있다. **넌클러스터드 인덱스(Non-Clustered Index)**는 인덱스의 키 값만 정렬되어 있고 실제 데이터는 정렬되지 않는 방식으로 데이터 삽입, 삭제 발생 시 순서 유지를 위한 데이터 재정렬이 필요 없어 속도가 빠르다.

뷰 / 클러스터
======

&ensp;**뷰(View)**는 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 **하나 이상의 기본 테이블로부터 유도된**, 이름을 가지는 **가상 테이블**이다. 뷰는 저장장치 내에 물리적으로 존재하지 않지만, 사용자에게는 있는 것처럼 간주된다. 뷰를 통해서만 데이터에 접근하게 하면 뷰에 나타나지 않는 데이터를 안전하게 보호하는 효율적인 기법으로 사용할 수 있다. 뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제된다. 또한 뷰를 정의할 때는 CREATE문, 제거할 때는 DROP문을 사용한다.<br/>
&ensp;**뷰의 장•단점**은 다음과 같다.
* 장점
  - 논리적 데이터 독립성을 제공한다.
  - 동일 데이터에 대해 동시에 여러 사용자의 상이한 응용이나 요구를 지원해 준다.
  - 사용자의 데이터 관리를 간단하게 해준다.
  - 접근 제어를 통한 자동 보안이 제공된다.
* 단점
  - 독립적인 인덱스를 가질 수 없다.
  - 뷰의 정의를 변경할 수 없다.
  - 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신 연산에 제약이 따른다.

&ensp;**클러스터(Cluster)**는 데이터 저장 시 데이터 액세스 효율을 향상시키기 위해 **동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법**이다. 클러스터링 된 테이블은 데이터 조회 속도를 향상시키지만 입력, 수정, 삭제에 대한 작업 성능을 저하시킨다. 클러스터는 데이터의 분포도가 넓을수록 유리하고 데이터 분포도가 넓은 테이블을 클러스터링 하면 저장 공간을 절약할 수 있다. 또한 처리 범위가 넓은 경우에는 단일 테이블 클러스터링을, 조인이 많이 발생하는 경우에는 다중 테이블 클러스터링을 사용한다.

파티션
======

&ensp;데이터베이스에서 **파티션(Patition)**은 **대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것**을 말한다. 대용량 DB의 경우 중요한 몇 개의 테이블에만 집중되어 데이터가 증가되므로, 이런 테이블들을 작은 단위로 나눠 분산시키면 성능 저하를 방지할 뿐만 아니라 데이터 관리도 쉬워진다. 데이터 처리는 테이블 단위로 이뤄지고, 데이터 저장은 파티션 별로 수행된다.<br/>
&ensp;**파티션의 장•단점**은 다음과 같다.
* 장점
  - 데이터 접근 시 액세스 범위를 줄여 쿼리 성능이 향상된다.
  - 파티션별로 데이터가 분산되어 저장되므로 디스크의 성능이 향상된다.
  - 파티션별로 백업 및 복구를 수행하므로 속도가 빠르다.
  - 데이터 가용성이 향상된다.
  - 파티션 단위로 입•출력을 분산시킬 수 있다.
* 단점
  - 하나의 테이블을 세분화하여 관리하므로 세심한 관리가 요구된다.
  - 테이블간 조인에 대한 비용이 증가한다.
  - 용량이 작은 테이블에 파티셔닝을 수행하면 오히려 성능이 저하된다.

&ensp;**파티션의 종류**는 다음과 같다.
* 범위 분할(Range Partitioning)
  - 지정한 열의 값을 기준으로 범위를 지정하여 분할한다.
  - 예로, 일별, 월별, 분기별 등이 있다.
* 해시 분할(Hash Partitioning)
  - 해시 함수를 적용한 결과 값에 따라 데이터를 분할한다.
  - 특정 파티션에 데이터가 집중되는 범위 분할의 단점을 보완한 것으로, 데이터를 고르게 분산할 때 유용하다.
  - 특정 데이터가 어디 있는지 판단할 수 있다.
  - 고객번호, 주민번호 등과 같이 데이터가 고른 컬럼에 효과적이다.
* 조합 분할(Composite Partitioning)
  - 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할하는 방법이다.
  - 범위 분할한 파티션이 너무 커서 관리가 어려울 때 유용하다.

분산 데이터베이스 설계
======

&ensp;**데이터베이스 용량 설계**는 데이터가 저장될 공간을 정의하는 것이다. 데이터베이스 용량을 설계할 때는 테이블에 저장될 데이터양과 인덱스, 클러스터 등이 차지하는 공간 등을 예측하여 반영해야 한다. 데이터베이스 용량 설계의 목적은 다음과 같다.
- 데이터베이스의 용량을 정확히 산정하여 디스크의 저장 공간을 효과적으로 사용하고 확장성 및 가용성을 높인다.
- 디스크의 특성을 고려하여 설계함으로써 디스크의 입•출력 부하를 분산시키고 채널의 병목 현상을 최소화한다.

&ensp;**분산 데이터베이스**는 **논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 컴퓨터 사이트(Site)에 분산된 데이터베이스**를 말한다. 분산 데이터베이스는 데이터의 처리나 이용이 많은 지역에 데이터베이스를 위치시킴으로써 데이터의 처리가 가능한 해당 지역에서 해결될 수 있도록 한다. 분산 데이터베이스 설계는 애플리케이션이나 사용자가 분산되어 저장된 데이터에 접근하게 하는 것을 목적으로 한다.<br/>
&ensp;**분산 데이터베이스의 목표**는 다음과 같다.
* 위치 투명성(Location Transparency)
  - 액세스하려는 데이터베이스의 실제 위치를 알 필요 없이 단지 데이터베이스의 논리적인 명칭만으로 액세스할 수 있다.
* 중복 투명성(Replication Transparency)
  - 동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 자동을 여러 자료에 대한 작업을 수행한다.
* 병행 투명성(Concurrency Transparency)
  - 분산 데이터베이스와 관련된 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않는다.
* 장애 투명성(Failure Transparency)
  - 트랜잭션, DBMS, 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션을 정확하게 처리한다.

&ensp;**분산 설계 방법**은 다음과 같다.
* 테이블 위치 분산
  - 데이터베이스의 테이블을 각기 다른 서버에 분산시켜 배치하는 방법을 의미한다.
* 분할(Fragment)
  - 테이블의 데이터를 분할하여 분산시키는 것이다.
  - 분할 규칙: 완전성(Completeness), 재구성(Reconstruction), 상호 중첩 배제(Dis-jointness)
  - 주요 분할 방법은 다음과 같다.
    + 수평 분할: 특정 속성의 값을 기준으로 행(Row) 단위로 분할
    + 수직 분할: 데이터 컬럼(속성) 단위로 분할
* 할당(Allocation)
  - 동일한 분할을 여러 개의 서버에 생성하는 분산 방법으로, 중복이 없는 할당과 중복이 있는 할당으로 나뉜다.

데이터베이스 이중화 / 서버 클러스터링
======

&ensp;**데이터베이스 이중화(Database Replication)**는 시스템 오류로 인한 데이터베이스 서비스 중단이나 물리적 손상 발생 시 이를 복구하기 위해 **동일한 데이터베이스를 복제하여 관리하는 것**이다. 데이버베이스 이중화를 수행하면 하나 이상의 데이터베이스가 항상 같은 상태를 유지하므로 데이터베이스에 문제가 발생하면 복제된 데이터베이스를 이용하여즉시 문제를 해결할 수 있다.<br/>
&ensp;여러 개의 데이터베이스를 동시에 관리하므로 사용자가 수행하는 작업은 데이터베이스 이중화 시스템에 연결된 다른 데이터베이스에도 동일하게 적용된다. 애플리케이션을 여러 개의 데이터베이스에서 분산 처리하므로 데이터베이스의 부하를 줄일 수 있다. 데이터베이스 이중화를 이용하면 손쉽게 백업 서버를 운영할 수 있다.<br/>
&ensp;**데이터베이스 이중화를 분류**하면 다음과 같다.
* Eager 기법
  - 트랜잭션 수해 중 데이터 변경이 발생하면 이중화된 모든 데이터베이스에 즉시 전달하여 변경 내용이 즉시 적용되도록 하는 기법
* Lazy 기법
  - 트랜잭션의 수행이 종료되면 변경 사실을 새로운 트랜잭션에 작성하여 각 데이터베이스에 전달되는 기법
  - 데이터베이스마다 새로운 트랜잭션이 수행되는 것으로 간주됨

&ensp;**데이터베이스 이중화 구성 방법**은 다음과 같다.
* 활동-대기(Active-Standby) 방법
  - 한 DB가 활성 상태로 서비스하고 있으면 다른 DB는 대기하고 있다가 활성 DB에 장애가 발생하면 대기 상태에 있던 DB가 자동으로 모든 서비스를 대신 수행함
  - 구성 방법과 관리가 쉬워 많은 기업에서 이용됨
* 활동-활동(Active-Active) 방법
  - 두 개의 DB가 서로 다른 서비스를 제공하다가 둘 중 한쪽 DB에 문제가 발생하면 나머지 다른 DB가 서비스를 제공함
  - 두 DB가 모두 처리를 하기 때문에 처리융리 높지만 구성 방법 및 설정이 복잡함

&ensp;**클러스터링(Clustering)**은 **두 대 이상의 서버를 하나의 서버처럼 운영하는 기술**이다. 클러스터링은 서버 이중화 및 공유 스토리지를 사용하여 서버의 고가용성을 제공한다. 클러스터링의 종류는 다음과 같다.
* 고가용성 클러스터링
  - 하나의 서버에 장애가 발생하면 다른 노드(서버)가 받아 처리하여 서비스 중단을 방지하는 방식
  - 일반적으로 언급되는 클러스터링이 고가용성 클러스터링임
* 병렬 처리 클러스터링
  - 전체 처리율을 높이기 위해 하나의 작업을 여러 개의 서버에서 분산하여 처리하는 방식

&ensp;**RTO/RPO**는 다음과 같다.
* RTO(Recovery Time Objective, 목표 복구 시간)
  - 비상사태 또는 업무 중단 시점으로부터 복구되어 가동될 때까지의 소요 시간을 의미함
  - ex. 장애 발생 후 6시간 내 복구 가능
* RPO(Recovery Point Objective, 목표 복구 시점)
  - 비상사태 또는 업무 중단 시점으로부터 데이터를 복구할 수 있는 기준점을 의미함
  - ex. 장애 발생 전인 지난 주 금요일에 백업시켜 둔 복원 시점으로 복구 가능


데이터베이스 보안
======

&ensp;**데이터베이스 보안**이란 데이터베이스의 일부 또는 전체에 대해서 권한이 없느 사용자가 액세스하는 것을 금지하기 위해 사용되는 기술이다. 보안을 위한 데이터 단위는 테이블 전체로부터 특정 테이블의 특정한 행과 열 위치에 있는 특정한 데이터 값에 이르기까지 다양하다.<br/>
&ensp;**암호화(Encryption)**는 데이터를 보낼 때 송수신자가 지정한 수신자 이외에는 그 내용을 알 수 없도록 평문을 암호문으로 변환하는 것이다.
* 암호화(Encryption) 과정: 암호화되지 않은 평문을 정보 보호를 위해 암호문으로 바꾸는 과정
* 복호화(Decryption) 과정: 암호문을 원래의 평문으로 바꾸는 과정
* 암호화 기법에는 개인키 암호 방식과 공개키 암호 방식이 있다.

&ensp;**접근 통제**는 데이터가 저장된 객체와 이를 사용하려는 주체사이의 정보 흐름을 제한하는 것이다. 접근통제 3요소로 "접근통제 정책", "접근통제 메커니즘", "접근통제 보안모델"이 있다. 접근통제 기술은 다음과 같다.
* 임의 접근통제(DAC; Discretionary Access Control)
  - 임의 접근통제는 데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하는 방식이다.
  - 데이터 소유자가 접근통제 권한을 지정하고 제어한다.
  - 객체를 생성한 사용자가 생성된 객체에 대한 모든 권한을 부여받고, 부여된 권한을 다른 사용자에게 허가할 수도 있다.
* 강제 접근통제(MAC; Mandatory Access Control)
  - 강제 접근통제는 주체와 객체의 등급을 비교하여 접근 권한을 부여하는 방식이다.
  - 시스템이 접근통제 권한을 지정한다.
  - 데이터베이스 객체별로 보안 등급을 부여할 수 있고, 사용자별로 인가 등급을 부여할 수 있다.
* 역할기반 접근통제(RBAC; Role Based Access Control)
  - 역할기반 접근통제는 사용자의 역할에 따라 접근 권한을 부여하는 방식이다.
  - 중앙관리자가 접근 통제 권한을 지정한다.
  - 임의 접근통제와 강제 접근통제의 단점을 보와하였으며, 다중 프로그래밍 환경에서 최적화된 방식이다.

&ensp;**접근통제 정책**은 어떤 주체(Who)가 언제(When), 어디서(Where), 어떤 객체(What)에게, 어떤 행위(How)에 대한 허용 여부를 정의하는 것이다. 접근통제 정책의 종류는 다음과 같다.
* 신분 기반 정책
  - 주체나 그룹의 신분에 근거하여 객체의 접근을 제한하는 방법으로, IBP와 GBP가 있다.
  - IBP(Individual-Based Policy): 최소 권한 정책으로, 단일 주체에게 하나의 객체에 대한 허가를 부여한다.
  - GBP(Group-Based Policy): 복수 주체에 하나의 객체에 대한 허가를 부여한다.
* 규칙 기반 정책
  - 주체가 갖는 권한에 근거하여 객체의 접근을 제한하는 방법으로, MLP와 CBP가 있다.
  - MLP(Multi-Level Policy): 사용자 및 객체별로 지정된 기밀 분류에 따른 정책
  - CBP(Compartment-Based Policy): 집단별로 지정된 기밀 허가에 따른 정책
* 역할 기반 정책
  - GBP의 변형된 정책으로, 주체의 신분이 아니라 주체가 맡은 역할에 근거하여 객체의 접근을 제안하는 방법이다.

&ensp;**접근통제 메커니즘**은 정의된 접근통제 정책을 구현하는 기술적인 방법으로, 접근통제 목록, 능력 테스트, 보안 등급, 패스워드, 암호화 등이 있다.<br/>
&ensp;**접근통제 보안 모델**은 보안 정책을 구현하기 위한 정형화된 모델로, 접근통제 보안 모델의 종류는 다음과 같다.
* 기밀성 모델
  - 기밀성 모델은 군사적인 목적으로 개발된 최초의 수학적 모델로, 기밀성 보장이 최우선인 모델이다.
  - 기밀성 모델은 군대 시스템 등 특수한 환경에서 주로 사용된다.
* 무결성 모델
  - 무결성 모델은 기밀성 모델에서 발생하는 불법적인 정보 변경을 방지하기 위해 무결성을 기반으로 개발된 모형이다.
* 접근통제 모델
  - 접근통제 모델은 접근통제 메커니즘을 보안 모델로 발전시킨 것으로, 대표적으로 접근통제 행렬(Access Control Matrix)이 있다.
  - 접근통제 행렬(Access Control Matrix)
    + 임의적인 접근통제를 관리하기 위한 보안 모델로, 행은 주체, 열은 객체 즉, 행과 열로 주체와 객체의 권한 유형을 나타낸다.

&ensp;**접근통제 조건**은 접근통제 매커니즘의 취약점을 보완하기 위해 접근통제 정책에 부가하여 적용할 수 있는 조건이다.
* 값 종속 통제(Value-Dependent Control): 일반적으로는 객체에 저장된 값에 상관없이 접근통제를 동일하게 허용하지만 객체에 저장된 값에 따라 다르게 접근통제를 허용해야 하는 경우에 사용한다.
* 다중 사용자 통제(Multi-User Control): 지정된 객체에 다수의 사용자가 동시에 접근을 요구하는 경우에 사용된다.
* 컨텍스트 기반 통제(Context-Based Control): 특정 시간, 네트워크 주소, 접근 경로, 인증 수준 등에 근거하여 접근을 제어하는 방법으로, 다른 보안 정책과 결합하여 보안 시스템의 취약점을 보완할 때 사용된다.

&ensp;**감사 추적**은 사용자나 애플리케이션이 데이터베이스에 접근하여 수행한 모든 활동을 기록하는 기능이다. 감사 추적은 오류가 발생한 데이터베이스를 복구하거나 부적절한 데이터 조작을 파악하기 위해 사용된다.

데이터베이스 백업
======

&ensp;**데이터베이스 백업**은 전산 장비의 장애에 대비하여 데이터베이스에 저장된 데이터를 보호하고 복구하기 위한 작업으로, 치명적인 데이터 손실을 막기 위해서는 데이터베이스를 정기적으로 백업해야한다.<br/>
&ensp;**로그 파일**은 **데이터베이스의** 처리 내용이나 이용 상황 등 **상태 변화를 시간의 흐름에 따라 모두 기록한 파일**로, 데이터베이스의 복구를 위해 필요한 가장 기본적인 자료이다. 로그 파일을 기반으로 데이터베이스를 과거 상태로 복귀(UNDO)시키거나 현재 상태로 재생(REDO)시켜 데이터베이스 상태를 일관성 있게 유지할 수 있다. 로그 파일은 트랜잭션 시작 시점, Rollback 시점, 데이터 입력, 수정 삭제 시점 등에서 기록된다.<br/>
&ensp;**데이터베이스 복구 알고리즘**은 동기적/비동기적 갱신에 따라 다음과 같은 방법으로 분류된다.
* NO-UNDO/REDO
  - 데이터베이스 버퍼의 내용을 비동기적으로 갱신한 경우의 복구 알고리즘
  - NO-UNDO: 트랜잭션 완료 전에는 변경 내용이 데이터베이스에 기록되지 않았으므로 취소할 필요가 없다.
  - REDO: 트랜잭션 완료 후 데이터베이스 버퍼에는 기록되어 있고, 저장매체에는 기록되지 않았으므로 트랜잭션 내용을 다시 실행해야 한다.
* UNDO/NO-REDO
  - 데이터베이스 버퍼의 내용을 동기적으로 갱신한 경우의 복구 알고리즘
  - UNDO: 트랜잭션 완료 전에 시스템이 파손되었다면 변경된 내용을 취소한다.
  - NO-REDO: 트랜잭션 완료 전에 데이터베이스 버퍼 내용을 이미 저장 매체에 기록했으므로 트랜잭션 내용을 다시 실행할 필요가 없다.
* UNDO/REDO
  - 데이터베이스 버퍼의 내용을 동기/비동기적으로 갱신한 경우의 복구 알고리즘
  - 데이터베이스 기록 전에 트랜잭션이 완료될 수 있으므로 완료된 트랜잭션이 데이터베이스에 기록되지 못했다면 다시 실행해야 한다.
* NO-UNDO/NO-REDO
  - 데이터베이스 버퍼의 내용을 동기적으로 저장 매체에 기록하지만 데이터베이스와는 다른 영역에 기록한 경우 복구 알고리즘
  - NO-UNDO: 변경 내용은 데이터베이스와 다른 영역에 기록되어 있으므로 취소할 필요가 없다. 
  - NO-REDO: 다른 영역에 이미 기록되어 있으므로 트랜잭션을 다시 실행할 필요가 없다.

&ensp;**백업 종류**는 복구 수준에 따라서 운영체제를 이용하는 물리 백업과 DBMS 유틸리티를 이용하는 논리 백업으로 나뉜다.
* 물리 백업: 데이터베이스 파일을 백업하는 방법으로, 백업 속도가 빠르고 작업이 단순하지만 문제 발생 시 원인 파악 및 문제 해결이 어렵다.
* 논리 백업: DB 내의 논리적 객체들을 백업하는 방법으로, 복원 시 데이터 손상을 막고 문제 발생 시 원인 파악 및 해결이 수월하지만 백업/복원 시 시간이 많이 소요된다.



스토리지
======

&ensp;**스토리지(Storage)**는 단일 디스크로 처리할 수 없는 **대용량의 데이터를 저장하기 위해 서버와 저장장치를 연결하는 기술**이다. 스토리지의 종류는 다음과 같다.
* DAS(Direct Attached Storage)
  - **서버와 저장장치를 전용 케이블로 직접 연결하는 방식**으로, 일반 가정에서 컴퓨터에 외장하드를 연결하는 것이 여기에 해당한다.
  - 저장장치를 직접 연결하므로 속도가 빠르고 설치 및 운영이 쉽다.
  - 초기 구축 비용 및 유지보수 비용이 저렴하다.
  - 직접 연결 방식이므로 다른 서버에서 접근할 수 없고 파일을 공유할 수 없다.
  - 확장성 및 유연성이 상대적으로 떨어진다.
* NAS(Network Attached Storage)
  - **서버와 저장장치를 네트워크를 통해 연결하는 방식**이다.
  - 별도의 파일 관리 기능이 있는 NAS Storage가 내장된 저장장치를 직접 관리한다.
  - Ethernet 스위치를 통해 다른 서버에서도 스토리지에 접근할 수 있어 파일 공유가 가능하고, 장소에 구애받지 않고 저장장치에 쉽게 접근할 수 있다.
  - DAS에 비해 확장성 및 유연성이 우수하다.
* SAN(Storage Area Network)
  - DAS의 빠른 처리와 NAS의 파일 공유 장점을 혼합한 방식으로, **서버와 저장 장치를 연결하는 전용 네트워크를 별도로 구성하는 방식**이다.
  - 광 채널(FC) 스위치를 이용하여 네트워크를 구성한다.
  - 광 채널 스위치는 서버나 저장장치를 광케이블로 연결하므로 처리 속도가 빠르다.
  - 저장장치를 공유함으로써 여러 개의 저장장치나 백업 장비를 단일화시킬 수 있다.
  - 확장성, 유연성, 가용성이 뛰어나다.

논리 데이터 모델의 변환
======

&ensp;**엔티티(Entity)를 테이블로 변환**은 논리 데이터 모델에서 정의된 엔티티를 물리 데이터 모델의 테이블로 변환시키는 것이다. 변환 규칙은 다음과 같다.
* 앤티티(Entity) - 테이블(Table)
* 속성(Attribute) - 칼럼(Column)
* 주 식별자(Primary Identifier) - 기본키(Primary Key)
* 외부 식별자(Foreign Identifier) - 외래키(Foreign Key)
* 관계(Relationship) - 관계(Relationship)

&ensp;**슈퍼타입/서브타입**은 논리 테이터 모델에서 이용되는 형태이므로 물리 데이터 모델을 설계할 때는 슈퍼타입/서브타입을 테이블로 변환해야 한다. 슈퍼타입/서브타입 모델을 테이블로 변환하는 방법은 다음과 같다.
* 슈퍼타입 기준 테이블 변환
  - **서브타입을 슈퍼타입에 통합하여 하나의 테이블로 만드는 것**이다.
  - 서브타입에 속성이나 관계가 적을 경우에 적용하는 방법이다.
  - 하나로 통합된 테이블에는 서브타입의 모든 속성이 포함되어야 한다.
* 서브타입 기준 테이블 변환
  - **슈퍼티입 속성들을 각각의 서브타입에 추가하여 서브타입들을 개별적인 테이블로 만드는 것**이다.
  - 서브타입에 속성이나 관계가 많이 포함된 경우 적용한다.
* 개별타입 기준 테이블 변환
  - **슈퍼타입과 서브타입들을 각각의 개별적인 테이블로 변환하는 것**이다.
  - 슈퍼타입과 서브타입 테이블들 사이에는 각각 1:1 관계가 형성된다.

&ensp;논리 데이터 모델에서 정의한 **속성을 물리 데이터 모델의 칼럼으로 변환**한다.
* 일반 속성 변환: 속성과 칼럼은 명칭이 반드시 일치할 필요는 없으나, 개발자와 사용자 간 의사소통을 위하여 가능한 한 표준화된 약어를 사용하여 일치시키는 것이 좋음
* Primary UID를 기본키로 변환: 논리 데이터 모델에서의 Primary UID는 물리 데이터 모델의 기본키로 만듦
* Primary UID(관계의 UID Bar)를 기본키로 변환: 다른 엔티티와의 관계로 인해 생성된 Primary UID는 물리 데이터 모델의 기본키로 만듦
* Secondary(Alternate) UID를 유니트키로 변환: 논리 모델링에서 정의된 Secondary UID 및 Alternate Key는 물리 모델에서 유니크키로 만듦

&ensp;논리 데이터 모델에서 정의된 **관계는 기본키와 이를 참조하는 외래키로 변환**한다.

자료 구조
======

&ensp;**자료 구조**는 자료를 기억장치의 공간 내에 저장하는 방법과 자료 간의 관계 처리 방법 등을 연구 분석하는 것을 말한다. 저장 공간의 효율성과 실행시간의 단축을 위해 사용한다. 자료구조를 분류하면 다음과 같다.
&ensp;**선형 구조(Linear Structure)**는 다음과 같다.
* **배열(Array)**: **크기와 형(Type)이 동일한 자료들이 순서대로 나열된 자료의 집합**이다. 반복적인 데이터 처리 작업에 적합한 구조이다. 정적인 자료 구조로, 기억장소의 추가가 어렵고 데이터 삭제 시 기억장소가 빈 공간으로 남아있어 메모리의 낭비가 발생한다.
* 선형 리스트(Linear List)
  - **연속 리스트(Contiguous List)**: 배열과 같이 **연속되는 기억장소에 저장되는 자료 구조**이다. 중간에 데이터를 삽입하기 위해서는 연속된 빈 공간이 있어야 한다. 삽입•삭제 시 자료의 이동이 필요하다.
  - **연결 리스트(Linked List)**: **자료들을 임의의 기억공간에 기억시키되**, 자료 항복의 순서에 따라 **노드의 포인터 부분을 이용하여 서로 연결시킨 자료 구조**이다. 연결을 위한 링크(포인터) 부분이 필요하기 때문에 기억 공간의 이용 효율이 좋지 않다. 접근 속도가 느리고, 연결이 끊어지면 다음 노드를 찾기 어렵다.
* **스택(Stack)**: **리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조**이다. 후입선출(LIFO, Last In First Out) 방식으로 자료를 처리한다. 저장할 기억 공간이 없는 상태에서 데이터가 삽입되면 오버플로(Overflow)가 발생하고 삭제할 데이터가 없는 상태에서 데이터를 삭제하면 언더플로(Underflow)가 발생한다.
* **큐(Queue)**: **리스트의 한쪽에서는 삽입 작업**이 이루어지고 **다른 한쪽에서는 삭제 작업이 이루어지는 자료 구조**이다. 선입선출(FIFO, First In First Out) 방식으로 처리하고 시작을 표시하는 프런트(Front) 포인터와 끝을 표시하는 리어(Rear) 포인터가 있다.
* 데크(Deque)
&ensp;**비선형 구조(Non-Linear Structure)**는 다음과 같다.
* **트리(Tree)**: **정점(Node)과 선분(Branch)을 이용하여 사이클로 이루지 않도록 구성한 그래프(Graph)의 특수한 형태**이다. 트리는 하나의 기억 공간을 노드(Node)라고 하며, 노드와 노드를 연결하는 선을 링크(Link)라고 한다. **트리 관련 용어**는 다음과 같다.
  - 노드(Node): 트리의 기본 요소로서 자료 항목과 다른 항목에 대한 가지(Branch)를 합친 것
  - 근 노드(Root Node): 트리의 맨 위에 있는 노드
  - 디그리(Degree, 차수): 각 노드에서 뻗어나온 가지의 수
  - 단말 노드(Terminal Node), 잎 노드(Leaf Node): 자식이 하나도 없는 노드, 즉 Degree가 0인 노드
  - 비단말 노드(Non-Terminal Node): 자식이 하나라도 있는 노드, 즉 Degree가 0이 아닌 노드
  - 조상 노드(Ancestors Node): 임의의 노드에서 근 노드에 이르는 경로상에 있는 노드들
  - 자식 노드(Son Node): 어떤 노드에 연결된 다음 레벨의 노드들
  - 부모 노드(Parent Node): 어떤 노드에 연결된 이전 레벨의 노드들
  - 형제 노드(Brother Node, Sibling): 동일한 부모를 갖는 노드들
  - Level: 근 노드의 Level을 1로 가정한 후 어떤 Level이 L이면 자식 노드는 L+1
  - 깊이(Depth, Height): 트리에서 노드가 가질 수 있는 최대의 레벨
  - 숲(Forest): 여러 개의 트리가 모여 있는 것
  - 트리의 디그리: 노드들의 디그리 중에서 가장 많은 수
* **그래프(Graph)**: **정점(Vertex)과 간선(Edge)의 두 집합으로 이루어지는 자료 구조**이다. 사이클이 없는 그래프를 트리라고 한다. 간선의 방향성 유무에 따라 방향 그래프와 무방향 그래프로 구분된다.
  - **방향 그래프의 최대 간선 수**: n(n-1)
  - **비방향 그래프의 최대 간선 수**: n(n-1)/2

이진 트리
======

&ensp;**이진 트리**는 **차수(Degree)가 2 이하인 노드들로 구성된 트리**, 즉 자식이 둘 이하인 노드들로만 구성된 트리를 말한다. 이진 트리의 레벨 i에서 최대 노드의 수는 $2^{i-1}$이다. 이즌 트리에서 Terminal Node수가 $n_0$, 차수가 2인 노드 수가 &n_2&라 할 때, $n_0 = n_2 + 1$이 된다.<br/>
&ensp;트리를 구성하는 각 노드들을 찾아가는 방법을 **운행법(Traversal)**이라 한다. 이진 트리를 운행하는 방법은 산술식의 표기법과 연관성을 갖는다. 이진 트리의 운행법은 다음 세 가지가 있다.<br/>
<p align="center"><img src="/assets/img/정보처리기사/소프트웨어 개발/데이터 입출력 구현/2-1.jpeg" width="300"></p>

* **Preorder 운행**: Root, Left, Right 순으로 운행한다. A, B, C
* **Inorder 운행**: Left, Root, Right 순으로 운행한다. B, A, C
* **Postorder 운행**: Left, Right, Root 순으로 운행한다. B, C, A

&ensp;이진 트리로 만들어진 **수식**을 인오더, 프리오더, 포스트오더로 운행하면 각각 중위(Infix), 전위(Prefix), 후위(Postfix) 표기법이 된다.
<p align="center"><img src="/assets/img/정보처리기사/소프트웨어 개발/데이터 입출력 구현/2-2.jpeg" width="300"></p>

* **전위 표기법(PreFix)**: 연산자, Left, Right, +AB
* **중위 표기법(InFix)**: Left, 연산자, Right, A+B
* **후위 표기법(PostFix)**: Left, Right, 연산자, AB+

정렬(Sort)
======

* **삽입 정렬(Insertion Sort)**
  - 가장 간단한 정렬 방식으로 **이미 순서화된 파일에 새로운 하나의 레코드를 순서에 맞게 삽입시켜 정렬하는 방식**이다.
  - 평균과 최악 모두 수행 시간 복잡도는 O($n^2$)이다.
* **선택 정렬(Selection Sort)**
  - n개의 레코드 중에서 **최소값을 찾아 첫 번째 레코드 위치에 놓고**, 나머지 (n-1)개 중에서 **다시 최소값을 찾아 두 번째 레코드 위치에 놓는 방식을 반복하여 정렬하는 방식**이다.
  - 평균과 최악 모두 수행 시간 복잡도는 O($n^2$)이다.
* **버블 정렬(Bubble Sort)**
  - 주어진 파일에서 **인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환하는 정렬 방식**이다.
  - 평균과 최악 모두 수행 시간 복잡도는 O($n^2$)이다.
* **쉘 정렬(Shell Sort)**
  - 입력 파일을 **어떤 매개변수의 값으로 서브파일을 구성하고, 각 서브파일을 Insertion 정렬 방식으로 순서 배열하는** 과정을 반복하는 **정렬 방식**이다.
  - 삽입 정렬을 확장한 개념이다.
  - 평균 수행 시간 복잡도는 O($n^{1.5}$)이고, 최악의 수행 시간 복잡도는 O($n^2$)이다.
* **큌 정렬(Quick Sort)**
  - **키를 기준으로 작은 값은 왼쪽에, 큰 값은 오른쪽 서브파일로 분해시키는** 과정을 반복하는 **정렬 방식**이다.
  - 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬한다.
  - 평균 수행 시간 복잡도는 O(nlogn)이고, 최악의 수행 시간 복잡도는 O($n^2$)이다.
* **힙 정렬(Heap Sort)**
  - **완전 이진 트리(Complete Binary Tree)를 이용한 정렬 방식**이다.
  - 구성된 완전 이진 트리를 Heap Tree로 변환하여 정렬한다.
  - 평균과 최악 모두 시간 복잡도는 O(nlogn)이다.
* **2-Way 합병 정렬(Merge Sort)**
  - 이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬 방식이다.
  - 평균과 최악 모두 시간 복잡도는 O(nlogn)이다. 
* **기수 정렬(Radix Sort), Bucket Sort**
  - **Queue를 이용하여 자릿수(Digit)별로 정렬하는 방식**이다.
  - 레코드의 키 값을 분석하여 같은 수 또는 같은 문자까리 그 순서에 맞는 버킷에 분배 하였다가 버킷의 순서대로 레코드를 꺼내어 정렬한다.
  - 평균과 최악 모두 시간 복잡도는 O(dn)이다.