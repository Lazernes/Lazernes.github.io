---
title: "회원가입 및 로그인 기능"
excerpt: "SringBoot와 Flutter, Firebase를 이용하여 회원가입 및 로그인 기능을 구현한다."

wirter: Myeongwoo Yoon
categories:
  - AIML
tags:
  - Spring
  - Java
  - Flutter
  - MySQL

toc: true
toc_sticky: true
use_math: true 

date: 2024-09-24
last_modified_at: 2023-09-24
---

&ensp;MySQL을 사용하여 회원가입 기능을 구현하기 위해서 다음과 같은 dependency를 추가한다.
```java
implementation 'org.springframework.boot:spring-boot-starter-security'
implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
testImplementation 'org.springframework.security:spring-security-test'

runtimeOnly 'com.mysql:mysql-connector-j'
```

데이터베이스 테이블 설계
======

MySQL CREATE TABLE
------

&ensp;먼저 회원의 정보를 저장할 데이터베이스를 생성한다. CREATE문을 통해 데이터베이스를 생성하고, USE를 통해 해당 데이터베이스를 사용한다.
```sql
CREATE DATABASE AIML;
USE AIML;
```

&ensp;회원가입 기능을 구현해야 하므로, 다음과 같이 TABLE을 생성한다.
```sql
CREATE TABLE Member(
	id VARCHAR(20) NOT NULL,
    password VARCHAR(20) NOT NULL,
    name VARCHAR(5) NOT NULL,
    phoneNum VARCHAR(13) NOT NULL,
    CONSTRAINT Member_PK PRIMARY KEY(id)
);
```

<p align="center"><img src="/assets/img/AIML/회원가입 및 로그인 기능/1-1-MEMBER TABLE.png" width="500"></p>

MEMBER Class
------

&ensp;회원가입을 할 때, 우선 ID, Password가 필요하고 이름, 전화번호를 MyPage에 출력하는 것을 해야하므로, Member에 위 Attribute를 설정하였다. 이후, 다음과 같은 Java 코드를 작성한다.
```java
package com.Member.aiml_server_2024.userInfo;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

@NoArgsConstructor  // JPA를 이용하기 위해 기본 생성자를 Lombok으로 선언
@Getter
@Entity(name = "Member")    // 데이터베이스 테이블과 매핑되는 클래스임을 선언
public class Member {
    @Id // id 칼럼을 MEMBER 테이블의 기본키로 설정
    private String id;
    private String password;
    private String name;
    private String phoneNum;

    @Builder
    public Member(String id, String password, String name, String phoneNum) {
        this.id = id;
        this.password = password;
        this.name = name;
        this.phoneNum = phoneNum;
    }

    @Getter
    @Setter
    @NoArgsConstructor
    public static class SaveRequest {
        private String id;
        private String password;
        private String name;
        private String phoneNum;

        @Transient
        public Member toEntity() {
            return Member.builder()
                    .id(this.id)
                    .password(this.password)
                    .name(this.name)
                    .phoneNum(this.phoneNum)
                    .build();
        }

    }

}
```

&ensp;**DTO(Data Transfer Object)** 클래스는 데이터 전송을 담당하는 클래스로, 위와같이 Member 클래스의 내부 정적 클래스로 선언했다.

application.properties
------

&ensp;application.properties에 다음 내용을 추가한다.
```
## Spring JDBC 연동 정보 설정
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url = jbcc:mysql://localhost:3306/aiml?serverTimezone=Asia/Seoul
spring.datasource.username=root
spring.datasource.password=qpalzm7801@

##Spring Data JPA
#true 설정시 JPA 쿼리문 확인 가능
spring.jpa.show-sql=true
# 데이터베이스 생성 쿼리를 보기 위해 create로 설정
spring.jpa.hibernate.ddl-auto=create
```

Spring Security 설정
======

기존 API 설정
------
&ensp;먼저 Spring Security를 사용하면 기존 Firebase의 데이터를 가져오는 API를 호출하면 401 Error가 발생하므로 다음과 같이 SecurityConfig.java를 생성해준다.
```java
package com.Member.aiml_server_2024.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityCustomizer;

@Configuration
@EnableWebSecurity  // Spring Security 설정 활성화
@EnableMethodSecurity(securedEnabled = true, jsr250Enabled = true, prePostEnabled = true)
public class SecurityConfig {

    @Bean
    public WebSecurityCustomizer webSecurityCustomizer() {
        return (web -> web.ignoring().requestMatchers("/location/**", "/UserInfo/get"));
        // 예외처리 하고 싶은 url
    }
}
```

&ensp;WebSecurityCustomizer는 Spring Security 설정을 커스터마이징하기 위한 인터페이스다. 이 메서드가 수행하는 역할은 특정 URL 패턴을 Spring Security의 인증 및 권한 검사에서 **예외 처리**하는 것이다. 즉, 해당 경로들에 대해서는 보안 필터를 적용하지 않고 접근을 허용하게 된다.<br/>
&ensp;이제 SecurityFilterChain과 PasswordEncoder 메서드를 만들어본다.
```java
package com.Member.aiml_server_2024.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityCustomizer;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(securedEnabled = true, jsr250Enabled = true, prePostEnabled = true)
public class SecurityConfig {

    @Bean
    public WebSecurityCustomizer webSecurityCustomizer() {
        return (web -> web.ignoring().requestMatchers("/location/**", "/UserInfo/get"));
        // 예외처리 하고 싶은 url
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity httpSecurity) throws Exception {
        httpSecurity
                .authorizeHttpRequests(authorize -> authorize
                        .requestMatchers("/").authenticated()
                        .anyRequest().permitAll()
                )
                .formLogin(form -> form
                        .loginPage("/login")    // 사용자 정의 로그인 페이지
                        .loginProcessingUrl("/api/login")   // 로그인 처리 URL
                        .defaultSuccessUrl("/") // 로그인 성공 시 이동할 URL
                )
                .logout(logout -> logout
                        .logoutUrl("/logout")   // 로그이웃 처리 URL
                )
                .csrf(csrf -> csrf.disable());

        return httpSecurity.build();
    }

    @Bean
    public PasswordEncoder getPasswordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

&ensp;이제 메인 페이지인 "/" 페이지는 인증받은 사용자만 접근할 수 있으며, 인증받지 않은 사용자가 접근할 경우 로그인 페이지 "/login"로 이동하게 된다. 또한 사용자가 입력한 로그인 폼을 "/api/login"으로 POST method로 전송하면 loginProcessingUrl() 메서드를 통해 해당 요청이 될 시 SpringSecurity가 직접 알아서 로그인 과정을 진행해준다.

Spring
======

LoginController
------

&ensp;사용자가 요청한 페이지를 반환해주는 Controller를 작성한다.
```java
package com.Member.aiml_server_2024.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class LoginController {
    @GetMapping("/")
    public String main() {
        return "main";
    }

    @GetMapping("/login")
    public String login() {
        return "login";
    }

    @GetMapping("/register")
    public String register() {
        return "register";  // 회원가입 페이지
    }
}
```

&ensp;이제 인증받지 않은 사용자가 메인페이지 "/"에 접근하면 로그인 페이지를 반환하거나 회원가입 후 로그인 페이지로 접근할 수 있게 된다.

MemberApiController, MemberService, MemberRepository
------

```java
package com.Member.aiml_server_2024.controller;

import com.Member.aiml_server_2024.userInfo.Member;
import com.Member.aiml_server_2024.userInfo.MemberService;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class MemberApiController {
    private final MemberService memberService;

    public MemberApiController(MemberService memberService) {
        this.memberService = memberService;
    }

    @PostMapping("/api/member")
    public void save(@RequestBody Member.SaveRequest member) {
        memberService.save(member);
    }
}
```

```java
package com.Member.aiml_server_2024.userInfo;

import org.springframework.transaction.annotation.Transactional;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

@Service
public class MemberService implements UserDetailsService {
    private final MemberRepository memberRepository;
    private final PasswordEncoder passwordEncoder;

    public MemberService(MemberRepository memberRepository, PasswordEncoder passwordEncoder) {
        this.memberRepository = memberRepository;
        this.passwordEncoder = passwordEncoder;
    }

    public void save(Member.SaveRequest member) {
        member.setPassword(passwordEncoder.encode(member.getPassword()));
        memberRepository.save(member.toEntity());
    }

    @Override
    @Transactional(readOnly = true)
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Member member = memberRepository.findById(username)
                .orElseThrow(() -> new UsernameNotFoundException("username"));

        return toUserDetails(member);
    }

    private UserDetails toUserDetails(Member member) {
        return User.builder()
                .username(member.getId())
                .password(member.getPassword())
                .build();
    }
}
```

```java
package com.Member.aiml_server_2024.userInfo;

import org.springframework.data.jpa.repository.JpaRepository;

public interface MemberRepository extends JpaRepository<Member, String> {
}
```

PostMan 실행 결과
------

<p align="center"><img src="/assets/img/AIML/회원가입 및 로그인 기능/4-1-Postman-Request.png" width="500"></p>

<p align="center"><img src="/assets/img/AIML/회원가입 및 로그인 기능/4-2-Postman-Request-MySQL.png" width="500"></p>

Flutter
======