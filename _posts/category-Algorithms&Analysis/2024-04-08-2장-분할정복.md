---
title: "분할정복"
excerpt: "문제의 입력사례를 두 개 이상의 작은 입력사례로 분할한 뒤 분할한 입력사례로 부터 답을 얻는다."

wirter: Myeongwoo Yoon
categories:
  - Algorithms&Analysis
tags:
  - Algorithms

toc: true
toc_sticky: true
use_math: true 

date: 2024-04-08
last_modified_at: 2023-04-08
---

&ensp;**분할정복(Divide-and-Conquer)**은 **하향식(top-down) 문제풀이 방식**이다. 즉, 문제의 상위 입력사례의 해답은 하위의 작은 입력사례(들)의 해답을 가지고 구한다. 재귀함수가 작동하는 원리가 바로 이렇다. 분할정복 알고리즘을 설계할 때도 보통 알고리즘을 재귀로 작성한다. 후에 재귀 알고리즘은 효율적인 반복 알고리즘으로 변형할 수 있다.

이분검색
======
&ensp;이분검색 알고리즘을 재귀(recursion)로 설계해본다.
1. (비내림차순으로) 정렬된 배열을 분할정복으로 이분검색을 하기 위해서는 먼저 배열의 정 가운데 원소와 키 $x$를 비교한다. 만일 같으면 원소를 찾았으므로 알고리즘을 종료한다.
2. 만약 다르면, 배열을 이미 비교한 원소를 기준으로 반으로 분할한다. 만약 $x$가 가운데 원소보다 작으면, 온쪽 배열에서 찾아야 하고, 그렇지 않으면 오른쪽 배열에서 찾아야한다.
3. 왼쪽 또는 오른쪽 중 원소가 있을 해당 반쪽 배열의 정 가운데 원소와 다시 비교하고 위 과정을 $x$를 찾거나 $x$가 그 배열에 없다고 확신할 때까지 이 절차를 계속한다.

&ensp;다음 예제를 보자.<br/>
<p align="center"><img src="/assets/img/Algorithms&Analysis/2장 분할정복/1-1.png" width="500"></p>

1. [분할] 배열을 분할한다. $x < 25$이기 때문에 왼쪽 배열에서 검색한다.
  - 10 12 13 14 18 20
2. [정복] 왼쪽 배열에 $x$가 있는지 결정한다(왼쪽 배열을 재귀적으로 정복한다).
  - $x$는 왼쪽 배열에 있다.
3. [취합] 왼쪽 배열에서 얻은 답으로 전체 배열에 대한 답을 구한다.
  - $x$는 왼쪽 배열에 있다.

&ensp;재귀로 작성한 이분검색 알고리즘을 보자.
```cpp
// 문제: 원소가 n개인 정렬된 배열 S에 검색키 x가 있는가?
// 입력: 양의 정수 n, 정렬된(비내림차순) 배열 S(첨자는 1부터 n까지), 검색키 x
// 출력: location, S에서 x의 위치(만약 x가 s에 없으면 0)
index location(index low, index high){
  index mid;

  if (low > high){
    return 0; // 다 본 경우
  } else {
    mid = ⌊(low + high) / 2⌋;
    if (x == S[mid]){
      return mid;
    } else if (x < S[mid]){
      return location(low, mid - 1);
    } else {
      return location(mid + 1, high);
    }
  }
}
```