---
title: "분기한정법"
excerpt: "Branch and Bound"

wirter: Myeongwoo Yoon
categories:
  - Algorithms&Analysis
tags:
  - Algorithms

toc: true
toc_sticky: true
use_math: true 

date: 2024-06-05
last_modified_at: 2024-06-05
---

&ensp;분기한정(BB, Branch-and-Bound) 알고리즘은 Backtracking 알고리즘을 개선한 것이다. 분기한정 설계전략은 상태공간트리를 사용하여 문제를 푼다는 사실이 backtracking과 매우 비슷하다. 차이점으로 BB는 트리 횡단방법에 구애받지 않고, 최적화 문제를 푸는데 만 쓰인다. BB는 어떤 마디가 유망한지를 결정하기 위해서 그 마디에서 수(한계값)를 계산한다. 이 수는 그 마디 아래로 확장하여 구할 수 있는 해답 값의 한계(bound)를 나타낸다. 그 한계값이 그때까지 찾은 최고 해답 값보다 더 좋지 않으면 그 마디는 **유망하지 않다(nonpromising)**, 그렇지 않으면 그 마디는 **유망하다(promising)**라고 한다.<br/>
&ensp;마디가 유망한지를 결정하기 위해 한계값을 사용하는 것 외에도 유망한 마디들의 한계값을 비교하여 그 중에서 가장 좋은 한계값을 가진 마디의 자식마디를 방문한다. 이렇게 하면 미리 정한 순서대로 마디를 방법론적으로 방문하는 것보다 더 빨리 최적해에 도달할 수 있다. 이 방법을 **분기한정 가지치기 최고우선검색(Best-first search with Branch-and-Bound pruning)**이라고 한다. 이 방법은 **분기한정 가지치기 너비우선검색(Breadth-first search with Branch-and-Bound pruning)**이라고 하는 또 다른 하나의 방법론적인 접근법을 간단히 수정하여 구현할 수 있다.<br/>
&ensp;먼저 너비우선검색을 알아본다. 트리의 경우 **너비우선검색(Breadth-first search)**은 뿌리마디를 먼저 방문하고, 다음에 수준 1의 마디를 모두 방문하고, 다음에 수준 2의 마디를 모두 방문하고, 등등 이런식으로 계속한다. 다음은 왼쪽에서 오른쪽으로 진행하는 경우 트리의 Breadth-first search를 보여준다.<br/>
<p align="center"><img src="/assets/img/Algorithms&Analysis/6장 분기한정법/0-1-BFS.png" width="700"></p>

&ensp;깊이우선검색과는 달리 너비우선검색을 하는 재귀 알고리즘은 작성하기 어렵다. 그러나 대기열(queue)을 사용하여 아래 알고리즘과 같은 방식으로 구현할 수 있다. enqueue라는 프로시저로 대기열의 뒤에 아이템을 붙여 넣고, dequeue라는 프로시저로 앞에서 아이템을 제거한다.
```cpp
void breadth_first_tree_search(tree T) {
    queue_of_node Q;
    node u, v;

    initialize(Q);  // Q를 빈 대기열로 초기화
    v = root of T;
    visit v;
    enqueue(Q, v);

    while(!empty(Q)) {
        dequeue(Q, v);

        for(each child u of v) {
            visit u;
            enqueue(Q, u);
        }
    }
}
```

분기한정을 0-1 배낭 채우기 문제로 설명하기
======

&ensp;먼저 node 구조체를 정해준다.
```cpp
struct node {
    int level;  // use level instead of i in BB
    int profit, weight;
}
```

&ensp;다음 예에서 다음과 같은 사례를 사용한다.<br/>
<p align="center"><img src="/assets/img/Algorithms&Analysis/6장 분기한정법/1-1-sample.png" width="500"></p>

&ensp;weight와 profit은 그 마디에 오기까지 포함되었던 아이템의 총 무게와 총 이익으로 한다. 마디가 유망한지를 결정하기 위해서 totweight와 bound를 weight와 profit으로 각각 초기화하고, 그 다음 totweight가 W를 초과하게 하는 아이템에 도달할 때까지 Greedy하게 아이템을 취하여 그 무게와 이익을 totweight와 bound에 각각 더한다. 배낭에 넣을 수 있는 만큼만 그 아이템의 일부분을 취하여 그 부분의 weight를 totweight에 더한다. 이런식으로 bound는 그 마디에서 확장하여 얻을 수 있는 이익의 상한이 된다. 만약 그 마디가 수준 $i$에 위치하고 있고, 수준 $k$에 위치한 마디는 무게의 합이 $W$가 넘어가는 마디라고 하면 다음과 같은 식을 얻는다.
<center>$totweight = weight + \sum\limits_{j=i+1}^{k-1} w_j$</center>
<center>$bound = (profit + \sum\limits_{j=i+1}^{k-1} p_j) + (W - totweight) \times \frac{p_k}{w_k}$</center>

&ensp;지금까지 찾은 최고 해답에서의 값인 maxprofit보다 이 한계값이 작거나 같으면($bound \le maxprofit$) 그 마디는 유망하지 않고 $weight \ge W$가 성립해도 유망하지 않다.

Breadth-First Search with Branch-and-Bound Pruning
------
&ensp;

Best-First Search with Branch-and-Bound Pruning
------

외판원 문제
======