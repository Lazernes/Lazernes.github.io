---
title: "되추적"
excerpt: "Backtracking"

wirter: Myeongwoo Yoon
categories:
  - Algorithms&Analysis
tags:
  - Algorithms

toc: true
toc_sticky: true
use_math: true 

date: 2024-06-03
last_modified_at: 2024-06-03
---

The Backtracking Technique
======
&ensp;**Backtracking**은 임의의 **집합(set)**에서 주어진 **기준(criterion)**대로 원소의 **순서(sequence)**를 선택하는 문제를 푸는데 사용한다. Backtracking은 트리의 변형된 **깊이우선검색(DFS, Depth-First Search)**이다. Preorder(부모마디우선) 트리검색은 트리의 깊이우선검색이다. 이는 뿌리마디(root)를 먼저 방문한 후, 그 뿌리마디(node)의 후손들을 모두 방문한다.<br/>
&ensp;깊이우선검색을 하는 간단한 재귀 알고리즘이 있다. 이 알고리즘은 자식마디를 방문하는 순서에 대해 언급하지는 않았지만, 왼쪽에서 오른쪽으로 방문하도록 한다.
```cpp
void depth_first_tree_search (node v) {
  node u;
  visit v;
  for(each child u of v)
    depth_first_tree_search(u);
}
```

&ensp;내려 가봐야 해답이 없는 마디를 만나는 순간, 그 마디의 검색을 중단하고 그 마디의 부모마디로 돌아가서 다른 자식마디의 검색을 계속하는 과정이 **Backtracking**이다. 해답이 될 가능성이 없는 마디를 **유망하지 않다(nonpromising)**고 한다. 그렇지 않으면 **유망하다(promising)**고 한다. 요약해 보면 Backtracking은 상태공간트리를 깊이우선검색하여 각 마디가 promising한지를 검사하고, 만약 nonpromising하지 않으면 그 마디의 부모마디로 Backtracking한다. 이 절차를 상태공간트리를 **가지친다(pruning)**고 하고, 유망한 마디만으로 구성된 부분트리를 **가지친 상태공간트리(pruned state space tree)**라고 한다. Backtracking의 일반적인 알고리즘은 다음과 같다.
```cpp
void checknode (node v) {
  node u;

  if(promising(v)){
    if(there is a solution at v)
      write the solution;
    else{
      for(each child u of v)
      checknode(u);
    }
  }
}
```

&ensp;상태공간트리의 뿌리마디는 호출할 때 파라미터로 checknode에 전달된다. 마디를 방문하면 일단 그 마디가 promising한지를 먼저 점검한다. 만약 그 마디가 promising하고 그 마디에 해답이 있으면, 해답을 프린트한다. promising한 마디에 해답이 없으면, 그 마디의 자식마디를 방문한다.<br/>
&ensp;Backtracking Algorithm이 트리를 실제로 구축할 필요는 없다. 대신, 조사 중인 해당 가지(branch)의 값만 알고 있으면 된다. 즉, 상태공간트리가 알고리즘에서 **묵시적으로(implicity)** 존재한다.<br/>
&ensp;Backtracking Algorithm(checknode)에 비효율적인 부분이 있다. 마디를 프로시저에 전달한 후 마디의 유망여부를 점검한다. 이는 활성레크드 스택에 유망하지 않는 마디의 활성레코드를 불필요하게 쌓아 놓음을 뜻한다. 마디를 전달하기 전에 마디의 유망성을 점검하면 이 비효율성을 제거할 수 있다. 이를 적용시킨 일반 알고리즘은 다음과 같다.
```cpp
void expand (node v) {
  node u;

  for(each child u of v) {
    if(promising(v)){
      if(there is a solution at u)
        write the solution;
      else
        expand(u);
    }
  }
}
```

&ensp;알고리즘에 파라미터로 전달된 마디는 뿌리이다. 이 알고리즘을 expand라고 하는 이유는 유망한 마디를 확장(expand)할 때 이 프로시저를 호출하기 때문이다. 이 알고리즘을 프로그램으로 구현하면 활성레코드 스택에 유망하지 않은 마디의 활성레코드를 쌓아놓지 않고 그 유망하지 않은 마디에서 backtracking한다.

The n-Queens Problem
======
&ensp;**The n-Queens Problem**은 여왕말을 서로 잡아먹지 않게 두어야 한다. 같은 행과 열, 대각선에 두 말을 놓을 수 없다. 예를 한번 보자.<br/>
<p align="center"><img src="/assets/img/Algorithms&Analysis/5장 되추적/2-1-N-Queen-Problems-ex-1.png" width="700"></p>
<p align="center"><img src="/assets/img/Algorithms&Analysis/5장 되추적/2-2-N-Queen-Problems-ex-2.png" width="700"></p>

* $<1, 1>$은 유망하다.
  - 여왕말 1이 두는 첫째 말이기 때문이다.
* $<2, 1>$은 유망하지 않다.
  - 여왕말 1이 열 1에 있기 때문이다.
* $<2, 2>$은 유망하지 않다.
  - 여왕말 1이 왼쪽 대각선에 있기 때문이다.
* $<2, 3>$은 유망하다.
* $<3, 1>$은 유망하지 않다.
  - 여왕말 1이 열 1에 있기 떄문이다.
* $<3, 2>$은 유망하지 않다.
  - 여왕말 2가 오른쪽 대각선에 있기 때문이다.
* $<3, 3>$은 유망하지 않다.
  - 여왕말 2가 열 3에 있기 때문이다.
* $<3, 4>$은 유망하지 않다.
  - 여왕말 2가 왼쪽 대각선에 있기 때문이다.
* $<1, 1>$로 backtracking

&ensp;위와 같게 계속 추적하다보면 해답을 알 수 있다.<br/>
&ensp;The n-Queens Problem에서 유망함수는 두 여왕말이 같은 열이나 대각선에 있는지 검사해야 한다. 만약 $col(i)$를 $i$째 행에서 여왕말이 놓어있는 열이라고 하면, $k$째 행에 있는 여왕말이 같은 열에 있는지 검사하기 위해서 식 $col(i) = col(k)$이 성립하는지 검사해야 한다($i > k$).<br/>
&ensp;대각선의 경우를 보면, 행 $k$에 있는 여왕말은 행 $i$에 놓여있는 여왕말에 의해서 어느 한쪽 대각선으로 위협받고 있으면, 식 $col(i) - col(k) = i - k$ 또는 $col(k) - col(i) = k - i$가 성립한다. 이제 알고리즘을 살펴보자.
```cpp
// 문제: 체스판에 어떤 두 여왕말도 같은 행, 열, 대각선에 있지 않도록 n개 여왕말을 놓으시오.
// 입력: 양의 정수 n
// 출력: n x n 체스판에 n개 여왕말을 서로 위협받지 않고 놓을 수 있는 가능한 모든 방법. 각 출력은 인덱스 범위가 1부터 n까지인 정수배열 col로 이루어진다.
// 여기서 col[i]는 i번째 행에 있는 여왕말이 놓여있는 열이다.
void queens (index i) {
  index j;

  if(promising(i)){
    if(i == n)
      cout << col[1] through col[n];
    else{
      for(j = 1; j <= n; j++){
        col[i + 1] = j;
        queens(i + 1);
      }
    }
  }
}

bool promising (index i) {
  index k;
  bool switch;

  k = 1;
  switch = true;

  while(k < i && switch) {
    if(col[i] == col[k] || abs(col[i] - col[k]) == i - k)
      switch = false;
    k++;
  }
  return switch;
}
```

&ensp;만약 $n$과 $col$이 전역변수로 정의된다면, queens의 최초 호출은 $queens(0)$;이다.<br/>
<p align="center"><img src="/assets/img/Algorithms&Analysis/5장 되추적/2-3-N-Queen-Problems-ex-3.JPEG" width="700"></p>

&ensp;이 알고리즘을 분석하기 위해서 검사하는 마디의 수를 여왕말의 개수인 $n$의 함수로 나타내야 한다. 트리에서 마디 개수의 상한은 전체 마디의 개수를 세어 구할 수 있다.
<center>$1 + n + n^2 + \cdots + n^n = \frac{n^{n + 1} - 1}{n - 1}$</center>

&ensp;만약 $n = 8$인 경우, 상태공간트리의 마디 개수는 19173961마디가 된다. 하지만 이렇게 알고리즘을 분석하는 것은 진정한 분석이 아니다. Backtracking의 목적은 알고리즘을 실행하기 전에 알고리즘이 효율적인지를 결정하는 데 있다. 다음 몬테칼로 기법을 사용하면 어떻게 backtracking algorithm의 효율을 추정할 수 있는지 알 수 있다.

몬테칼로 알고리즘을 사용한 Backtracking Algorithm의 효율성 추정
======
&ensp;**몬테칼로 알고리즘(Monte Carlo Algorithms)**은 실행할 명령이 무작위로 결정되는 **확률 알고리즘(probabilistic algorithm)**이다. **결정 알고리즘(deterministic algorithm)**은 그렇지 않다. 지금까지 공부한 알고리즘은 모두 결정 알고리즘이다. 몬테칼로 알고리즘은 표본공간의 무작위 표본의 평균치를 가지고 표본공간에서 정의된 무작위변수의 기대치를 추정한다. 추정치가 실제 기대치에 근접하리라는 보장은 없지만 알고리즘을 오래 실행할수록 실제 기대치에 근접할 확률은 증가한다. 몬테칼로 알고리즘을 사용하여 특정 사례에 대한 backtrackin algorithm의 효율을 추정할 수 있다.<br/>
&ensp;이 기술을 적용하기 위해서 알고리즘은 다음 조건을 반드시 만족해야 한다.
* 상태공간트리의 같은 수준의 모든 마디에서 같은 유망함수를 사용해야 한다.
* 상태공간트리에서 같은 수준에 있는 마디들은 모두 자식마디의 개수가 같아야 한다.

&ensp;The n-Queens problem은 이 조건을 만족한다.
&ensp;$m_i$를 수준 $i$에서 마디들의 유망한 자식마디의 평균 개수의 추정치, $t_i$를 수준 $i$에서 어떤 마디의 자식마디의 총 개수라고 하면, 어떤 마디 $t_i$개의 자식마디를 모두 검사하고 $m_i$개의 유망한 자식만 검사한 자식마디이기 때문에 backtracking algorithm이 해답을 모두 찾기 위해서 검사한 마디의 총 개수 추정치는 다음과 같다.
<center>$1 + t_0 + m_0t_1 + m_0m_1t_2 + \cdots + m_0m_1 \cdots m_{i-1}t_i + \cdots$</center>

&ensp;이 추정치를 계산하는 일반 알고리즘은 다음과 같다. 이 알고리즘에서 변수 $mprod$는 각 수준에서 만들어진 $m_0m_1 \cdots m_{i-1}$을 표현하는데 쓴다.
```cpp
// 문제: 몬테칼로 알고리즘을 사용하여 backtracking algorithms의 효율을 추정하시오.
// 입력: Backtracking algorithm이 풀려고 하는 문제의 사례
// 출력: 알고리즘이 만들어 내는 가지친 상태공간트리에서 마디의 개수 추정치.
// 그 사례에 대하여 알고리즘이 해답을 모두 찾기 위하여 검사하는 마디의 개수가 됨.
int estimate () {
  node v;
  int m, mprod, t, numnodes;

  v = 상태공간트리의 뿌리;
  numnodes = 1;
  m = 1;
  mprod = 1;

  while(m != 0) {
    t = v의 자식마디의 개수;
    mprod = mprod * m;
    numnodes = numnodes + mprod * t;
    m = v의 유말한 자식마디의 개수;
    if(m != 0)
      v = v의 무작위로 선택한 자식마디의 개수;
  }

  return numnodes;
}
```

&ensp;다음 알고리즘은 The n-Queens problem에 대한 몬테칼로 추정치를 구하는 알고리즘이다.
```cpp
// 문제: The n-Queens problem의 효율 추정
// 입력: 양의 정수 n
// 출력: The n-Queens problem이 만들어 내는 가지친 상태공간트리에서 마디의 개수 추정치.
// 두 여왕말이 서로 위협하지 않도록 체스판에 n개의 여왕말을 놓는 방법을 모두 찾기 전에 알고리즘이 검사하는 마디의 개수가 됨
int estimate_n_queens (int n) {
  index i, j, col[1 .. n];
  int m, mprod, numnodes;
  set_of_index prom_children;

  i = 0;
  numnodes = 1;
  m = 1;
  mprod = 1;

  while(m != 0 && i != n) {
    mprod = mprod * m;
    numnodes = numnodes + mprod * n;
    i++;
    m = 0;
    prom_children = ∅;

    for(j = 1; j <= n; j++) {
      col[i] = j;
      if(promising(i)) {
        m++;
        prom_children = prom_children ⋃ {j};
      }
    }

    if(m != 0) {
      j = prom_children에서 무작위로 선택;
      col[i] = j;
    }
  }

  return numnodes;
}
```

&ensp;몬테칼로 알고리즘을 사용할 때 두 번 이상 실행하여 추정치를 구해야 하고, 그 결과의 평균을 실제 추정치로 사용해야 한다. 통계학에서 표준으로 쓰이는 방법을 사용하면 시도한 결과로 검사한 마디의 실제 개수에 대한 신뢰구간을 결정할 수 있다. 경험으로 보면 20번 정도 시도하면 보통 충분하다. 몬테칼로 알고리즘을 여러 번 실행시키면 좋은 추정치를 구할 확률이 높아지지만, 결과가 항상 좋은 추정치라는 보장은 결코 없다는 걸 주의해야 한다.

The Sum-of-Subsets Problem
======
&ensp;부분집합의 합 구하기 문제에서는 양의 정수(무게) $w_i$가 $n$개, 양의 정수 $W$가 있다. 목표는 합이 $W$가 되는 정수의 부분집합을 모두 찾는 것이다. 다음 예를 보자.<br/>
<p align="center"><img src="/assets/img/Algorithms&Analysis/5장 되추적/4-1-Sum-of-Subsets-Problem-ex-1.png" width="700"></p>

&ensp;큰 $n$ 값에 대해서 체계적인 접근 방법이 필요하다. 상태공간트리를 만들어 푸는 방법이 하나 있다. 검색하기 전에 증가하는 순으로 가중치를 정렬한다면, 마디가 유망하지 않음을 분명하게 알려주는 표시가 존재한다. 가중치가 이렇게 정렬되어 있으면 $w_{i + 1}$은 $i$수준에서 남아있는 가장 가벼운 무게가 된다. **weight**를 수준 $i$의 마디까지 포함된 무게의 합이라 하면, $w_{i+1}$이 weight의 값을 $W$를 넘기게 한다면, 그 이후에 어떤 다른 무게도 $W$를 넘길 것이다. 따라서 weight가 $W$와 같지 않으면, $weight + w_{i+1} > W$,수준 $i$의 마디는 유망하지 않다.<br/>
&ensp;어떤 주어진 마디에서 남아있는 아이템의 무게의 총 합에다 weight를 더해서도 최소한 $W$와 같아지지도 않으면, 그 마디 이후로 아무리 확장하더라고 $W$와 같아질 수 없다. 이는 **total**이 남은 아이템의 총 무게일 때, $weight + total < W$를 만족하면 이 마디는 유망하지 않음을 의미한다. 다음 예를 보자.<br/>
<p align="center"><img src="/assets/img/Algorithms&Analysis/5장 되추적/4-2-Sum-of-Subsets-Problem-ex-2.png" width="700"></p>

* 12, 8, 9를 포함하는 마디들은 다음 무게(6)을 추가하면 weight의 값이 W를 초과하기 때문에 유망하지 않다.
* 7, 3, 4, 0을 포함하는 마디들은 남은 무게의 총합이 weight의 값을 W까지 올리기에 충분하지 않기 때문에 유망하지 않다.
* 해답을 포함하지 않은 상태공간트리에서 leaf는 자동적으로 유망하지 않다.

&ensp;이제 알고리즘을 살펴보자.
```cpp
void sum_of_subsets (index i, int weight, int total) {
  if(promising(i)){
    if(weight == W)
      cout << include[1] through include[i];
    else {
      include[i + 1] = "yes";
      sum_of_subsets(i + 1, weight + w[i + 1], total - w[i + 1]);
      include[i + 1] = "no";
      sum_of_subsets(i + 1, weight, total - w[i + 1]);
    }
  }
}

bool promising(index i) {
  return (weight + total >= W) && (weight == W || weight + w[i + 1] <= W); 
}
```

Graph Coloring
======

```cpp
void m_coloring (index i) {
  index color;

  if(promising(i)){
    if(i == n)
      cout << vcolor[1] through vcolor[n];
    else {
      for(color = 1; color <= m; color++) {
        vcolor[i + 1] = color;
        m_coloring(i + 1);
      }
    }
  }
}

bool promising (index i) {
  index j;
  bool switch;

  switch = true;
  j = 1;
  while(j < i && switch) {
    if(W[i][j] && vcolor[i] == vcolor[j])
      switch = false;
    j++;
  }

  return switch;
}
```

The Hamiltonian Circuits Problem
======

```cpp
void hamiltonian (index i) {
  index j;

  if(promising(i)) {
    if(i == n - 1)
      cout<< vindex[0] through vindex[n - 1];
    else {
      for(j = 2; j <= n; j++){
        vindex[i + 1] = j;
        hamiltonian(i + 1);
      }
    }
  }
}

bool promising (index i) {
  index j;
  bool switch;

  if(i == n - 1 && !W[vindex[n - 1]][vindex[0]])
    switch = false;
  else if (i > 0 && !W[vindex[i - 1]][vindex[i]])
    switch = false;
  else {
    switch = true;
    while(j < i && switch) {
      if(vindex[i] == vindex[j])
        switch = false;
      j++;
    }
  }

  return switch;
}
```

The 0/1 Knapsack Problem
======