---
title: "3장 연산자"
excerpt: "연산자"

wirter: Myeongwoo Yoon
categories:
  - 이것이 자바다
tags:
  - java

use_math: true
toc: true
toc_sticky: true
 
date: 2025-04-12
last_modified_at: 2025-04-12
---

부호 / 증감 연산자
======

&ensp;부호 연산자는 변수의 부호를 유지하거나 변경한다.
* +: 피연산자의 부호 유지
* -: 피연산자의 부호 변경

&ensp;이때 주의할 점은 부호 변경 후의 타입이다.
```java
byte b = 100;
byte result1 = -b; // 컴파일 에러
int result2 = -b; 
```

* 정수 타입의 연산의 결과는 int 타입이므로 부호 변경 연산도 int 타입 변수에 대입헤야 한다.

&ensp;증감 연산자는 변수의 값을 1 증가(++)시키거나 1 감소(--)시키는 연산자이다.

산술 연산자
======

&ensp;산술 연산자는 더하기(+), 빼기(-), 곱하기(*), 나누기(/), 나머지(%)로 총 5개이다. 산술 연산의 특징은 다음과 같다.
* 피연산자가 정수 타입이면 연산의 결과는 int이다.
* 피연산자가 정수 타입이고, 그 중 하나가 long 타입이면 연산의 결과는 long 타입이다.
* 피연산자 중 하나가 실수 타입이면 연산의 결과는 실수 타입이다.

오버플로우와 언더플로우
======

* 오버플로우(overflow): 타입이 허용하는 최대값을 벗어나는 것
* 언더플로우(underflow): 타입이 허용하는 최소값을 벗어나는 것

&ensp;정수 타입 연산에서 오버플로우 또는 언더플로우가 발생하면 정수 타입의 최소값 또는 최대값으로 되돌아간다. 연산 과정 중에 발생하는 오버플로우와 언더플로우는 기대하는 값이 아니므로 항상 해당 타입의 범위 내에서 연산이 수행되도록 신경써야 한다.

정확한 계산은 정수 연산으로
======

&ensp;산술 연산을 정확하게 계산하고 싶으면 실수 타입을 사용하지 않는 것이 좋다. 실수 타입에서는 부동 소수점 방식을 사용하기 때문에 정확한 계산이 필요하다면 정수 연산으로 변경해서 계산하는 것이 좋다.

나눗셈 연산 후 NaN과 Infinity 처리
======

&ensp;나눗셈 또는 나머지 연산에서 좌측 피연산자가 정수이고 우측 피연산자가 0일 경우 예외(ArithmeticException)가 발생한다. 무한대의 값을 정수로 표현할 수 없기 때문이다. 그렇기 때문에 좌측 피연산자가 실수이거나 우측 피연산자가 0.0 또는 0.0f 이면 예외가 발생하지 않고 연산의 결과는 Infinity 또는 NaN(Not a Number)이 된다.
* Infinity 또는 NaN 상태에서 계속해서 연산을 수행하면 데이터가 엉망이 될 수 있으므로 추가적인 연산을 해서는 안된다.
* 이를 확인하기 위해서 Double.isInfinite()와 Double.inNaN()를 사용한다.
  - true 또는 false를 산출
```java
boolean result = Double.isInfinite(변수);
boolean result = Double.isNaN(변수);
```

비교 연산자
======

&ensp;비교 연산자는 동등(==, !=) 또는 크기(<, <=, >, >=)를 평가해서 boolean 타입인 true/false를 산출한다.<br/>
&ensp;피연산자의 타입이 다를 경우에는 비교 연산을 수행하기 전에 타입을 일치시킨다.
```java
'A' == 65 // true
3 == 3.0  // true
```

&ensp;한 가지 예외는 다음과 같다.
```java
0.1f == 0.1 // false
```

* 0.1f가 double 타입으로 변환되면 0.1이 되어야 하지만, 부동 소수점 방식을 사용하는 실수 타입은 0.1을 정확히 표현할 수 없기 때문에 false를 출력한다. 그러므로 **0.1f == (float) 0.1** 으로 해주면 true가 출력된다.

&ensp;문자열을 비교할 때는 equals()와 !equals()를 사용한다.

논리 연산자
======

&ensp;논리 연산자는 논리곱(&&), 논리합(||), 배타적 논리합(^, XOR) 그리고 논리 부정(!) 연산을 수행한다. 

비트 연산자
======

비트 논리 연산자
------

&ensp;비트 논리 연산자는 bit 단위로 논리 연산(&&, ||, ^, !)을 수행한다. 0과 1이 피연산자가 되므로 2진수 0과 1로 저장되는 정수 타입만 피연산자가 될 수 있고, 부동 소수점 방식으로 저장되는 실수 타입(float, double)은 피연산자가 될 수 없다.<br/>
&ensp;비트 논리 연산자는 byte, short, char 타입 피연산자를 int 타입으로 자동 변환한 후 연산을 수행한다. 따라서 연산 결과도 int 타입이 되므로 int 변수에 대입해야 한다.
```java
byte num1 = 45;
byte num2 = 25;
byte result1 = num1 & num2; // 컴파일 에러
int result = num1 & num2;
```

비트 이동 연산자
------

&ensp;비트 이동 연산자는 비트를 좌측 또는 우측으로 밀어서 이동시키는 연산을 수행한다.
* a << b
  - 정수 a의 각 비트를 b만큼 왼쪽으로 이동
  - 오른쪽 빈자리를 0으로 채움
* a >> b
  - 정수 a의 각 비트를 b만큼 오른쪽으로 이동
  - 왼쪽 빈자리는 최상위 부호 비트와 같은 값으로 채움
* a >>> b
  - 정수 a의 각 비트를 b만큼 오른쪽으로 이동
  - 왼쪽 빈자리는 0으로 채움움

대입 연산자
======

&ensp;대입 연산자는 우측 피연산자의 값을 좌측 피연산자인 변수에 대입한다.
* 단순 대입 연산자: =
* 복합 대입 연산자: +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=, >>>=

삼항(조건) 연산자
======

&ensp;삼항 연산자(피연산자1 ? 피연산자2(1이 true) : 피연산자3(1이 false))는 총 3개의 피연산자를 가진다. ?앞의 피연산자에는 boolean 변수 또는 조건식이 오므로 조건 연산자라고도 한다.

연산의 방향과 우선순위
======

&ensp;다음은 연산자의 우선순위이다.
1. 단항 연산자
2. 산술 연산자
3. 시프트 연산자
4. 관계 연산자
5. 비트 연산자
6. 논리 연산자
7. 조건 연산자
8. 대입 연산자
9. 순서 연산자