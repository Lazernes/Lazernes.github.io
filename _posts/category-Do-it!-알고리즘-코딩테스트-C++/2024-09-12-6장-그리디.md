---
title: "6장 그리디"
excerpt: "그리디 알고리즘은 현재 상태에서 볼 수 있는 선택지 중에 최선의 선택을 하는 알고리즘이다. 그리디 알고리즘은 동적 계획법보다 구현하기 쉽고 시간 복잡도가 우수하다. 하지만 항상 최적의 해는 보장하지 못해, 코딩 테스트에서 논리 유무를 충분히 살펴야 한다."

wirter: Myeongwoo Yoon
categories:
  - Do it! 알고리즘 코딩테스트 C++
tags:
  - Algorithm
  - java

use_math: true
toc: true
toc_sticky: true
 
date: 2024-09-12
last_modified_at: 2024-09-12
---

그리디 알고리즘
======

&ensp;**그리디(Greedy)**알고리즘은 현재 상태에서 보는 선택지 중 최선의 선택지가 전체 선택지 중 최선의 선택지라고 가정하는 알고리즘이다.

그리디 알고리즘의 핵심 이론
------
&ensp;그리디 알고리즘은 다음과 같은 3가지 단계를 반복하면서 문제를 해결한다.
1. 해 선택: 현재 상태에서 가장 최선이라고 생각되는 해를 선택한다.
2. 적절성 검사: 현재 선택한 해가 전체 문제의 제약 조건에 벗어나지 않는지 검사한다.
3. 해 검사: 현재까지 선택한 해 집합이 전체 문제를 해결할 수 있는지 검사한다. 전체 문제를 해결하지 목한다면 1로 돌아가 같은 과정을 반복한다.


문제 032 동전 개수의 최솟값 구하기
------
`시간 제한: 1초, 난이도: 실버4, 11047번`
<p align="center"><img src="/assets/img/Do-it!-알고리즘-코딩테스트-C++/6장 그리디/1-1-032-11047-문제.png"></p>

```java
import java.io.*;
import java.util.StringTokenizer;

public class Main {

    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        StringTokenizer st = new StringTokenizer(bf.readLine());
        int N = Integer.parseInt(st.nextToken());
        int K = Integer.parseInt(st.nextToken());

        int[] coin = new int[N];
        for (int i = 0; i < N; i++) {
            coin[i] = Integer.parseInt(bf.readLine());
        }

        int result = 0;

        for (int i = N - 1; i >= 0; i--) {
            if (coin[i] <= K) {
                result += (K / coin[i]);
                K = K % coin[i];
            }
        }

        bw.write(result + "\n");
        bw.flush();
        bw.close();
    }
}
```

&ensp;동전을 최소로 사용하기 위하여 coin 배열을 역순서 대로, 즉 큰 동전 부터 순서대로 동전을 사용하였다.
