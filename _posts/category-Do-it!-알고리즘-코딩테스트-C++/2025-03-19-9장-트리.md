---
title: "9장 트리"
excerpt: "트리의 기본적인 구조, 용어 특성 등에 관해 알아본다. 특히 이진 트리와 세그먼트 트리의 개념과 구현 방법을 알아본다."

wirter: Myeongwoo Yoon
categories:
  - Do it! 알고리즘 코딩테스트
tags:
  - Algorithm
  - java

use_math: true
toc: true
toc_sticky: true
 
date: 2025-03-19
last_modified_at: 2024-03-19
---

트리 알아보기
======

&ensp;**트리(tree)**는 노드와 에지로 연결된 그래프의 특수한 형태로, 주요 특징은 다음과 같다.
* **순환 구조(cycle)**를 지니고 있지 않고, 1개의 루트 노드가 존재한다.
* 루트 노드를 제외한 노드는 단 1개의 부모 노드를 갖는다.
* 트리의 **부분 트리(subtree)** 역시 트리의 모든 특징을 따른다.

트리의 핵심 이론
------

<p align="center"><img src="/assets/img/Do-it!-알고리즘-코딩테스트-C++/9장 트리/1-1-트리의 구성 요소.JPEG" width="500"></p>

* **노드**: 데이터의 index와 value를 표현하는 요소
* **에지**: 노드와 노드의 연결 관계를나타내는 선
* **루트 노드**: 트리에서 가장 상위에 존재하는 노드
* **부모 노드**: 두 노드 사이의 관계에서 상위 노드에 해당하는 노드
* **자식 노드**: 두 노드 사이의 관계에서 하위 노드에 해당하는 노드
* **리프 노드**: 트리에서 가장 하위에 존재하는 노드(자식 노드가 없는 노드)
* **서브 트리**: 전체 트리에 속한 작은 트리

문제 067 트리의 부모 찾기
------
`시간 제한: 1초, 난이도: 실버2, 11725번`
<p align="center"><img src="/assets/img/Do-it!-알고리즘-코딩테스트-C++/9장 트리/1-2-067-11725-문제.png"></p>

```java
import java.io.*;
import java.util.ArrayList;
import java.util.StringTokenizer;

public class Main {

    public static ArrayList<ArrayList<Integer>> Tree;

    public static boolean Visit[];
    public static int parent[];

    public static void DFS(int a) {
        if (Visit[a]) {
            return;
        }

        Visit[a] = true;
        for (int i = 0; i < Tree.get(a).size(); i++) {
            int next = Tree.get(a).get(i);

            if (!Visit[next]) {
                parent[next] = a;
                DFS(next);
            }
        }
    }

    public static void main(String[] args) throws IOException {

        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        Tree = new ArrayList<>();

        int N = Integer.parseInt(bf.readLine());

        for (int i = 0; i <= N; i++) {
            Tree.add(new ArrayList<>());
        }

        Visit = new boolean[N + 1];
        parent = new int[N + 1];

        for (int i = 1; i < N; i++) {
            StringTokenizer st = new StringTokenizer(bf.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());

            Tree.get(a).add(b);
            Tree.get(b).add(a);
        }

        DFS(1);

        for (int i = 2; i < N + 1; i++) {
            bw.write(parent[i] + "\n");
        }

        bw.flush();
        bw.close();
    }
}
```

문제 068 리프 노드의 개수 구하기
------
`시간 제한: 2초, 난이도: 골드5, 1068번`
<p align="center"><img src="/assets/img/Do-it!-알고리즘-코딩테스트-C++/9장 트리/1-3-068-1068-문제.png"></p>

```java
import java.io.*;
import java.util.ArrayList;
import java.util.StringTokenizer;

public class Main {

    public static ArrayList<ArrayList<Integer>> Tree;
    public static boolean[] Visit;
    public static int count = 0;

    public static void DFS(int a) {

        if (Tree.get(a).size() == 0) {
            count++;
        }

        for (int i = 0; i < Tree.get(a).size(); i++) {
            int nextNode = Tree.get(a).get(i);
            if (!Visit[nextNode]) {
                Visit[nextNode] = true;
                DFS(nextNode);
            }
        }
    }


    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int N = Integer.parseInt(bf.readLine());
        Visit = new boolean[N];
        Tree = new ArrayList<>();
        for (int i = 0; i < N; i++) {
            Tree.add(new ArrayList<>());
        }

        StringTokenizer st = new StringTokenizer(bf.readLine());
        int root = 0;

        for (int i = 0; i < N; i++) {
            int parent = Integer.parseInt(st.nextToken());

            if (parent != -1) {
                Tree.get(parent).add(i);
            } else {
                root = i;
            }
        }

        int del = Integer.parseInt(bf.readLine());
        if (del == root) {
            for (int i = 0; i < Tree.get(root).size(); i++) {
                Tree.get(root).remove(i);
            }

            bw.write(0 + "\n");

        } else {
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < Tree.get(i).size(); j++) {
                    if (Tree.get(i).get(j) == del) {
                        Tree.get(i).remove(j);
                    }
                }
            }

            DFS(root);

            bw.write(count + "\n");
        }

        bw.flush();
        bw.close();
    }
}
```

트라이
======

&ensp;**트라이(trie)**는 문자열 검색을 빠르게 실행할 수 있도록 설계한 트라 형태의 자료구조이다.

트라이의 핵심 이론
------

&ensp;트라이는 일반적으로 단어들을 사전의 형태로 생성한 후 트리의 부모 자식 노드 관계를 이용해 검색을 수행한다. 트라이 자료구조의 특징은 다음과 같다.
* N진 트리: 문자 종류의 개수에 따라 N이 결정된다. 예를 들어 알파벳은 26개의 문자로 이뤄져 있으므로 26진 트리로 구성된다.
* 루트 노드는 항상 빈 문자열을 뜩하는 공백 상태를 유지한다.

&ensp;다음은 영단어 apple, air, apply를 순서대로 트라이 자료구조에 삽입하는 모습니다.<br/>
<p align="center"><img src="/assets/img/Do-it!-알고리즘-코딩테스트-C++/9장 트리/2-1-트라이 자료구조"></p>

* 먼저 루트 노드는 공백을 유지하고 apply의 각 알파벳에 해당하는 노드를 생성한다.
* 그다음으로 air를 삽입할 때는 루트 노드에서부터 검색한다. a노드는 공백상태가 아니므로 이동하고, i와 r은 공백 상태이므로 신규 노드를 생성한다.
* apply를 삽입할 때도 검색 노드가 공백 상태이면 신규 노드를 생성하고, 아니면 이동하는 원리로 트라이 자료구조를 구현한다.

문제 069 문자열 찾기
------
`시간 제한: 2초, 난이도: 실버4, 14425번`
<p align="center"><img src="/assets/img/Do-it!-알고리즘-코딩테스트-C++/9장 트리/2-2-069-14425-문제.png"></p>

```java
import java.io.*;
import java.util.StringTokenizer;

public class Main {

    public static Node root;

    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        StringTokenizer st = new StringTokenizer(bf.readLine());
        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());

        root = new Node();

        while (N > 0) {
            String text = bf.readLine();
            Node now = root;

            for (int i = 0; i < text.length(); i++) {
                char a = text.charAt(i);

                // 입력은 소문자로만 이루어져 있고 index를 나타내기 위해 'a'를 뺌
                if (now.next[a - 'a'] == null) {
                    now.next[a - 'a'] = new Node();
                }
                now = now.next[a - 'a'];
                if (i == text.length() - 1) {
                    now.isEnd = true;
                }
            }

            N--;
        }

        int count = 0;
        while (M > 0) {
            String text = bf.readLine();
            Node now = root;
            for (int i = 0; i < text.length(); i++) {
                char a = text.charAt(i);
                if (now.next[a - 'a'] == null) {
                    break;
                }   // now의 next가 존재하지 않으면 break

                now = now.next[a - 'a'];
                if (i == text.length() - 1 && now.isEnd) {
                    count++;
                }
            }
            M--;
        }

        bw.write(count + "\n");
        bw.flush();
        bw.close();
    }

    public static class Node {
        Node[] next = new Node[26];    // 알파벳 26개
        boolean isEnd;  // 문자열의 마지막인지 표시
    }
}
```

&ensp;트라이 자료구조를 활용하기 위해서는 26진 트리를 만들어야 하기 때문에 크기가 26인 Node를 만들어 주고 문자열의 마지막에 도달하면 리프 노드라고 표시해야한다. 또한 now노드를 유지하기 위해 for문을 사용하지 않고 while문을 사용해 반복문을 진행한다.

이진 트리
======

세그먼트 트리
======

최소 공통 조상
======
