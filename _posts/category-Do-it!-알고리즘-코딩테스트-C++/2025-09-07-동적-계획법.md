---
title: "11장 동적 계획법"
excerpt: "동적 계획법은 가장 광범위한 여러 유형의 문제를 논리적인 사고를 이용해 효율적으로 풀 수 있는 알고리즘이다."

wirter: Myeongwoo Yoon
categories:
  - Do it! 알고리즘 코딩테스트
tags:
  - Algorithm
  - java

use_math: true
toc: true
toc_sticky: true
 
date: 2025-09-07
last_modified_at: 2025-09-07
---

&ensp;**동적 계획법(Dynamic Programming)**은 복잡한 문제를 여러 개의 간단한 문제로 분리하여 부분의 문제들을 해결함으로써 최종적으로 복잡한 문제의 답을 구하는 방법을 뜻한다.

동적 계획법의 핵심 이론
======

&ensp;동적 계획법의 원리와 구현 방식은 다음과 같다.
1. 큰 문제를 작은 문제로 나눌 수 있어야 한다.
2. 작은 문제들이 반복돼 나타나고 사용되며 이 작은 문제들의 결괏값은 항상 같아야 한다.
3. 모든 작은 문제들은 한 번만 계산해 DP 테이블에 저장하여 추후 재사용할 때는 이 DP 테이블을 이용한다(메모이제이션 기법, memoization).
4. 동적 계획법은 톱-다운 방식(top-down)과 바텀-업 방식(bottom-up)으로 구현할 수 있다.

&ensp;먼저 **동적 계획법으로 풀 수 있는지 확인**해야 한다. 피보나치 수열을 예로 들면, 6버째 피보나치 수열은 5번째 피보나치 수열과 4번째 피보나치 수열의 합이다. 즉, 6번째 피보나치 수열을 구하는 문제는 5번째 피보나치 수열과 4번째 피보나치 수열을 구하는 작은 문제로 나눌 수 있고, 수열의 값은 항상 같기 때문에 동적 계획법으로 풀 수 있다.<br/>
&ensp;다음으로 **점화식**을 세워야 한다. 점화식을 세울 때는 논리적으로 전체 문제를 나누고, 전체 문제와 부분 문제 간의 인과 관계를 파악해야 한다.<br/>
&ensp;**메모이제이션**은 부분 문제를 풀었을 때 이 문제를 DP 테이블에 저장해 놓고 다음에 같은 문제가 나왔을 때 재계산하지 않고 DP 테이블의 값을 이용하는 것을 말한다. 이러한 방식을 사용하면 불필요한 연산과 탐색이 줄어들어 시간 복잡도 측면에서 많은 이점을 가질 수 있다.<br/>
&ensp;**톱-다운 방식**웨어서 부터 문제를 파악해 내려오는 방식으로, 주로 재귀 함수 형태로 코드를 구현한다. 코드의 가독성이 좋고, 이해하기 편하다는 장점이 있다.
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

    public static int[] D;
    public static int fib(int n) {
        // 기존에 계산한 적이 있는 부분 문제는 다시 계산하지 않고 반환
        if (D[n] != -1) {
            return D[n];
        }

        // 메모이제이션: 구현 값을 바로 반환하지 않고 테이블에 저장 후 반환하도록 구현
        return D[n] = fib(n - 2) + fib(n - 1);
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(bf.readLine());
        D = new int[N];
        for (int i = 0; i <= N; i++) {
            D[i] = -1;
        }

        D[0] = 0;
        D[1] = 1;
        fib(N);
        System.out.println(D[N]);
    }
}
```

&ensp;**바텀-업 방식**은 가장 작은 부분 문제부터 문제를 해결하면서 점점 큰 문제로 확장해 나가는 방식이다. 주로 반복문의 형태로 구현한다.
```java
import java.io.BufferedReader;
import java.io.IOException;

public class Main {

    public static int[] D;

    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(bf.readLine());
        D = new int[N];
        for (int i = 0; i <= N; i++) {
            D[i] = -1;
        }

        D[0] = 0;
        D[1] = 1;
        for (int i = 2; i <= N; i++) {
            D[i] = D[i - 1] + D[i - 2];
        }
        System.out.println(D[N]);
    }
}
```

&ensp;두 방식 중 좀 더 안전한 방식은 **바텀-업**이다. 톱-다운 방식은 재귀 함수의 형태로 구현돼있기 때문에 재귀의 깊이가 매우 깊어질 경우 런타임 에러가 방생할 수 있다.

문제 084 정수를 1로 만들기
======
`시간 제한: 0.15초, 난이도: 실버3, 1463번`
<p align="center"><img src="/assets/img/Do-it!-알고리즘-코딩테스트-C++/11장 동적 계획법/1-1-084-1463-문제.png"></p>

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(bf.readLine());
        int[] D = new int[N + 1];
        D[1] = 0;

        for (int i = 2; i <= N; i++) {
            D[i] = D[i - 1] + 1;    // 1을 뺀다.
            if (i % 2 == 0) {
                D[i] = Math.min(D[i], D[i / 2] + 1);
            }
            if (i % 3 == 0) {
                D[i] = Math.min(D[i], D[i / 3] + 1);
            }
        }
        System.out.println(D[N]);
    }
}
```

문제 085 퇴사 준비하기
======
`시간 제한: 2초, 난이도: 실버3, 14501번`
<p align="center"><img src="/assets/img/Do-it!-알고리즘-코딩테스트-C++/11장 동적 계획법/1-2-085-14501-문제.png"></p>

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class P085 {

    public static int[] T;
    public static int[] P;
    public static int[] D;

    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(bf.readLine());
        T = new int[16];
        P = new int[16];
        D = new int[17];

        for (int i = 1; i < N + 1; i++) {
            StringTokenizer st = new StringTokenizer(bf.readLine());
            T[i] = Integer.parseInt(st.nextToken());
            P[i] = Integer.parseInt(st.nextToken());
        }

        for (int i = N; i > 0; i--) {
            if (i + T[i] > N + 1) {
                D[i] = D[i + 1];
            } else {
                D[i] = Math.max(D[i + 1], P[i] + D[i + T[i]]);
            }
        }
        System.out.println(D[1]);
    }
}
```

&ensp;i=N 부터 시작해서 Top-Down 방식으로 접근했다. i가 감소할 때, 현재 날짜에 상담한 후 벌 수 있는 가격과 다음날 부터 상담해서 벌 수 있는 금액을 비교한 후 그 중에 최대값을 저장한다. 만약 i + T[i] 가 N + 1 보다 크면 상담을 할 수 없으므로 이때는 전 날의 정보를 저장한다.

문제 086 이친수 구하기
======
`시간 제한: 2초, 난이도: 실버3, 2193번`
<p align="center"><img src="/assets/img/Do-it!-알고리즘-코딩테스트-C++/11장 동적 계획법/1-3-086-2193-문제.png"></p>

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

    public static long[][] D;

    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(bf.readLine());

        D = new long[N + 1][2];
        D[1][0] = 0;
        D[1][1] = 1;

        for (int i = 2; i < N + 1; i++) {
            D[i][0] = D[i - 1][1] + D[i - 1][0];
            D[i][1] = D[i - 1][0];
        }
        
        System.out.println(D[N][1] + D[N][0]);
    }
}
```

&ensp;배열 D[i][0]은 i길이에서 끝이 0으로 끝나는 이친수의 개수, D[i][1]은 i길이에서 끝이 1로 끝나는 이친수의 개수이다. 이때, 1은 연속해서 올 수 없으므로 D[i + 1][0]은 D[i][0]과 D[i][1]의 합과 같고, D[i + 1][1]은 D[i][0]의 값과 같다.

문제 087 2*N 타일 채우기
======
`시간 제한: 1초, 난이도: 실버3, 11726번`
<p align="center"><img src="/assets/img/Do-it!-알고리즘-코딩테스트-C++/11장 동적 계획법/1-4-087-11726-문제.png"></p>

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(bf.readLine());
        long[] D = new long[1001];

        D[1] = 1;
        D[2] = 2;
        for (int i = 3; i <= N; i++) {
            D[i] = (D[i - 1] + D[i - 2]) % 10007;
        }

        System.out.println(D[N]);
    }
}
```

&ensp;i번째 타일을 채우는 경우의 수는 i - 1번째 타일에서 1 X 2 타일을 넣으면 되고, 1 - 2번째 타일에서 2 x 1 타일 2개를 넣으면 되기 때문에, D[i] = D[i - 1] + D[i - 2]와 같다.

문제 088 계단 수 구하기
======
`시간 제한: 1초, 난이도: 실버1, 10844번`
<p align="center"><img src="/assets/img/Do-it!-알고리즘-코딩테스트-C++/11장 동적 계획법/1-5-088-10844-문제.png"></p>

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(bf.readLine());
        long[][] D = new long[101][11];
        for (int i = 1; i < 11; i++) {
            D[1][i] = 1;
        }

        for (int i = 2; i < N + 1; i++) {
            D[i][0] = D[i - 1][1];
            D[i][9] = D[i - 1][8];

            for (int j = 1; j < 9; j++) {
                D[i][j] = (D[i - 1][j - 1] + D[i - 1][j + 1]) % 1000000000;
            }
        }

        long sum = 0;
        for (int i = 0; i < 10; i++) {
            sum = (sum + D[N][i]) % 1000000000;
        }
        System.out.println(sum);
    }
}
```

&ensp;배열 D[N][H] 를 길이가 N인 숫자에서 끝이 H인 숫자의 경우의 수를 의미한다. 그래서 H = 0 이면 D[i][H] = D[i - 1][1] 과 같고, H = 9이면 D[i][H] = D[i - 1][8] 과 같다. 나머지 경우에서는 D[i][H] = D[i - 1][H - 1] + D[i - 1][H + 1] 과 같으므로 위와 같은 반복문을 통해 구현했다.

문제 089 연속된 정수의 합 구하기
======
`시간 제한: 2초, 난이도: 골드5, 13398번`
<p align="center"><img src="/assets/img/Do-it!-알고리즘-코딩테스트-C++/11장 동적 계획법/1-6-089-13398-문제.png"></p>

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(bf.readLine());

        int[] A = new int[N];
        StringTokenizer st = new StringTokenizer(bf.readLine());

        for (int i = 0; i < N; i++) {
            A[i] = Integer.parseInt(st.nextToken());
        }

        int[] L = new int[N];
        int[] R = new int[N];

        L[0] = A[0];
        int max = A[0];

        for (int i = 1; i < N; i++) {
            L[i] = Math.max(L[i - 1] + A[i], A[i]);
            // 하나도 제거하지 않았을 때를 기본 최대값으로 저장
            max = Math.max(max, L[i]);
        }

        R[N - 1] = A[N - 1];

        for (int i = N - 2; i >= 0; i--) {
            R[i] = Math.max(A[i], R[i + 1] + A[i]);
        }

        // L[i - 1] + R[i + 1] 두 개의 구간 합 배열을 더해주면 i 번째 값을 제거한 효과
        for (int i = 1; i < N - 1; i++) {
            int temp = L[i - 1] + R[i + 1];
            max = Math.max(max, temp);
        }

        System.out.println(max);
    }
}
```

&ensp;배열 A에 입력된 값들을 저장하고, 배열 L은 왼쪽부터 더해서 최대값일 때를 저장하고, R은 오른쪽 부터 더해서 최대값일 때를 저장한다. 그리고 마지막으로 i 번째 원소를 제외했을 때 합을 구해서 그것과 전의 최대값을 비교해 제외했을 때와 제외하지 않았을 때의 최대값을 비교해 결과를 출력한다.

문제 090 최장 공통부분 수열 찾기
======
`시간 제한: 1초, 난이도: 골드5, 9252번`
<p align="center"><img src="/assets/img/Do-it!-알고리즘-코딩테스트-C++/11장 동적 계획법/1-7-090-9252-문제.png"></p>

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Stack;

public class Main {

    public static String A;
    public static String B;

    public static int[][] D;
    public static Stack<Character> LCS = new Stack<>();
    public static int maxLen;

    public static void LCS(int a, int b) {
        if (a == 0 || b == 0) {
            return;
        }

        if (A.charAt(a - 1) == B.charAt(b - 1)) {
            LCS.push(A.charAt(a - 1));
            LCS(a - 1, b - 1);
        } else {
            if (D[a - 1][b] > D[a][b - 1]) {
                LCS(a - 1, b);
            } else {
                LCS(a, b - 1);
            }
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        A = bf.readLine();
        B = bf.readLine();

        D = new int[A.length() + 1][B.length() + 1];

        for (int i = 1; i < A.length() + 1; i++) {
            for (int j = 1; j < B.length() + 1; j++) {
                if (A.charAt(i - 1) == B.charAt(j - 1)) {
                    D[i][j] = D[i - 1][j - 1] + 1;
                } else {
                    D[i][j] = Math.max(D[i - 1][j], D[i][j - 1]);
                }
            }
        }

        maxLen = D[A.length()][B.length()];
        System.out.println(maxLen);

        if (maxLen != 0) {
            LCS(A.length(), B.length());
            int iter = LCS.size();
            for (int i = 0; i < iter; i++) {
                System.out.print(LCS.pop());
            }
        }

    }
}
```

&ensp;먼저 DP에 필요한 배열을 2차원 배열로 만든 다음에 입력된 두 문자열의 각 자리수가 같으면 최장 공통 부분에 들어가므로 D[i][j] = D[i - 1][j - 1] + 1 (대각선 방향)을 해준다. 같지 않으면 D[i - 1][j]와 D[i][j - 1] 중에 큰 값을 가져온다. 그러면 D[A.length() + 1][B.length() + 1]에는 최장 공통 부분의 길이가 들어가게 된다.<br/>
&ensp;이제 D[A.lenhth() + 1][B.length() + 1] 부터 A와 B의 각 자리수가 같으면 대각선 방향으로, 같지 않으면 왼쪽 또는 위쪽 중 큰 방향으로 이동하면서 LCS 함수를 호출한다. 이때 스택에 같은 문자를 넣고 마지막에 스택에 들어있는 모든 문자들을 출력한다.

문제 091 가장 큰 정사각형 찾기
======
`시간 제한: 1초, 난이도: 골드4, 1915번`
<p align="center"><img src="/assets/img/Do-it!-알고리즘-코딩테스트-C++/11장 동적 계획법/1-8-091-1915-문제.png"></p>

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {

    public static int N;
    public static int M;

    public static int[][] D;

    public static int Min(int a, int b, int c) {
        int min = Math.min(a, b);
        min = Math.min(min, c);

        return min;
    }


    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(bf.readLine());

        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        D = new int[N][M];
        int max = 0;

        for (int i = 0; i < N; i++) {
            String input = bf.readLine();

            for (int j = 0; j < M; j++) {
                D[i][j] = input.charAt(j) - '0';
                
                if (D[i][j] == 1) {
                    max = 1;
                }
            }
        }

        for (int i = 1; i < N; i++) {
            for (int j = 1; j < M; j++) {
                if (D[i][j] == 1) {
                    D[i][j] = Min(D[i - 1][j - 1], D[i - 1][j], D[i][j - 1]) + 1;
                }

                if (max < D[i][j]) {
                    max = D[i][j];
                }
            }
        }

        System.out.println(max * max);
    }
}
```

&ensp;배열 D[i][j]를 오른쪽 아래 꼭짓점이 [i][j]인 사각형에서 만들 수 있는 정사각형의 최대 길이로 정의하고 이를 이용해 DP로 풀었다.

문제 092 빌딩 순서 구하기
======
`시간 제한: 2초, 난이도: 플래티넘5, 1328번`
<p align="center"><img src="/assets/img/Do-it!-알고리즘-코딩테스트-C++/11장 동적 계획법/1-9-092-1328-문제.png"></p>

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {

    // D[N][L][R]: N개의 빌딩이 있고 왼쪽에 L개, 오른쪽에서 R개가 보일 때 가능할 경우의 수
    public static long[][][] D = new long[101][101][101];

    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(bf.readLine());

        int N = Integer.parseInt(st.nextToken());
        int L = Integer.parseInt(st.nextToken());
        int R = Integer.parseInt(st.nextToken());

        D[1][1][1] = 1;

        for (int i = 2; i < N + 1; i++) {
            for (int j = 1; j < L + 1; j++) {
                for (int k = 1; k < R + 1; k++) {
                    D[i][j][k] = (D[i - 1][j][k] * (i - 2) + D[i - 1][j][k - 1] + D[i - 1][j - 1][k]) % 1000000007;
                }
            }
        }

        System.out.println(D[N][L][R]);
    }
}
```

&ensp;배열 D[N][L][R]을 N개의 빌딩이 있고 왼쪽에 L개, 오른쪽에서 R개가 보일 때 가능할 경우의 수로 설정한다. 이때 D[N][L][R]은 N - 1개의 빌딩에서 왼쪽에서 L개, 오른쪽에서 R개 보일 때 가능한 경우의 수에서 건 물 사이사이에 건물을 추가하는 경우의 수와 N - 1개의 빌딩에서 각각 왼쪽에 1개, 오른쪽에 1개 추가하는 경우의 수의 합과 같으므로, D[i][j][k] = D[i - 1][j][k] * (i - 2) + D[i - 1][j][k - 1] + D[i - 1][j - 1][k] 로 점화식을 세울 수 있다.

문제 093 DDR을 해보자
======
`시간 제한: 2초, 난이도: 골드3, 2342번`
<p align="center"><img src="/assets/img/Do-it!-알고리즘-코딩테스트-C++/11장 동적 계획법/1-10-093-2342-문제.png"></p>

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    // D[N][L][R] = N개의 수열을 수행하고있고 왼쪽이 L, 오른쪽이 R 자리에 있을 때 최소 누적 힘
    public static long[][][] D = new long[100001][5][5];

    // mp[n][m] = n에서 m으로 발을 옮길 때 드는 힘
    public static int[][] mp =
            { {0, 2, 2, 2, 2},
                    {2, 1, 3, 4, 3},
                    {2, 3, 1, 3, 4},
                    {2, 4, 3, 1, 3},
                    {2, 3, 4, 3, 1} };

    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));

        for (int i = 0; i < 100001; i++) {
            for (int j = 0; j < 5; j++) {
                for (int k = 0; k < 5; k++) {
                    D[i][j][k] = 100001 * 4;
                }
            }
        }
        D[0][0][0] = 0;

        int n = 1;
        StringTokenizer st = new StringTokenizer(bf.readLine());

        while (true) {
            int nextStep = Integer.parseInt(st.nextToken());
            if (nextStep == 0) {
                break;
            }

            // 오른발을 옮겼을 때 최소 힘
            for (int i = 0; i < 5; i++) {
                if (nextStep == i) {
                    continue;
                }
                for (int j = 0; j < 5; j++) {
                    D[n][i][nextStep] = Math.min(D[n - 1][i][j] + mp[j][nextStep], D[n][i][nextStep]);
                }
            }

            // 왼발을 옮겼을 때 최소 힘
            for (int i = 0; i < 5; i++) {
                if (nextStep == i) {
                    continue;
                }
                for (int j = 0; j < 5; j++) {
                    D[n][nextStep][i] = Math.min(D[n - 1][j][i] + mp[j][nextStep], D[n][nextStep][i]);
                }
            }

            n++;
        }

        n--;
        long min = 100001 * 4;
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 5; j++) {
                min = Math.min(min, D[n][i][j]);
            }
        }

        System.out.println(min);
    }
}
```

&ensp;배열 D[N][L][R] 를 N개의 수열을 수행하고있고 왼쪽이 L, 오른쪽이 R 자리에 있을 때 최소 누적 힘으로 정의한 뒤, 오른발을 옮겨서 nextStep으로 가는 힘과 왼발을 옮겨서 nextStep으로 가는 힘 중 최소값을 저장한 다음 그 값을 비교해 최소값을 출력한다.

문제 094 행렬 곱 연산 횟수의 최솟값 구하기
======
`시간 제한: 1초, 난이도: 골드3, 11049번`
<p align="center"><img src="/assets/img/Do-it!-알고리즘-코딩테스트-C++/11장 동적 계획법/1-11-094-11049-문제.png"></p>

```java
import java.io.*;
import java.util.*;

public class Main {

    static int[][] D;   // D[i][j]: i ~ j 구간의 행렬을 합치는 데 드는 최소 연산 횟수
    static int[][] Matrix;

    static int Cross(int s, int e) {
        int result = Integer.MAX_VALUE;

        if (D[s][e] != -1) {
            return D[s][e]; // 이미 계산헀으면 return
        }

        if (s == e) {
            return 0;
        }

        if (s + 1 == e) {
            return Matrix[s][0] * Matrix[s][1] * Matrix[e][1];
        }

        // 헹렬이 3개 이상일 경우
        for (int i = s; i < e; i++) {
            result = Math.min(result, Matrix[s][0] * Matrix[i][1] * Matrix[e][1] + Cross(s, i) + Cross(i + 1, e));
        }

        return D[s][e] = result;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(bf.readLine());
        D = new int[N][N];

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                D[i][j] = -1;
            }
        }

        Matrix = new int[N][2]; // 0번째 원소: column, 1번째 원소: row
        for (int i = 0; i < N; i++) {
            StringTokenizer st = new StringTokenizer(bf.readLine());

            Matrix[i][0] = Integer.parseInt(st.nextToken());
            Matrix[i][1] = Integer.parseInt(st.nextToken());
        }

        System.out.println(Cross(0, N - 1));

    }
}
```

&ensp;D[i][j]를 i번째에서 j까지 행렬을 곱했을 때, 최솟값으로 정의했다. 이후 i==j 일 경우, 행렬 1개의 곱과 같으므로 0이 된다. i + 1 == j 일 경우, 행렬 2개의 곱과 같다. 이후 곱해야할 행렬이 3개 이상인 경우, s부터 i번째 까지 곱했을 때와 i + 1부터 e까지 곱했을 때의 행렬 곱 횟수와 그 전의 최솟값과 비교해 최솟값을 구한다.

문제 095 외판원의 순회 경로 짜기
======
`시간 제한: 1초, 난이도: 골드1, 2098번`
<p align="center"><img src="/assets/img/Do-it!-알고리즘-코딩테스트-C++/11장 동적 계획법/1-12-095-2098-문제.png"></p>

문제 096 가장 길게 증가하는 부분 수열 찾기
======
`시간 제한: 3초, 난이도: 플래티넘5, 14003번`
<p align="center"><img src="/assets/img/Do-it!-알고리즘-코딩테스트-C++/11장 동적 계획법/1-13-096-14003-문제.png"></p>

