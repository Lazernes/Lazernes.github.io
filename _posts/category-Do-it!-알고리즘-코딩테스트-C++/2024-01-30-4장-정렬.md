---
title: "4장 정렬"
excerpt: "정렬은 데이터를 정해진 기준에 따라 배치해 의미 있는 구조로 재설정하는 것을 말한다."

wirter: Myeongwoo Yoon
categories:
  - Do it! 알고리즘 코딩테스트 C++
tags:
  - Algorithm
  - C++

use_math: true
toc: true
toc_sticky: true
 
date: 2024-01-30
last_modified_at: 2024-01-30
---

　4장에서 다룰 정렬 알고리즘의 정의는 다음과 같다.

|정렬 알고리즘|정의|
|---|---|
|버블(bubble)|데이터의 인접 요소끼리 비교하고, swap 연산을 수행하며 정렬하는 방식|
|선택(selection)|대상에서 가장 크거나 작은 데이터를 찾아가 선택을 반복하면서 정렬하는 방식|
|삽입(insertion)|대상을 선택해 정렬된 영역에서 선택 데이터의 적절한 위치를 찾아 삽입하면서 정렬하는 방식|
|퀵(quick)|pivot 값을 선정해 해당 값을 기준으로 정렬하는 방식|
|병합(merge)|이미 정렬된 부분 집합들을 효율적으로 병합해 전체를 정렬하는 방식|
|기수(radix)|데이터의 자릿수를 바탕으로 비교해 데이터를 정렬하는 방식|

버블 정렬
======

버블 정렬의 핵심 이론
------
　**버블 정렬(bubble sort)**은 두 인접한 데이터의 크기를 비교해 정렬하는 방법이다. 간단하게 구현할 순 있지만, 시간 복잡도는 O($n^2$)으로 다른 정렬 알고리즘보다 속도가 느린 편이다. 다음과 같이 루프(loop)를 돌면서 인접한 데이터 간의 swap 연산으로 정렬한다.<br/>
<p align="center"><img src="/assets/img/Do-it!-알고리즘-코딩테스트-C++/4장 정렬/1-1.jpeg" width="500"></p>

　정렬 과정은 다음과 같다.
1. 비교 연산이 필요한 루프 범위를 설정한다.
2. 인접한 데이터 값을 비교한다.
3. swap 조건에 부합하면 swap 연산을 수행한다.
4. 루프가 끝날 때까지 2~3을 반복한다.
5. 정렬된 영역을 설정한다. 다음 루프를 실행할 때는 이 영역을 제외한다.
6. 비교 대상이 없을 때까지 1~5를 반복한다.

　만약 특정한 루프의 전체 영역에서 swap이 한 번도 발생하지 않았다면 그 영역 뒤에 있는 데이터가 모두 정렬됐다는 뜻이므로 프로세스를 종료해도 된다.

문제 015 수 정렬하기 1
------
`시간 제한: 2초, 난이도: 브론즈1, 2750번`
<p align="center"><img src="/assets/img/Do-it!-알고리즘-코딩테스트-C++/4장 정렬/1-2.png"></p>

**풀이**<br/>
<p align="center"><img src="/assets/img/Do-it!-알고리즘-코딩테스트-C++/4장 정렬/1-3.jpeg"></p>

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
	int N;
	cin >> N;

	vector<int>A(N, 0);
	for (int i = 0; i < N; i++) {
		cin >> A[i];
	}

	for (int i = 0; i < N - 1; i++) {
		for (int j = 0; j < N - 1 - i; j++) {
			if (A[j] > A[j + 1]) {
				int tmp = A[j + 1];
				A[j + 1] = A[j];
				A[j] = tmp;
			}
		}
	}

	for (int i = 0; i < N; i++)
		cout << A[i] << '\n';
}
```

문제 016 버블 정렬 프로그램 1
------
`시간 제한: 2초, 난이도: 골드2, 1377번`
<p align="center"><img src="/assets/img/Do-it!-알고리즘-코딩테스트-C++/4장 정렬/1-4.png"></p>

**풀이**<br/>
<p align="center"><img src="/assets/img/Do-it!-알고리즘-코딩테스트-C++/4장 정렬/1-5.jpeg"></p>

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

typedef pair<int, int>Node;

int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int N;
	cin >> N;

	vector<Node>A(N);
	for (int i = 0; i < N; i++) {
		cin >> A[i].first;
		A[i].second = i;
	}

	sort(A.begin(), A.end());

	int Max = 0;
	for (int i = 0; i < N; i++) {
		if (Max < A[i].second - i)
			Max = A[i].second - i;
	}

	cout << Max + 1;

}
```

　위 출력은 영식이가 만든 프로그램에서 for문이 수행된 횟수이다. 이를 구하기 위해서 정렬 전 index와 정렬 후 index를 비교해 왼쪽으로 가장 많이 이동한 값을 찾아 + 1을 해주면 된다.

선택 정렬
======

삽입 정렬
======


퀵 정렬
======


병합 정렬
======


기수 정렬
======