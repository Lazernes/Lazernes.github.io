---
title: "2장 데이터 모델링의 이해"
excerpt: "데이터 모델링의 기본적인 용어에 대해 알아본다."

wirter: Myeongwoo Yoon
categories:
  - SQLD
tags:
  - SQL

use_math: true
toc: true
toc_sticky: true
 
date: 2024-03-04
last_modified_at: 2024-03-04
---

데이터 모델링(Data Modeling)
======

데이터 모델링의 이해
------
　데이터 모델링은 현실 세계를 데이터베이스로 표현하기 위해서 추상화한다. 데이터 모델링의 특징으로는 **추상화(Abstraction), 단순화(Simplification), 명확성(Clarity)**가 있다.
* 추상화(Abstraction): 현실 세계를 간략하게 표현한다.
* 단순화(Simplification): 누구나 쉽게 이해할 수 있도록 표현한다.
* 명확성(Clarity): 명확하게 의미가 해석되어야 하고 한 가지 의미를 가져야 한다.

**데이터 모델링의 단계**<br/>
* **개념적 모델링(Condeptual Data Modeling)**
  - 전사적 관점에서 기업의 데이터를 모델링한다.
  - 추상화 수준이 가장 높은 수준의 모델링이다.
  - 계층형 데이터 모델, 네트워크 모델, 관계형 모델에 관계없이 업무 측면에서 모델링한다.
  - 엔티티(Entity)와 속성(Attribute)을 도출하고 개념적 ERD(Entity Relationship Diagram)를 작성한다.
* **논리적 모델링(Logical Data Modeling)**
  - 개념적 모델링을 논리적 모델링으로 변환하는 작업이다.
  - 식별자를 정의하고 관계, 속성 등을 모두 표현한다.
  - 특정 데이터베이스 모델에 종속한다.
  - 정규화를 통해서 재사용성을 높이고 데이터 모델의 독립성을 확보한다.
* **물리적 모델링(Physical Modeling)**
  - 구축할 데이터베이스 관리 시스템에 테이블, 인덱스 등을 생성하는 단계이다.
  - 성능, 보안, 가용성 등을 고려하여 데이터베이스를 구축한다.

**데이터 모델링을 위한 ERD(Entity Relationship Diagram)**<br/>
　엔티티와 엔티티 간의 관계를 정의하는 모델링 방법이다. ERD 작성 절차는 다음과 같다.
1. 엔티티를 도출하고 그린다.
  - 업무에서 관리해야 하는 집합을 도출한다.
2. 엔티티를 배치한다.
  - 엔티티를 도출한 후 엔티티를 배치한다.
  - 중요한 엔티티를 왼쪽 상단에 배치한다.
3. 엔티티 간의 관계를 설정한다.
4. 관계명을 서술한다.
  - 엔티티 간의 어떤 행위나 존재가 있는지 표현한다.
5. 관계 참여도를 표현한다.
  - 관계 참여도는 한 개의 엔티티와 다른 엔티티 간의 참여하는 관계 수를 의미한다.
6. 관계의 필수 여부를 표현한다.
  - 필수는 반드시 존재해야 하는 것이다.

**데이터 모델링 고려사항**<br/>
* 데이터 모델의 독립성
  - 독립성이 확보된 모델은 고객의 업무 변화에 능동적으로 대응할 수 있다.
  - 독립성을 확보하기 위해서는 중복된 데이터를 제거해야 한다.
  - 데이터 중복을 제거하는 방법이 바로 정규화이다.
* 고객 요구사항의 표현
  - 데이터 모델링으로 고객과 데이터 모델러 간에 의사소통을 할 수 있어야 하므로, 고객의 요구사항을 간결하고 명확하게 표현해야 한다.
* 데이터 품질 확보
  - 데이터베이스 구축 시에 데이터 표준을 정의하고 표준 준수율을 관리해야 한다.
  - 데이터 표준을 확보해야 데이터 품질을 향상시킬 수 있다.

3층 스키마(3-Level Schema)
------
　**3층 스키마(3-Level Schema)**는 사용자, 설계자, 개발자가 데이터베이스를 보는 관점에 따라 데이터베이스를 기술하고 이들간의 관계를 정의한 ANSI 표준이다. 3층 스키마는 데이터베이스의 독립성을 확보하기 위한 방법이다. 데이터의 독립성을 확보하면 데이터 복잡도 감소, 데이터 중복 제거, 사용자 요구사항 변경에 따른 대응력 향상, 관리 및 유지보구 비용 절감 등의 장점을 갖는다. 3단계 계층으로 분리해서 독립성을 확보하는 방법으로 각 계층을 뷰(View)라고도 한다.
* 논리적 독립성: 개념 스키마가 변경되더라도 외부 스키마가 영향을 받지 않는 것이다.
* 물리적 독립성: 내부 스키마가 변경되더라고 개념 스키마가 영향을 받지 않는 것이다.

　3층 스키마의 구조는 다음과 같다.
<p align="center"><img src="/assets/img/SQLD/데이터 모델링의 이해/2-1.jpeg"></p>

* 외부 스키마(External Schema)
  - 사용자 관점, 업무상 관련이 있는 데이터 접근이다.
  - 관련 데이터베이스의 뷰(View)를 표시한다.
  - 응용 프로그램이 접근하는 데이터베이스를 정의한다.
* 개념 스키마(Conceptual Schema)
  - 설계자 관점, 사용자 전체 집단의 데이터베이스 구조이다.
  - 전체 데이터베이스 내의 규칙과 구조를 표현한다.
  - 통합 데이터베이스 구조이다.
* 내부 스키마(Internal Schema)
  - 개발자 관점, 데이터베이스의 물리적 저장 구조이다.
  - 데이터 저장 구조, 레코드 구조, 필드 정의, 인덱스 등을 의미한다.

엔티티(Entity)
------
　엔티티는 업무에서 관리해야 하는 데이터 집합을 의미하며, 저장되고 관리되어야 하는 데이터이다. 엔티티는 고객의 비지니스 프로세스에서 관리되어야 하는 정보를 추출해야 한다. 엔티티의 특징은 다음과 같다.
* 식별자: 엔티티는 유일한 식별자가 있어야 한다.
* 인스턴스 집합: 2개 이상의 인스턴스가 있어야 한다.
* 속성: 엔티티는 반드시 속성을 가지고 있다.
* 관계: 엔티티는 다른 엔티티와 최소한 한 개 이상 관계가 있어야 한다.
* 업무: 엔티티는 업무에서 관리되어야 하는 집합이다.

　엔티티의 종류는 유형과 무형에 따른 종류, 엔티티가 발생하는 시점에 따른 종류로 나누어진다. 엔티티를 유형과 무형으로 분류하는 기준은 물리적 형태의 존재 여부이다.
* 유형 엔티티: 업무에서 도출되며 지속적으로 사용되는 엔티티이다.
* 개념 엔티티: 유형 엔티티는 물리적 형태가 있지만, 개념 엔티티는 물리적 형태가 없다. 개념적으로 사용되는 엔티티이다.
* 사건 엔티티: 비지니스 프로세스를 실행하면서 생성되는 엔티티이다.

　발생 시점에 따른 엔티티의 종류는 다음과 같다.
* 기본 엔티티(Basic Entity): 키 엔티티라고도 한다. 다른 엔티티로부터 영향을 받지 않고 독립적으로 생성되는 엔티티이다.
* 중심 엔티티(Main Entity): 기본 엔티티와 행위 엔티티 간의 중간에 있는 것이다. 즉, 기본 엔티티로부터 발생되고 행위 엔티티를 생성하는 것이다.
* 행위 엔티티(Active Entity): 2개 이상의 엔티티로부터 발생된다.
<p align="center"><img src="/assets/img/SQLD/데이터 모델링의 이해/2-2.jpeg"></p>

속성(Attribute)
------
　속성은 업무에서 필요한 정보인 엔티티가 가지는 항목이다. 속성은 더 이상 분리되지 않는 단위로, 업무에 필요한 데이터를 저장할 수 있다. 인스턴스의 구성요소이고 의미적으로 더 이상 분해되지 않는다. 속성의 특징과 종류는 다음과 같다.
* 속성의 특징
  - 속성은 업무에서 관리되는 정보이다.
  - 속성은 하나의 값만 가진다.
  - 주식별자에게 함수적으로 종속된다. 즉, 기본키가 변경되면 속성의 값도 변경된다.
* 속성의 종류
  - 분해 여부에 따른 속성의 종류
    + 단일 속성: 하나의 의미로 구성된 것으로 회원ID, 이름 등이다.
    + 복합 속성: 여러 개의 의미가 있는 것으로 주소가 있다. 주소는 시, 군, 동 등으로 분해될 수 있다.
    + 다중값 속성: 속성에 여러 개의 값을 가질 수 있는 것으로 상품 리스트가 있다. 다중값 속성은 엔티티로 분해된다.
  - 특성에 따른 속성의 종류
    + 기본 속성: 비지니스 프로세스에서 도출되는 본래의 속성이다.
    + 설계 속성: 데이터 모델링의 과정에서 발생되는 속성이다. 유일한 값을 부여한다.
    + 파생 속성: 다른 속성에 의해서 만들어지는 속성이다.

관계(Relationship)
------
　관계는 엔티티 간의 관련성을 의미하며 존재 관계와 행위 관계로 분류된다. 존재 관계는 두 개의 엔티티가 존재 여부의 관계가 있는 것이고, 행위 관계는 두 개의 엔티티가 어떤 행위에 의한 관련성이 있는 것이다.
* 존재 관계: 존재 관계는 엔티티 간의 상태를 의미한다.
  - 고객이 은행에 회원가입을 하면, 관지점이 할당되고, 그 할당된 관리점에서 고객을 관리한다.
* 행위 관계: 엔티티 간의 어떤 행위가 있는 것으로, 계좌를 사용해서 주문을 발주하는 관계가 만들어진다.
  - 증권회사는 계좌를 개설하고 주문을 발주하는 것이다.

　**관계 차수(Relation Cardinality)**는 두 개의 엔티티 간에 관계에 참여하는 수를 의미한다.
* 1대1 관계
  - 1대1 관계는 완전 1대1 관계와 선택적 1대1 관계가 있다.
  - 완전 1대1 관계: 하나의 엔티티에 관계되는 엔티티의 관계가 하나의 경우로, 반드시 존재한다.
  - 선택적 1개1 관계: 하나의 엔티티에 관계되는 엔티티의 관계가 하나이거나 없을 수도 없다.
* 1개N 관계
  - 1대N 관계는 엔티티에 행이 하나 있을 때 다른 엔티티의 값이 여러 개 있는 관계이다.
* M대N 관계
  - M개N 관계는 두 개 엔티티가 서로 여러 개의 관계를 가지고 있는 것이다.
  - M대N 관계의 조인(Join)은 카티션 곱이 발생한다. 그래서 M대N관계를 1대N, N대1로 해소해야 한다.
  - 카티션 곱(Cartesian Product, 곱집합): 각 릴레이션에 존재하는 모든 데이터를 조합하여 연산하는 것을 말한다.
* 필수적 관계와 선택적 관계
  - 필수적 관계는 반드시 하나는 존재해야 하는 관계이고 선택적 관계는 없을 수도 있는 관계이다.
  - 필수적 관계는 '\|'로 표현되고 선택적 관계는 'O'으로 표시한다.

식별 관계와 비식별 관계
------
* 식별 관계(Identification Relationship)
  - 고객과 계좌 엔티티에서 고객은 독립적으로 존재할 수 있는 강한 개체(Strong Entity)이다.
  - 강한 개체는 어떤 다른 엔티티에게 의존하지 않고 독립적으로 존재하고 다른 엔티티와 관계를 가질 때 다른 엔티티에게 기본키를 공유한다. 또한 식별 관리로 표현된다.
  - 즉, 식별 관계란 고객 엔티티의 기본키인 회원 ID를 계좌 엔티티의 기본키의 하나로 공유하는 것이다.
  - 강한 개체의 기본키 값이 변경되면 식별 관계(기본키를 공유받은)에 있는 엔티티의 값도 변경된다.
  - 강한 개체(Strong Entity): 누구에게도 지배되지 않는 독립적인 개체(Entity)이다.
  - 약한 개체(Weak Entity): 개체의 존재가 다른 개체의 존재에 달려 있는 개체이다.
* 비식별 관계(Non-Identification Relationship)
  - 비식별 관계는 강한 개체의 기본키를 다른 엔티티의 기본키가 아닌 일반 칼럼으로 관계를 가지는 것이다.

엔티티 식별자(Entity Identifier)
------
　식별자는 엔티티를 대표할 수 있는 유일성을 만족하는 속성이다.<br/>
　**주식별자(기본키, Primary Key)**의 특징은 다음과 같다.
* 최소성: 주식별자는 최소성을 만족하는 키이다.
* 대표성: 주식별자는 엔티티를 대표할 수 있어야 한다.
* 유일성: 주식별자는 엔티티의 인스턴스를 유일하게 식별한다.
* 불변성: 주식별자는 자주 변경되지 않아야 한다.
* 키의 종류
  - 기본키(Primary Key): 후보키 중에서 엔티티를 대표할 수 있는 키이다.
  - 후보키(Candidate Key): 후보키는 유일성과 최소성을 만족하는 키이다.
  - 슈퍼키(Super Key): 슈퍼키는 유일성은 만족하지만 최소성은 만족하니 않는 키이다.
  - 대체키(Alternate Key): 대체키는 여러 개의 후보키 중에서 기본키를 선정하고 남은 키이다.
  - 외래키(Foreign Key): 하나 혹은 다수의 다른 테이블의 기본 키 필드를 가리키는 것으로 참조 무결성(Referential Integrity)을 확인하기 위해서 사용되는 키이다. 즉, 허용된 데이터 값만 데이터베이스에 저장하기 위해서 사용된다.

　식별자는 대표성, 생성 여부, 속성의 수, 대체 여부로 분류된다.
* 식별자의 대표성
  - 주식별자는 엔티티를 대표할 수 있는 식별자이다.
  - 주식별자: 유일성과 최소성을 만족하면서 엔티티를 대표하는 식별자이다. 다른 엔티티와 참조 관계로 연결될 수 있다.
  - 보조 식별자: 유일성과 최소성은 만족하지만 대표성은 만족하지 못하는 식별자이다.
* 생성 여부
  - 내부 식별자: 엔티티 내부에서 스스로 생성되는 식별자이다. 부서코드, 주문번호, 종목코드 등이 있다.
  - 외부 식별자: 다른 엔티티와의 관계로 인하여 만들어지는 식별자이다. 계좌 엔티티에 회원 ID가 있다.
* 속성의 수
  - 단일 식별자: 하나의 속성으로 구성된다.
  - 복합 식별자: 두 개 이상의 속성으로 구성된다.
* 대체 여부
  - 본질 식별자: 비지니스 프로세스에서 만들어지는 식별자이다.
  - 인조 식별자: 인위적으로 만들어지는 식별자이다.

데이터 모델과 성능
======

정규화(Normalization)
------
　정규화는 데이터의 일과성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법이며 데이터를 분해하는 과정이다. 정규화는 데이터 중복을 제거하고 데이터 모델의 독립성을 확보하기 위한 방법이고 테이블을 분해해서 데이터 중복을 제거하기 때문에 데이터 모델의 유연성을 높인다. 정규화를 수행하면 비지니스에 변화가 발생하여도 데이터 모델의 변경을 최소화 할 수 있다. 정규화는 제1정규화부터 제5정규화까지 있지만, 실질적으로는 제3정규화까지만 수행한다.<br/>
　정규화된 모델은 테이블이 분해된다. 테이블이 분해되면 조인(Join)을 수행하여 하나의 합집합으로 만들 수도 있다. 정규화를 수행하면 불필요한 데이터를 입력하지 않아도 되기 때문에 중복 데이터가 제거된다.
* 제1정규화: 속성(Attribute)의 원자성을 확보한다. 기본키(Primary)를 설정한다.
* 제2정규화: 기본키가 2개 이상의 속성으로 이루어진 경우, 부분 함수 종속성을 제거한다.
* 제3정규화: 기본키를 제외한 칼럼 간에 종속성을 제거한다. 즉, 이행 함수 종속성을 제거한다.
* BCNF: 기본키를 제외하고 후보키가 있는 경우, 후보키가 기본키를 종속시키면 분해한다.
* 제4정규화: 여러 칼럼들이 하나의 칼럼을 종속시키는 경우 분해하여 다중값 종속성을 제거한다.
* 제5정규화: 조인에 의해서 종속성이 발생되는 경우 분해한다.

　정규화는 데이터 조회(SELECT) 시에 조인(Join)을 유발하기 때문에 CPU와 메모리를 많이 사용하는 단점이 있다. 정규화의 문제점을 해결하기 위해서 반정규화를 하여 하나의 테이블에 저장한다면 조인을 통한 성능 저하는 해결될 것이다. 이런 성능 저하를 해결하기 위해 반정규화가 존재하는 것이다.

반정규화(De-Normalization)
------
　반정규화는 데이터베이스의 성능 향상을 위하여, 데이터 중복을 허용하고 조인을 줄이는 데이터베이스 성능 향상 방법이다. 반정규화는 조회(SELCET) 속도를 향상하지만, 데이터 모델의 유연성은 낮아진다.<br/>
　반정규화는 정규화에 충실하면 종소성, 활용성은 향상되지만 수행 속도가 느려지는 경우, 다량의 범위를 자주 처리해야 하는 경우, 특정 범위의 데이터만 자주 처리하는 경우, 요약/집계 정보가 자주 요구되는 경우에 수행한다.<br/>
　반정규화의 절차는 다음과 같다.
* 대상 조사 및 검토: 데이터 처리 범위, 통계성 등을 확인하여 반정규화 대상을 조사한다.
* 다른 방법 검토: 반정규화를 수행하기 전에 다른 방법이 있는지 검토한다. 예를 들어 클러스터링, 뷰, 인덱스 튜닝 등을 검토한다.
  - 클러스터링(Clustering): 클러스터링 인덱스는 인덱스 정보를 저장할 때 물리적으로 정렬해서 저장하는 방법이다. 따라서 조회 시에 인접 블록을 연속적으로 읽기 때문에 성능이 향상된다.
* 반정규화 수행: 테이블, 속성, 관계 등을 반정규화 한다.

　반정규화 기법은 다음과 같다.
1. 계산된 칼럼 추가
  * 배치 프로그램으로 총판매액, 평균잔고 등을 미리 계산하고, 그 결과를 특정 칼럼에 추가한다.
2. 테이블 수직 분할
  * 하나의 테이블을 두 개 이상의 테이블로 분할한다. 즉, 칼럼을 분할하여 새로운 테이블을 만드는 것이다.
3. 테이블 수평 분할
  * 하나의 테이블에 있는 값을 기준으로 테이블을 분할하는 방법이다.
  * 파티션(Partition) 기법
    - 데이터베이스에서 파티션을 사용해서 테이블을 분할할 수 있다. 파티션을 사용하면 논리적으로는 하나의 테이블이지만 여러 개의 데이터 파일에 분산되어서 저장된다.
    - Range Partition: 데이터 값의 범위를 기준으로 파티션을 수행한다.
    - List Partition: 특정한 값을 지정하여 파티션을 수행한다.
    - Hash Partition: 해시 함수를 적용하여 파티션을 수행한다.
    - Composite Partition: 범위와 해시를 복합적으로 사용하여 파티션을 수행한다.
  * 파티션 테이블의 장점
    - 데이터 조회 시에 액세스(Access) 범위가 줄어들기 때문에 성능이 향상된다.
    - 데이터가 분할되어 있기 때문에 I/O의 성능이 향상된다.
    - 각 파티션을 독립적으로 백업 및 복구가 가능한다.
4. 테이블 병합
  - 1대1 관계의 테이블을 하나의 테이블로 병합해서 성능을 향상시킨다.
  - 1대N 관계의 테이블을 병합하여 성능을 향상시킨다. 하지만 많은 양의 데이터 중복이 발생한다.
  - 슈퍼 타입과 서브 타입 관계가 발생하면 테이블을 통합하여 성능을 향상시킨다.
  - Super Type, Sub Type
    + 고객 엔티티는 개인고객과 법인고객으로 분류된다. 이때 고객 엔티티는 슈퍼타입이고 개인고객과 법인고객은 서브 타입이 된다.
    + 즉, 부모와 자식 간의 관계가 나타난다.
    + 슈퍼 타입과 서브 타입의 관계는 베타적 관계와 포괄적 관계가 있는데, 베타적 관계는 고객이 개인고객이거나 법인고객인 경우를 의미한다. 포괄적 관계는 고객이 개인고객일 수도 있고 법인고객일 수도 있는 것이다.
  - 슈퍼 타입 및 서브 타입 변환 방법
    + OneToOne Type: 슈퍼 타입과 서브 타입을 개인 테이블로 도출한다. 테이블의 수가 많아서 조인이 많이 발생하고 관리가 어렵다.
    + Plus Type: 슈퍼 타입과 서브 타입 테이블로 도출한다. 조인이 발생하고 관리가 어렵다.
    + Single Type: 슈퍼 타입과 서브 타입을 하나의 테이블로 도출한다. 조인 성능이 좋고 관리가 편하지만, 입출력 성능이 나쁘다.
    
분산 데이터베이스
------
　데이터베이스 시스템 구축 시 한 대의 물리적 시스테메 데이터베이스 관리 시스템을 설치하고 여러 명의 사용자가 데이터베이스 관리 시스템에 접속하여 데이터베이스를 사용하는 구조를 **중앙 집중형 데이터베이스**라고 한다. 또한 물리적으로 떨어진 데이터베이스에 네트워크로 연결하여 단일 데이터베이스 이미지를 보여 주고 분산된 작업 처리를 수행하는 데이터베이스를 **분산 데이터베이스**라고 한다.<br/>
　분산 데이터베이스를 사용하는 고객은 시스템이 네트워크로 분산되어 있는지의 여부를 인식하지 못하면서, 자신만의 데이터베이스를 사용하는 것처럼 사용할 수 있다. 이처럼 데이터베이스는 투명성을 제공해야 한다. 투명성은 분산 데이터베이스에서 중요한 요소이며 투명성의 종류에는 분할, 위치, 지역사상, 중복, 장애 및 병생 투명성이 있다.
* 분할 투명성: 고객은 하나의 논리적 릴레이션이 여러 단편으로 분할되어 각 단편의 사본이 여러 시스템이 저장되어 있음을 인식할 필요가 없다.
* 위치 투명성: 고객이 사용하려는 데이터의 저장 장소를 명시할 필요가 없다. 고객은 데이터가 어느 위치에 있더라도 동일한 명령을 사용하여 데이터에 접근할 수 있어야 한다.
* 지역 사상 투명성: 지역 DBMS와 물적 데이터베이스 사이의 사상이 보장됨에 따라 각 지역 시스템 이름과 무관한 이름이 사용 가능하다.
* 중복 투명성: 데이터베이스 객체가 여러 시스템에 중복되어 존재함에도 고객과는 무관하게 데이터의 일관성이 유지된다.
* 장애 투명성: 데이터베이스가 분산되어 있는 각 지역의 시스템이나 통신망에 이상이 발생해도, 데이터의 무결성은 보장된다.
* 병행 투명성: 여러 고객의 응용 프로그램이 동시에 분산 데이터베이스에 대한 트랜잭션을 수행하는 경우에도 결과에 이상이 없다.

　분산 데이터베이스의 구축 방법에는 상향식 설계 방식과 하향식 설계 방식이 있다.
* 상향식 설계 방식: 지역 스키마 작성 후 향후 전역 스키마를 작성하여 분산 데이터베이스를 구축한다.
* 하향식 설계 방식: 전역 스키마 작성 후 해당 지역 사상 스키마를 작성하여 분산 데이터베이스를 구축한다.

　분산 데이터베이스를 하향식 접근 방식으로 구축한다는 것은 기업 전체의 전사 데이터 모델을 수렴하여 전역 스키마를 생성하고, 그 다음 각 지역별로 지역 스키마를 생성하여 분산 데이터베이스를 구축하는 것이다. 상향식 접근 방식은 지역별로 데이터베이스를 구축한 후에 전역 스키마로 통합하는 것이다.<br/>
　분산 데이터베이스를 구축하거나 운영할 때 동일한 데이터베이스 관리 시스템으로 분산 데이터베이스를 구축하는 것은 크게 어렵지 않다. 하지만 기업에 여러 종류의 데이터베이스 관리 시스템이 있으면 이기종 데이터베이스 관리 시스템으로 연동해야 한다. 이기종 데이터베이스 시스템으로 연동하기 위해서는 데이터베이스를 미들웨어(ODBC, JDBC)를 사용해야 한다.<br/>
　분산 데이터베이스의 장•단점은 다음과 같다.
* 장점
  - 데이터베이스 신뢰성과 가용성이 높다.
  - 분산 데이터베이스가 병렬 처리를 수행하기 때문에 빠른 응답이 가능하다.
  - 분산 데이터베이스를 추가하여 시스템 용량 확장이 쉽다.
* 단점
  - 데이터베이스가 여러 네트워크를 통해서 분리되어 있기 때문에 관리와 통제가 어렵다.
  - 보안관리가 어렵다.
  - 데이터 무결성 관리가 어렵다.
  - 데이터베이스 설계가 복잡하다.