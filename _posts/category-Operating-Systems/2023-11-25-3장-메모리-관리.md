---
title: "3장 메모리 관리"
excerpt: "메인 메모리(main memory)는 매우 조심스럽게 관리되어야 할 중요한 자원이다. 프로그램은 매우 크고 빠른 메모리를 요구한다. 프로그램은 가용한 메모리가 생기는 만큼 크기가 증가한다고 말할 수 있다."

wirter: Myeongwoo Yoon
categories:
  - Operating Systems
tags:
  - Programing

use_math: true
toc: true
toc_sticky: true
 
date: 2023-11-25
last_modified_at: 2023-11-25
---

　모든 프로그래머가 원하는 것은 무한히 크고, 빠르며, 자신이 혼자 사용할 수 있는 메모리이다. 또한 비휘발성(nonvolatile) 메모리를 원한다. 또 한가지 중요한 것은 가격이 비싸지 않아야 한다는 것이다. 하지만 현재 기술로는 위의 모든 요구 조건을 만족시킬 수 있는 메모리를 만들 수는 없다.<br/>
　**메모리 계층 구조(memory hierarchy)**란 캐시 메모리(cache memory), 메인 메모리(main memory), 디스크 스토리지(storage) 등의 서로 다른 특성을 갖는 메모리들을 층 구조로 구성하는 방법이다. 캐시 메모리는 보통 메가바이트(megabyte) 크기를 가지며, 빠르고 휘발성이며 비싸다. 반면 메인 메모리는 가가바이트(gigabyte) 크기를 가지며, 중간 속도이고 휘발성이며 중간 정도의 가격을 갖는다. 마지막으로 디스크 스토리지는 테라바이트(terabyte) 크기를 가지며, 느리고 비휘발성이며 가격이 싸다. 이러한 계층 구조를 사용하기 좋은 모델로 추상화시키고 이 추상화된 객체를 관리하는 것이 운영체제의 역할이다.<br/>
　운영체제 중에서 메모리 계층 구조 관리를 담당하는 부분을 **메모리 관리자(memory manager)**라고 한다. 메모리 관리자는 현재 사용 중인 메모리 부분을 파악하고, 프로세스들이 메모리를 필요로 하면 할당해 주고, 더 이상 사용하지 않으면 해제하는 작업을 실행한다.<br/>

메모리 추상화가 없는 컴퓨터
======
　메모리 추상화의 가장 단순한 형태는 추상화를 사용하지 않는 것이다. 즉 모든 프로그램은 물리 메모리를 직접 사용하였다.(ex. MOV REGISTER1, 1000) 메모리 추상화가 없는 환경에서는 두 개의 프로그램이 동시에 메모리에서 실행된다는 것은 불가능하다.<br/>
　물리 메모리를 직접 사용하는 추상화 없는 메모리 모델에서도 설계에 여러 가지 선택이 가능하다. 다음은 3가지 선택의 경우들을 보여준다.<br/>
<p align="center"><img src="/assets/img/Operating-Systems/3장-메모리-관리/1-1.png" width="600"></p>

　(a)는 RAM(Random Access Memory: 임의접근 메모리)의 아래 부분에 운영체제가 존재하고 그 위에 사용자 프로그램이 존재하는 메모리 구성의 예를 보여준다. 반면 (b)는 주소 공간 상단에 배치된 ROM(Read Only Memory)에 운영체제가 존재하는 예를 보여주며, (c)는 ROM에는 장치 드라이버가 존재하고 그 아래에 있는 RAM에 사용자 프로그램과 운영체제가 존재하는 예를 보여준다.<br/>
　컴퓨터 시스템이 이와 같은 방법으로 구성되어 있으면 대부분 한 순간에 하나의 프로세스만 동작하게 된다. 사용자가 명령을 입력하면 운영체제는 요청한 명령 프로그램을 디스크에서 메모리로 적재하고 그것을 실행한다. 그 프로세스가 종료되면 운영체제는 프롬프트를 출력하고 사용자가 다른 명령을 입력할 때까지 대기한다. 만일 새로운 명령이 요청되면 운영체제는 새로운 명령을 위한 프로그램을 디스크에서 메모리로 적재하는데 이때 기존에 있던 프로그램을 덮어쓰게 된다.<br/>
　메모리 추상화가 없는 시스템에서 병령성(parallelism)을 획득하는 방법 중에 하나는 여러 개의 스레드(multiple thread)를 사용하는 것이다. 한 프로세스에 존재하는 스레드들은 모두 같은 메모리 이미지를 공유하기 때문에 가능하다. 하지만 이것의 다른 의미는 스레드들이 서로 다른 프로그램을 실행할 수는 없다는 것이다. 따라서 스레드를 통해 병렬성을 얻을 수는 있지만 이것은 제한되어 있다. 실제로 많은 사람들은 관련되지 않은 서로 다른 프로그램들을 동시에 실행하기를 원하며 이것은 스레드 추상화가 지원하지 않는 기능이다. 

메모리 추상화가 없는 환경에서 여러 프로그램 실행
------
　메모리 추상화가 없는 시스템에서도 여러 프로그램을 동시에 실행하는 방법이 가능하긴 하다. 운영체제가 해야하는 일은 우선 메모리에 존재하던 프로그램 이미지를 디스크에 저장하고 다음에 실행할 프로그램을 메모리로 올리는 것이다. 사실상 메모리에 한 순간에 하나의 프로그램이 존재하기만 하면 충돌을 방지할 수 있다.<br/>
　특별한 하드웨어의 도움이 있으면 스와핑을 사용하지 않더라도 여러 프로그램을 동시에 실행하는 것이 가능하다. **보호 키(protection key)**를 통해 사용자 프로세스들은 서로 간섭하는 것을 예방할 수 있으며 운영체제 역시 프로세스들로부터 간섭을 막아 보호할 수 있다. 하지만 예를 들어 프로그램 2개가 서로 다른 보호키를 가지고 있을 때 두 프로그램들이 모두 절대 물리 주소(absolute physical address)를 사용할 경우 문제가 발생한다.<br/>
　이를 해결하기 위해 **정적 재배치(static relocation)**라는 기법을 사용한다. 정적 재배치란 프로그램이 메모리에 적재될 때 프로그램의 내용을 수정하는 것이다. 하지만 이 기법은 일반적인 방법은 아니며 또한 적재하는 시간을 증가시킨다. 더욱이 이 기법은 프로그램의 어느 위치에 주소가 있는지 부가적인 정보를 요구한다.<br/>

메모리 추상화: 주소 공간
======
　프로세스가 물리 메모리를 직접 사용하는 것은 다음과 같은 단점이 있다.
* 프로그램이 물리 메모리의 모든 주소를 접근할 수 있다면 사용자는 실수로 또는 의도적으로 운영체제를 파괴할 수 있으며 결국 시스템을 중지시킬 수 있다.
* 여러 프로그램들을 동시에 실행시키는 것이 어려워진다.

주소 공간 개념
------
　여러 프로그램들을 동시에 메모리에 적재하고 서로 간섭 없이 실행하기 위해서는 **보호(protection)**와 **재배치(relocation)** 방법이 제공되어야 한다. IBM360에서는 메모리 공간마다 보호 키를 연결하고 프로세스가 메모리를 접근할 때 키를 비교하는 벙법으로 보호를 제공한다. 한편, 이것만으로는 재배치를 제공하지 못하기 때문에 프로그램을 적재할 때 프로그램이 참조하는 주소를 직접 바꾸는 방법으로 재배치를 제공하였다. 하지만 이 방법은 느리고 복잡하다.<br/>
　보호와 재배치를 제공하는 더 효과적인 방법은 **주소 공간(address space)**이라는 새로운 메모리 추상화를 제공하는 것이다. 주소 공간이란 프로세스가 메모리를 접근할 때 사용하는 주소들의 집합으로 각 프로세스는 자신만의 주소 공간을 갖는다. 한 프로세스가 갖는 주소 공간은 다른 프로세스가 갖는 주소 공간과 독립되어 있다. 각 프로세스들에게 서로 다른 주소 공간을 제공해야 하는데, 한 프로그램에서 사용하는 28 주소가 다른 프로그램에서 사용하는 28 주소와는 서로 다른 물리 주소를 가리키도록 해야한다.<br/>
**Base와 Limit 레지스터**<br/>
　각 프로세스의 주소 공간을 물리 메모리의 서로 다른 주소 공간으로 연속적으로 매핑하는 방법은 **동적 재배치(dynamic relocation)** 방법 중의 한가지로 상당히 단순하다. 이 방법을 위해 CPU는 **base**와 **limit**이라는 이름의 특별한 하드웨어 레지스터를 사용한다. 프로그램이 실행될 때 base 레지스터에 프로그램이 적재된 메모리 시작 위치가, limit 레지스터에 프로그램의 크기가 저장된다. 예를 들어, 첫 번째 프로그램이 실행될 때 base와 limit에는 각각 0과 16,384가 저장되며, 두 번째 프로그램에는 16,384와 16.384가 저장된다.<br/>
　프로세스가 명령어 반입이나 데이터를 읽고 쓰기 위해 메모리를 참조하면 CPU 하드웨어는 자동으로 프로세스가 참조하려는 메모리 주소에 base 레지스터 값을 더한다. 또한 프로세스가 참조하려는 주소가 limit 레지스터의 값과 동일한지 혹은 큰지를 확인한다. 만일 그렇다면 메모리 참조는 중단되고 결함(fault)이 발생한다. 아니라면 더한 값을 참조하려는 메모리 주소 값을 메모리 버스에 보낸다.<br/>
　Base와 limit 레지스터는 각 프로세스에게 자신 고유의 주소 공간을 제공하는 간단한 방법을 지원한다. 참조되는 모든 메모리 주소는 명령이 접근하려는 주소와 base 레지스터에 기록된 값이 더해진 값이 되며 이것은 하드웨어에 의해 자동으로 계산된다. 많은 구현에서 base와 limit 레지스터는 오직 운영체제만 변경할 수 있도록 보호된다.<br/>
　Base와 limit 레지스터를 사용하는 재배치의 단점은 모든 메모리 참조마다 덧셈과 비교 연산이 요구 된다는 것이다. 비교 연산은 상대적으로 빠르게 처리될 수 있지만 덧셈은 특별한 하드웨어 로직을 사용하지 않으면 캐리 전파 때문에 시간이 많이 걸린다.<br/>

스와핑
------
　지금까지는 시스템에 존재하는 물리 메모리의 용량이 모든 프로세스를 적재할 만큼 충분히 많은 경우에 대한 경우를 보았다. 하지만 실제 시스템에서 모든 프로세스들이 필요로 하는 메모리의 전체 크기는 시스템에 존재하는 실제의 RAM 용량보다 크다. 이러한 문제를 해결하기 위한 방법으로 **스와핑(swapping)**과 **가상 메모리(virtual memory)**가 제안되었다. 스와핑은 한 프로세스의 모든 이미지가 메모리로 적재되어 실행되다가 더 이상 실행되지 않을 경우 다시 디스크로 내려 보내는 방법이다. 따라서 현재 실행되고 있지 않은 프로세스는 메모리를 차지하지 않고 디스크에 존재하게 된다. 주기적으로 깨어나 실행하고 다시 수면에 빠지는 프로세스들은 메모리의 상태에 따라 계속 메모리에 존재할 수도 있고, 또는 실행 중일 때만 메모리에 존재하고 수면에 들어가면 다시 스와핑 될 수도 있다. 가상 메모리는 한 프로세스의 전체 이미지가 아닌 일부만 메모리에 있어도 그 프로세스의 실행이 가능하다.<br/>
　다음은 스와핑 시스템의 동작을 에시한 것이다.<br/>
<p align="center"><img src="/assets/img/Operating-Systems/3장-메모리-관리/2-1.png" width="600"></p>

　초기에는 메모리에 프로세스 A만 존재한다. 그러다가 프로세스 B와 C가 새로 생성 되었거나 디스크에서 스왑 인(swap in) 되었다. (d)는 프로세스 A가 스왑 아웃(swap out) 된 것을 보여주며, 그 이후에 프로세스 D가 적재 죄었고, 프로세스 B가 스왑 아웃되었다. 마지막으로 프로세스 A가 스왑 인 되었다. 마지막 상태에서 프로세스 A의 메모리 위치가 바뀌었기 때문에 재배치가 필요하다. 재배치는 스왑 인 될 때 소프트웨어적으로 실행될 수도 있으며, 또는 프로그램이 실행될 때 하드웨어적으로 실행될 수도 있다.<br/>
　스와핑 결과 메모리에 여러 개의 분리된 빈 공간들이 만들어지며 프로세스들의 위치를 이동하여 빈 공간들을 모아 하나의 큰 공간으로 합칠 수 있다. 이것을 **메모리 조각모음(memory compaction)**이라고 한다. 메모리 조각모음은 시간이 많이 걸리는 작업이기 때문에 자주 실행되지는 않는다.<br/>
　만약 프로세스의 크기가 실행 중에 증가할 것으로 예상된다면 프로세스가 생성되거나 스왑 인 될 때 여분의 빈 공간을 더 할당해 주는 것도 좋은 생각이다. 이것은 프로세스의 크기 증가에 따라 프로세스를 이동시키거나 다른 프로세스들을 스왑 아웃 시키는 부하를 줄일 수 있다. 다음 (a)는 공간 확장을 고려하여 두 프로세스에게 여분의 공간을 더 할당한 예를 보여준다.<br/>
<p align="center"><img src="/assets/img/Operating-Systems/3장-메모리-관리/2-2.png" width="600"></p>

　(b)
