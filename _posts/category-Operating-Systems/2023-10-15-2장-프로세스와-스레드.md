---
title: "2장 프로세스와 스레드"
excerpt: "운영체제가 어떻게 설계되고 구성되었는지에 대한 구체적인 사항들을 살펴본다. 어떤 운영체제든 가장 중요한 개념은 프로세스이다. 프로세스가 무엇인지를 완벽하게 이해하는 것은 운영체제 설계자에게 매우 중요하다."

wirter: Myeongwoo Yoon
categories:
  - Operating Systems
tags:
  - Programing

toc: true
toc_sticky: true
 
date: 2023-10-15
last_modified_at: 2023-10-15
---

프로세스
======
**프로세스(Process)**는 모든 운영체제에서 핵심 개념이다. 프로세스는 간단히 말해 실행하고 있는 프로그램이다 각 프로세스는 프로세스가 읽고 쓸 수 있는 0에서 특정 최대 값에 이르는 메모리 주소를 일컫는 **주소공간(address space)**(core image)과 프로세스를 다시 시작할 수 있도록 해 주는 레지스터의 내용 등을 담고 있는 프로세스 테이블 엔트리(process table entry)들로 구성된다.

프로세스 모델
------
　하나의 프로세스는 실행중인 프로그램으로서 프로그램 카운터의 현재 값, 레지스터, 그리고 변수들을 포함한다. CPU는 다수의 프로세스 사이를 전환하고 있다. 프로그램 사이를 빨리 전환하는 것을 **다중프로그래밍(multiprogramming)**이라고 부른다.<br/>
<p align="center"><img src="/assets/img/Operating-Systems/2장-프로세스와-스레드/2-1-1.png" width="600"></p>

　(a)는 메모리에 있는 네 개의 프로그램을 다중프로그래밍 형태로 수행하는 컴퓨터를 보여준다. (b)에서는 네 개의 프로그램을 볼 수 있는데, 각각은 자신만의 실행의 흐름을 가지며 또한 다른 프로그램과 독립적으로 수행된다. (c)에서 충분히 긴 시간 간격을 두고 보면 모든 프로세스가 모두 진행 중이지만 어떤 한 순간을 보면 단 하나의 프로세스만 실제로 수행 중임을 알 수 있다.<br/>
　프로세스는 어떤 종류의 행위이다. 프로세스는 프로그램, 입력, 출력 그리고 상태를 갖는다. 하나의 처리기(processor)는 다수의 프로세스들 간에 공유될 수 있으며 스케줄링 알고리즘이 언제 프로세스의 작업을 멈추고 다른 프로세스를 서비스 해야 할 지를 결정한다.

프로세스 상태
------
　다음 상태도는 프로세스가 가질 수 있는 세가지 상태를 보여준다.<br/>
<p align="center"><img src="/assets/img/Operating-Systems/2장-프로세스와-스레드/2-1-2.png" width="500"></p>

* 실행(Running): 이 순간 실제로 CPU를 사용하고 있음
* 준비(Ready): 실행 가능하지만 다른 프로세스가 실행할 수 있도록 일시적으로 정지
* 대기(Blocked): 외부 이벤트가 발생할 때까지 실행할 수 없음

　위 그림에서 세 가지 상태 사이에 네 가지 상태 전이가 가능하다. 상태 전이 1은 어떤 프로세스가 수행을 지속할 수 없음을 운영체제가 발견한 경우이다. 몇몇 시스템의 경우 스스로 대기 상태가 되기 위해 프로세스는 pause와 같은 시스템 호출을 부를 수 있다. 또한 프로세스가 파이프나 특별한 파일로부터 읽으려고 하는데 입력이 주어지지 않은 경우 프로세스는 자동적으로 대기 상태가 된다.<br/>
　상태 전이 2와 3은 프로세스 지신은 이러한 상태 전이에 대해 모르는 상태에서 운영체제의 일부분인 프로세스 스케줄러에 의해 야기된다. 상태 전이 2는 스케줄러가 현재 수행중인 프로세스가 충분이 오랫동안 수행되었으며 이제 다른 프로세스애개 CPU 시간을 할당해야 한다고 결정했을 때 발생한다. 상태 전이 3은 다른 모든 프로세스가 공평하게 자신의 몫을 받았으며 이제 다시 처음 프로세스가 CPU를 할당 받아야 한다고 스케줄러가 결정했을 때 발생한다.<br/>
　상태 전이 4는 프로세스가 기다리던(입력이 주어지는 것과 같은) 외부 인벤트가 발생했을 때 생간다. 만약 그 순간 수행중인 다른 프로세스가 없다면 다시 상태 전이 3이 발생하고 해당 프로세스는 실행을 시작한다. 수행중인 다른 프로세스가 존재하면 이 프로세스는 자신의 순번이 되어서 CPU가 이용 가능해질 때까지 준비 상태에서 기다려야 할 것이다.<br/>
<p align="center"><img src="/assets/img/Operating-Systems/2장-프로세스와-스레드/2-1-3.png" width="400"></p>

　위 그림에서 운영체제의 가장 하위 계층은 스케줄러이며 그 위에 다수의 프로세서들이 존재한다. 모든 인터럽트처리와 실제 프로세스를 시작하고 중단하는 세부 사항은 실제로는 많지 않은 코드로 작성된 스케줄러라 불리는 것에의해 감추어진다. 운영체제의 나머지 부분은 프로세스 형태에 따라 아주 잘 구조화될 수 있다. 그러나 실제 시스템의 경우 이와 같이 잘 구조화되지는 않는다.

프로세스의 주소공간
------
　프로세스는 메모리를 **텍스트 세그먼트(text segments)**(프로그램 코드), **데이터 세그먼트(data segments)**(변수), **스택 세그먼트(stack segments)**라는 세 개의 세그먼트로 나눈다. 다음 그림에서처럼 데이터 시그먼트는 위로 자라고 스택은 아래로 자란다.<br/>
<p align="center"><img src="/assets/img/Operating-Systems/2장-프로세스와-스레드/2-1-4.png" width="300"></p>

　이들 사이에는 사용되지 않는 주소공간이 존재한다. 스택은 필요에 따라 이 공간 안으로 자동적으로 증가한다. 

프로세스 계층
------
　몇몇 시스템에서는 프로세스가 다른 프로세스를 생성하면 **부모 프로세스(parent process)**와 **자식 프로세스(child process)**는 특별한 방식으로 관계를 지속한다. 자식 프로세스 역시 다른 프로세스들을 생성하여 프로세스 계층 구조를 형성할 수 있다. 프로세스는 단 한 명의 부모만 가지고 있음을 주의해야 한다.<br/>
　한 프로세스가 하나 이상의 다른 프로세스를 생성할 수 있고, 이어 이 프로세스들이 또 다시 자식 프로세스를 생성할 수 있다면 다음과 같은 프로세스 트리 구조를 만들어 낼 수 있다.<br/>
<p align="center"><img src="/assets/img/Operating-Systems/2장-프로세스와-스레드/2-1-5.png" width="300"></p>

　프로세스 A가 두 개의 자식 프로세스 B와 C를 생성했다. 프로세스 B가 세 개의 자식 프로세스 D,E,F를 생성했다.<br/>
　UNIX에서 프로세스와 그 자식들 그리고 그들의 후손들은 모두 프로세스 그룹을 형성한다. 이와 대조적으로 Windows는 프로세스 계층 구조라는 개념을 가지고 있지 않다. 모든 프로세스는 동등하다.

보호
------
　시스템 관리자는 시스템을 사용할 권한이 있는 각 사용자에게 **UID(User IDentification)**를 부여한다. 각 프로세스는 그 프로세스를 시작한 사람의 UID를 갖게된다. 자식 프로세스 역시 부모 프로세스의 UID를 갖는다. 사용자들은 특정 그룹의 멤버일 수 있는데 각 그룹은 **GID(Group IDentification)**를 갖는다.<br/>
　UNIX에서 **슈퍼유저(superuser)**라는 UID는 특별한 능력을 갖고 있어 보호에 관한 각종 규정들을 어길 수도 있다. 많은 시스템들을 갖춘 대형 시설에서 슈퍼유저 패스워드를 아는 사람은 시스템 관리자 한 명뿐이다. 그러나 패스워드 없이도 슈퍼유저가 되려고 시스템의 문제점들을 찾기 위해 상당한 시간을 헌신하는 일반 사용자들도 상당히 많다.

프로세스의 구현
------
　프로세스 모델을 구현하기 위해서 운영체제는 **프로세스 테이블(process table)(프로세스 제어 블록(process control block))**이라 불리는 각 프로세스마다 하나의 엔트리가 존재하는 테이블을 유지한다.<br/>
　엔트리는 프로세스 상태에 대한 중요한 정보들을 가지는데 이러한 정보로는 프로그램 카운터, 스택 포인터, 메모리 할당, 열린 파일들의 상태, 과금 및 스케줄링 정보, 기타 프로세스가 실행 상태에서 준비 또는 대기 상태로 전환될 때 저장되어야 할 프로세스에 대한 모든 정보를 포함하며 이들을 저장해야 프로세스는 마치 중단된 적이 없던 것처럼 나중에 재시작 할 수 있다. 다음 그림은 일반적인 시스템에서 볼 수 있는 핵심 필드들을 보여준다.<br/>
<p align="center"><img src="/assets/img/Operating-Systems/2장-프로세스와-스레드/2-1-6.png" width="600"></p>

　첫 번째 열에있는 필드들은 프로세스 관리와 관계된 것이다. 다른 두 열은 각각 메모리 관리와 파일 관리와 관계된 것들이다.

프로세스 생성
------
　새로운 프로세스는 기존 프로세스가 프로세스 생성 시스템 호출을 실행해야만 생성할 수 있다. 다음은 프로세스의 생성을 유발하는 네 가지 주요 이벤트들이다.
* 시스템 초기화
  - 데몬(Daemon): 후위에 머물면서 전자 우편, 웹 페이지, 뉴스, 인쇄, 기타 등등의 작업을 담당하는 프로세스
* 실행중인 프로세스가 프로세스 생성 시스템 호출을 부르는 경우
  - fork 시스템 호출(fork system call)
* 사용자가 새로운 프로세스를 생성하도록 요청하는 경우
  - 명령어를 입력하거나 또는 아이콘을 클릭하여 수행할 수 있다.
* 배치 작업이 시작
  - 거대한 메인프레임 컴퓨터에서 볼 수 있는 배치 시스템에서만 관찰된다.

프로세스 종료
------
　다음은 프로세스가 종료되는 조건들이다.
* 정상적인 종료(자발적)
  - 대부분의 프로세스는 자신의 작업을 완료했기 때문에 종료한다.
* 요류 종료(자발적)
  - 프로세스가 치명적인 오류를 발견한 경우
* 치명적인 오류(비자발적)
  - 종종 프로그램의 버그때문에 발생한다.
  - 잘못된 명령어 실행, 존재하지 않는 메모리 접근, 0으로 나누기 등
* 다른 프로세스에 의해 종료(비자발적)
  - kill: 어떤 프로세스가 시스템 호출을 실행하여 운영체제에게 다른 프로세스를 종료시켜 줄 것을 요청하는 경우

프로세스 관리를 위한 시스템 호출
------
* 프로세스 생성/종료
* 자신의 전 코어 이미지를 자기의 첫 인자에 의해 명시된 파일로 완전히 대체하는 함수
* 자식이 종료되기만을 기다리는 명령
* 더 많은 메모리를 요구/사용하지 않은 메모리를 반납

　다음은 fork, waitpid, execve를 사용하는 아주 단순한 쉘이다.
```cpp
#define TRUE 1

while (TRUE) {                        /* repeat forever */
  type_promt();                       /* display prompt on the screen */
  read_command(command, parameters);  /* read input from terminal */

  if(fork()!=0) {                     /* fork off child process */
    /* Parent code */
    waitpid(-1, &status, 0);          /* wait for child to exit */
  } else {
    /* Child code */
    execve(command, parameters, 0);   /* execute command */
  }
}
```
　프로세스를 생성할 수 있는 방법은 **fork** 시스템 호출 뿐이다. fork 호출에는 반환 값이 있는데 자식의 경우 0이고 부모의 경우 자식 프로세스의 식별자 또는 PID가 된다. **waitpid**는 특정 자식을 기다릴 수도 있고, 첫 인자를 -1로 설정하면 자식들 중에 임의의 하나를 기다리게 된다. waitpid가 종료되면 둘째 인자 statloc가 가리키는 주소에는 자식의 exit상태가 들어가게 된다. 셋째 인자에 의해 각종 옵션들을 설정할 수 있다. **execve**시스템 호출은 자신의 전 코어 이미지를 자기의 첫인자에 의해 명시된 파일로 완전히 대체하는 함수이다. execve는 세 개의 인자를 갖는데 각각 실행시킬 파일의 이름, 인자 배열을 가리키는 포인터, 환경 배열을 가리키는 포인터이다. 데이터 세그먼트의 확장은 **brk**라는 시스템 호출을 통해서 명시적으로 이루어진다. 이 시스템 호출은 데이터 세그먼트가 끝나는 새로운 주소를 명시하고 동적으로 할당 받을 때는 malloc 라이브러리 함수를 사용하도록 권장하고 있다.

인터럽트 처리
------
　다음은 인터럽트가 발생할 때 운영체제의 가장 하위 레벨에서 수행하는 작업이다.<br/>
<p align="center"><img src="/assets/img/Operating-Systems/2장-프로세스와-스레드/2-1-7.png" width="500"></p>

스레드
======



프로세스간 통신
======




스케줄링
======


