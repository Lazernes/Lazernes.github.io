---
title: "2장 프로세스와 스레드"
excerpt: "운영체제가 어떻게 설계되고 구성되었는지에 대한 구체적인 사항들을 살펴본다. 어떤 운영체제든 가장 중요한 개념은 프로세스이다. 프로세스가 무엇인지를 완벽하게 이해하는 것은 운영체제 설계자에게 매우 중요하다."

wirter: Myeongwoo Yoon
categories:
  - Operating Systems
tags:
  - Programing

use_math: true
toc: true
toc_sticky: true
 
date: 2023-10-15
last_modified_at: 2023-10-22
---

프로세스
======
**프로세스(Process)**는 모든 운영체제에서 핵심 개념이다. 프로세스는 간단히 말해 실행하고 있는 프로그램이다 각 프로세스는 프로세스가 읽고 쓸 수 있는 0에서 특정 최대 값에 이르는 메모리 주소를 일컫는 **주소공간(address space)**(core image)과 프로세스를 다시 시작할 수 있도록 해 주는 레지스터의 내용 등을 담고 있는 프로세스 테이블 엔트리(process table entry)들로 구성된다.

프로세스 모델
------
　하나의 프로세스는 실행중인 프로그램으로서 프로그램 카운터의 현재 값, 레지스터, 그리고 변수들을 포함한다. CPU는 다수의 프로세스 사이를 전환하고 있다. 프로그램 사이를 빨리 전환하는 것을 **다중프로그래밍(multiprogramming)**이라고 부른다.<br/>
<p align="center"><img src="/assets/img/Operating-Systems/2장-프로세스와-스레드/2-1-1.png" width="600"></p>

　(a)는 메모리에 있는 네 개의 프로그램을 다중프로그래밍 형태로 수행하는 컴퓨터를 보여준다. (b)에서는 네 개의 프로그램을 볼 수 있는데, 각각은 자신만의 실행의 흐름을 가지며 또한 다른 프로그램과 독립적으로 수행된다. (c)에서 충분히 긴 시간 간격을 두고 보면 모든 프로세스가 모두 진행 중이지만 어떤 한 순간을 보면 단 하나의 프로세스만 실제로 수행 중임을 알 수 있다.<br/>
　프로세스는 어떤 종류의 행위이다. 프로세스는 프로그램, 입력, 출력 그리고 상태를 갖는다. 하나의 처리기(processor)는 다수의 프로세스들 간에 공유될 수 있으며 스케줄링 알고리즘이 언제 프로세스의 작업을 멈추고 다른 프로세스를 서비스 해야 할 지를 결정한다.

프로세스 상태
------
　다음 상태도는 프로세스가 가질 수 있는 세가지 상태를 보여준다.<br/>
<p align="center"><img src="/assets/img/Operating-Systems/2장-프로세스와-스레드/2-1-2.png" width="500"></p>

* 실행(Running): 이 순간 실제로 CPU를 사용하고 있음
* 준비(Ready): 실행 가능하지만 다른 프로세스가 실행할 수 있도록 일시적으로 정지
* 대기(Blocked): 외부 이벤트가 발생할 때까지 실행할 수 없음

　위 그림에서 세 가지 상태 사이에 네 가지 상태 전이가 가능하다. 상태 전이 1은 어떤 프로세스가 수행을 지속할 수 없음을 운영체제가 발견한 경우이다. 몇몇 시스템의 경우 스스로 대기 상태가 되기 위해 프로세스는 pause와 같은 시스템 호출을 부를 수 있다. 또한 프로세스가 파이프나 특별한 파일로부터 읽으려고 하는데 입력이 주어지지 않은 경우 프로세스는 자동적으로 대기 상태가 된다.<br/>
　상태 전이 2와 3은 프로세스 지신은 이러한 상태 전이에 대해 모르는 상태에서 운영체제의 일부분인 프로세스 스케줄러에 의해 야기된다. 상태 전이 2는 스케줄러가 현재 수행중인 프로세스가 충분이 오랫동안 수행되었으며 이제 다른 프로세스애개 CPU 시간을 할당해야 한다고 결정했을 때 발생한다. 상태 전이 3은 다른 모든 프로세스가 공평하게 자신의 몫을 받았으며 이제 다시 처음 프로세스가 CPU를 할당 받아야 한다고 스케줄러가 결정했을 때 발생한다.<br/>
　상태 전이 4는 프로세스가 기다리던(입력이 주어지는 것과 같은) 외부 인벤트가 발생했을 때 생간다. 만약 그 순간 수행중인 다른 프로세스가 없다면 다시 상태 전이 3이 발생하고 해당 프로세스는 실행을 시작한다. 수행중인 다른 프로세스가 존재하면 이 프로세스는 자신의 순번이 되어서 CPU가 이용 가능해질 때까지 준비 상태에서 기다려야 할 것이다.<br/>
<p align="center"><img src="/assets/img/Operating-Systems/2장-프로세스와-스레드/2-1-3.png" width="400"></p>

　위 그림에서 운영체제의 가장 하위 계층은 스케줄러이며 그 위에 다수의 프로세서들이 존재한다. 모든 인터럽트처리와 실제 프로세스를 시작하고 중단하는 세부 사항은 실제로는 많지 않은 코드로 작성된 스케줄러라 불리는 것에의해 감추어진다. 운영체제의 나머지 부분은 프로세스 형태에 따라 아주 잘 구조화될 수 있다. 그러나 실제 시스템의 경우 이와 같이 잘 구조화되지는 않는다.

프로세스의 주소공간
------
　프로세스는 메모리를 **텍스트 세그먼트(text segments)**(프로그램 코드), **데이터 세그먼트(data segments)**(변수), **스택 세그먼트(stack segments)**라는 세 개의 세그먼트로 나눈다. 다음 그림에서처럼 데이터 시그먼트는 위로 자라고 스택은 아래로 자란다.<br/>
<p align="center"><img src="/assets/img/Operating-Systems/2장-프로세스와-스레드/2-1-4.png" width="300"></p>

　이들 사이에는 사용되지 않는 주소공간이 존재한다. 스택은 필요에 따라 이 공간 안으로 자동적으로 증가한다. 

프로세스 계층
------
　몇몇 시스템에서는 프로세스가 다른 프로세스를 생성하면 **부모 프로세스(parent process)**와 **자식 프로세스(child process)**는 특별한 방식으로 관계를 지속한다. 자식 프로세스 역시 다른 프로세스들을 생성하여 프로세스 계층 구조를 형성할 수 있다. 프로세스는 단 한 명의 부모만 가지고 있음을 주의해야 한다.<br/>
　한 프로세스가 하나 이상의 다른 프로세스를 생성할 수 있고, 이어 이 프로세스들이 또 다시 자식 프로세스를 생성할 수 있다면 다음과 같은 프로세스 트리 구조를 만들어 낼 수 있다.<br/>
<p align="center"><img src="/assets/img/Operating-Systems/2장-프로세스와-스레드/2-1-5.png" width="300"></p>

　프로세스 A가 두 개의 자식 프로세스 B와 C를 생성했다. 프로세스 B가 세 개의 자식 프로세스 D,E,F를 생성했다.<br/>
　UNIX에서 프로세스와 그 자식들 그리고 그들의 후손들은 모두 프로세스 그룹을 형성한다. 이와 대조적으로 Windows는 프로세스 계층 구조라는 개념을 가지고 있지 않다. 모든 프로세스는 동등하다.

보호
------
　시스템 관리자는 시스템을 사용할 권한이 있는 각 사용자에게 **UID(User IDentification)**를 부여한다. 각 프로세스는 그 프로세스를 시작한 사람의 UID를 갖게된다. 자식 프로세스 역시 부모 프로세스의 UID를 갖는다. 사용자들은 특정 그룹의 멤버일 수 있는데 각 그룹은 **GID(Group IDentification)**를 갖는다.<br/>
　UNIX에서 **슈퍼유저(superuser)**라는 UID는 특별한 능력을 갖고 있어 보호에 관한 각종 규정들을 어길 수도 있다. 많은 시스템들을 갖춘 대형 시설에서 슈퍼유저 패스워드를 아는 사람은 시스템 관리자 한 명뿐이다. 그러나 패스워드 없이도 슈퍼유저가 되려고 시스템의 문제점들을 찾기 위해 상당한 시간을 헌신하는 일반 사용자들도 상당히 많다.

프로세스의 구현
------
　프로세스 모델을 구현하기 위해서 운영체제는 **프로세스 테이블(process table)(프로세스 제어 블록(process control block))**이라 불리는 각 프로세스마다 하나의 엔트리가 존재하는 테이블을 유지한다.<br/>
　엔트리는 프로세스 상태에 대한 중요한 정보들을 가지는데 이러한 정보로는 프로그램 카운터, 스택 포인터, 메모리 할당, 열린 파일들의 상태, 과금 및 스케줄링 정보, 기타 프로세스가 실행 상태에서 준비 또는 대기 상태로 전환될 때 저장되어야 할 프로세스에 대한 모든 정보를 포함하며 이들을 저장해야 프로세스는 마치 중단된 적이 없던 것처럼 나중에 재시작 할 수 있다. 다음 그림은 일반적인 시스템에서 볼 수 있는 핵심 필드들을 보여준다.<br/>
<p align="center"><img src="/assets/img/Operating-Systems/2장-프로세스와-스레드/2-1-6.png" width="600"></p>

　첫 번째 열에있는 필드들은 프로세스 관리와 관계된 것이다. 다른 두 열은 각각 메모리 관리와 파일 관리와 관계된 것들이다.

프로세스 생성
------
　새로운 프로세스는 기존 프로세스가 프로세스 생성 시스템 호출을 실행해야만 생성할 수 있다. 다음은 프로세스의 생성을 유발하는 네 가지 주요 이벤트들이다.
* 시스템 초기화
  - 데몬(Daemon): 후위에 머물면서 전자 우편, 웹 페이지, 뉴스, 인쇄, 기타 등등의 작업을 담당하는 프로세스
* 실행중인 프로세스가 프로세스 생성 시스템 호출을 부르는 경우
  - fork 시스템 호출(fork system call)
* 사용자가 새로운 프로세스를 생성하도록 요청하는 경우
  - 명령어를 입력하거나 또는 아이콘을 클릭하여 수행할 수 있다.
* 배치 작업이 시작
  - 거대한 메인프레임 컴퓨터에서 볼 수 있는 배치 시스템에서만 관찰된다.

프로세스 종료
------
　다음은 프로세스가 종료되는 조건들이다.
* 정상적인 종료(자발적)
  - 대부분의 프로세스는 자신의 작업을 완료했기 때문에 종료한다.
* 요류 종료(자발적)
  - 프로세스가 치명적인 오류를 발견한 경우
* 치명적인 오류(비자발적)
  - 종종 프로그램의 버그때문에 발생한다.
  - 잘못된 명령어 실행, 존재하지 않는 메모리 접근, 0으로 나누기 등
* 다른 프로세스에 의해 종료(비자발적)
  - kill: 어떤 프로세스가 시스템 호출을 실행하여 운영체제에게 다른 프로세스를 종료시켜 줄 것을 요청하는 경우

프로세스 관리를 위한 시스템 호출
------
* 프로세스 생성/종료
* 자신의 전 코어 이미지를 자기의 첫 인자에 의해 명시된 파일로 완전히 대체하는 함수
* 자식이 종료되기만을 기다리는 명령
* 더 많은 메모리를 요구/사용하지 않은 메모리를 반납

　다음은 fork, waitpid, execve를 사용하는 아주 단순한 쉘이다.
```cpp
#define TRUE 1

while (TRUE) {                        /* repeat forever */
  type_promt();                       /* display prompt on the screen */
  read_command(command, parameters);  /* read input from terminal */

  if(fork()!=0) {                     /* fork off child process */
    /* Parent code */
    waitpid(-1, &status, 0);          /* wait for child to exit */
  } else {
    /* Child code */
    execve(command, parameters, 0);   /* execute command */
  }
}
```
　프로세스를 생성할 수 있는 방법은 **fork** 시스템 호출 뿐이다. fork 호출에는 반환 값이 있는데 자식의 경우 0이고 부모의 경우 자식 프로세스의 식별자 또는 PID가 된다. **waitpid**는 특정 자식을 기다릴 수도 있고, 첫 인자를 -1로 설정하면 자식들 중에 임의의 하나를 기다리게 된다. waitpid가 종료되면 둘째 인자 statloc가 가리키는 주소에는 자식의 exit상태가 들어가게 된다. 셋째 인자에 의해 각종 옵션들을 설정할 수 있다. **execve**시스템 호출은 자신의 전 코어 이미지를 자기의 첫인자에 의해 명시된 파일로 완전히 대체하는 함수이다. execve는 세 개의 인자를 갖는데 각각 실행시킬 파일의 이름, 인자 배열을 가리키는 포인터, 환경 배열을 가리키는 포인터이다. 데이터 세그먼트의 확장은 **brk**라는 시스템 호출을 통해서 명시적으로 이루어진다. 이 시스템 호출은 데이터 세그먼트가 끝나는 새로운 주소를 명시하고 동적으로 할당 받을 때는 malloc 라이브러리 함수를 사용하도록 권장하고 있다.

인터럽트 처리
------
　다음은 인터럽트가 발생할 때 운영체제의 가장 하위 레벨에서 수행하는 작업이다.<br/>
<p align="center"><img src="/assets/img/Operating-Systems/2장-프로세스와-스레드/2-1-7.png" width="500"></p>

프로세스간 통신
======
　프로세스는 종종 다른 프로세스와 통신할 필요가 있다. **프로세스간 통신(InterProcessCommunication, IPC)**에는 세 개의 쟁점이 있다.
* 어떻게 프로세스가 다른 프로세스에게 정보를 정달하는가 이다.
  - 예를 들면 쉘의 파이프라인에서 첫 번째 프로세스의 출력은 두 번째 프로세스에게 전달되어야 한다.
* 둘 또는 그 이상의 프로세스가 서로 상대방을 방해하지 않도록 하는 것과 관련이 있다.
  - 예를 들면 항공 예약 시스템에서 두 프로세스가 서로 다른 손님을 위해 마직막 남은 좌석으 배정하기 위해 시도할 때 방생하는 것이다.
* 종속성(dependency)이 존재할 때 적정한 순서를 정하는 것이다.
  - 예를 들면 프로세스 A가 데이터를 생성하고 프로세스 B가 이를 프린트한다면 B는 프린트를 시작하기 전에 A가 데이터를 생성할 때까지 기다려야 한다.

경쟁 조건(Race conditions)
------
　몇몇 운영체제에서 협력하는 프로세스들은 종종 각 프로세스가 일고 쓸 수 있는 저장공간을 공유한다. 실질적으로 프로세스간 통신이 어떨게 작동하는지 살펴보기 위해 **프린트 스풀러(print spooler)**라는 간단하지만 일반적인 예제를 살펴보자. 프로세스가 파일을 프린트하고 싶으면 특별한 스풀러 디렉터리에 파일 이름을 기입한다. **프린터 데몬**이라는 다른 프로세스는 주기적으로 프린트할 파일이 있는지 검사하며, 있으면 이를 프린트 하고 이를 디렉터리에서 지운다.<br/>
<p align="center"><img src="/assets/img/Operating-Systems/2장-프로세스와-스레드/2-2-1.jpg" width="500"></p>

　스풀러 디렉터리는 0, 1, 2, ...와 같이 번호로 색인되며 이름을 저장하는 다수의 슬롯(slot)을 가지고 있다. Out과 in 두 개의 공유 변수가 있다고 하자. Out은 프린트할 다음 파일을 가리키고 in은 디렉터리에서 다음 번 빈 슬롯을 가리킨다. 이 두 변수는 두 개의 워드로 구성된 파일에 존재하며 모든 프로세스가 이 파일에 접근할 수 있다. 위 그림은 어느 순간 슬롯 0에서부터 3까지 비어있고 (파일들이 이미 프린트 되었고) 슬롯 4에서 6까지 사용 중이다 (프린트할 파일 이름이 대기중이다).<br/>
　다음과 같은 상황을 보자.
* 플로세스 A가 in을 읽고 지역 변수 next_free_slot에 7 값을 적는다. 이 때 클록 인터럽트가 발생하고 프로세스 A가 충분히 오래 실행되었으므로 CPU는 이제 프로세스 B로 문맥교환 한다. 프로세스 B 역시 in을 읽고 7값을 적는다. 그리고 이 값을 역시 자신의 next_free_slot 변수(A의 next_free_slot 과 다름)에 저장한다. 이 순간 두 프로세스는 모두 다음 번 이용 가능한 슬롯이 7이라고 생각한다.
* 프로세스 B는 계속해서 수행하면서 자신의 파일 이름을 슬롯 7에 저장하고 in을 8로 변경한다.
* 프로세스 A가 다시 수행하여 문맥교환 직전에 실행하던 위치부터 다시 실행한다. 프로세스는 next_free_slot을 살펴보고 7값을 발견하여 자신의 파일 이름을 슬롯 7에 기록하는데, 이 때 프로세스 B가 기록했던 파일 이름이 지워진다. 그리고 next_free_slot + 1을 계산하여 in에 8을 기록한다. 스풀러 디렉터리는 이제 내부적으로는 일관성이 훼손되지 않는 상태이므로 프린터 데몬은 잘못된 사실을 알지 못한다.그러나 프로세스 B는 자신이 쓴 in값이 없어지므로 자신의 인쇄물을 받을 수 없다.

　둘 또는 그 이상의 프로세스가 공유 데이터를 읽거나 기록하는데 최종 결과는 누가 언제 수행되는가에 따라 달라지는 이러한 상황을 **경쟁조건(race condition)**이라 부른다.

임계구역(Critical Regions)
------
　경쟁조건을 회피하기 위해 공유 메모리, 공유 파일, 그리고 무언가를 공유하는 상황에서 문제를 방지하는 핵심은 둘 이상의 프로세스가 동시에 공유 데이터에 읽기와 쓰기를 수행하지 못하도록 금지하는 방법을 고안하는 것이다. 이를 **상호배제(mutual exclusion)**, 즉 한 프로세스가 공유 변수나 파일을 사용 중이면 다른 프로세스들은 똑같은 일을 수행하지 못하도록 하는 것이다.<br/>
　공유 메모리를 접근하는 프로그램 부분을 **임계구역(critical  region, critical section)**이라 한다. 만약 두 프로세스가 동시에 임계구역에 존재하지 않도록 조절한다면 경쟁조건을 피할 수 있다.<br/>
　비록 이러한 요구 조건이 만족되면 경쟁조건을 피할 수 있지만 병령 프로세스가 정확하게 그리고 효율적으로 공유 데이터를 사용하도록 하기에는 충분하지 않다. 좋은 해결잭은 다음과 같은 네 가지 조건을 모두 만족해야 한다.
* 두 개의 프로세스가 동시에 자기의 임계구역 내에 존재하는 경우는 없어야 한다.
* CPU의 개수나 속도에 대해 어떤 가정도 하지 않는다.
* 임계구역 외부에서 실행하고 있는 프로세스는 다른 프로세스들을 블록시켜서는 안된다.
* 임계구역에 진입하기 위해 무한히 기다리는 프로세스는 없어야 한다.

　추상적인 관념에서 우리가 원하는 동작은 다음과 같다.<br/>
<p align="center"><img src="/assets/img/Operating-Systems/2장-프로세스와-스레드/2-2-2.jpg" width="500"></p>

* 프로세스 A가 시간 $T_1$에 자신의 임계구역에 진입한다. 잠시 후 시간 $T_2$에 프로세스 가 자신의 임계구역에 진입하려고 시도하지만 다른 프로세스가 이미 임계구역에 존재하고 임계구역에는 오직 하나의 프로세스만 존재할 수 있으므로 프로세스 B의 시도는 실패할 것이다.
* B는 A가 지신의 임계구역을 나가는 시간 $T_3$까지 일시적으로 중단되고 A가 나가면 즉시 프로세스 B가 자신의 임계구역에 진입한다.
* 다음으로 B가 시간 $T_4$에 임계구역을 빠져 나가고 자신의 임계구역에 프로세스가 존재하지 않는 원래 상태가 된다.

바쁜 대기를 이용한 상호배제
------
**인터럽트 끄기**<br/>
　단일 처리기 시스템에서 가장 간단한 해결책은 각 프로세스가 임계구역에 진입하자마가 인터럽트를 끄고 임계구역에서 나가기 직전에 인터럽트를 켜도록 하는 것이다. 인터럽트를 끄면 클록 인터럽트가 발생하지 않는다. 이 방법은 일반적으로 매력적이지 못하는데 이는 사용자 프로세스에게 인터럽트를 끌수 있는 권한을 주는 것은 현명하지 못하기 때문이다. 만약 프로세스 중 하나가 인터럽트를 끄고 다시 켜지 않는다면 시스템은 더 이상 동작하지 않는다.<br/>
　반면 커널이 변수나 리스트를 변경하는 단 몇 개의 명령을 수행하는 동안 스스로 인터럽트를 금지시키는 것이 편리할 때가 많다. 결론적으로, 인터럽트 끄기는 운영체제 내부에서 사용할 수 있는 유용한 기법이지만 사용자 프로세스간 상호배제를 위해 일반적으로 사용하기에는 적절하지 않다.<br/>

**락 변수**<br/>
　소프트웨어 해법을 생각해 보자. 0으로 초기화된 단일 공유(락) 변수가 있다고 가정하고 다음 예를 보자.
* 임계구역에 진입하려는 프로세스는 먼저 락을 테스트한다.
* 만약 락이 0이면 프로세스는 이를 1로 설정하고 임계구역에 진입한다.
* 만약 락이 1이면 프로세스는 이 변수가 0이 될 때까지 기다린다.
* 따라서 0 값은 임계구역 내에 어떤 프로세스도 없다는 것을 의미하며 1은 임계구역에 어떤 프로세스가 존재함을 의미한다.

　이 생각은 스풀러 디렉터리에서 보았던 것과 정확히 동일한 결함을 가지고 있다. 한 프로세스가 락을 읽고 이 값이 0임을 알았다고 하자. 프로세스가 락을 1로 설정하기 전에 다른 프로세스가 스케줄되어 실행하면서 락을 1로 설정한다. 다시 첫 번째 프로세스가 실행하면서 락을 1로 설정할 것이며 두 개의 프로세스가 동시에 임계구역에 들어가게 된다.<br/>

**엄격한 교대**<br/>
　상호배제 문제의 기법이 다음과 같이 표시되어있다. (a)는 프로세스 0, (b)는 프로세스 1이다.<br/>
<p align="center"><img src="/assets/img/Operating-Systems/2장-프로세스와-스레드/2-2-3.jpg" width="500"></p>

　초기값이 0인 정수 변수 turn은 임계구역에 진입하여 공유 메모리를 검사하고 변경할 순번을 나타낸다. 최초에 프로세스 0이 turn을 검사하여 이 값이 0임을 발견하면 임계구역에 진입한다. 또한 프로세스 1은 이 값을 검사하여 0임을 발견하고 turn이 1이 되는지를 검사하면서 루프를 돌게 된다. 변수가 특정 값이 될 때까지 계속해서 검사하는 것을 **바쁜 대기(busy waiting)**라 한다. 이것은 CPU 시간을 낭비하므로 바쁜 대기는 일반적으로 피해야 한다. 기다리는 시간이 짧을 것이라고 합리적으로 예상할 수 있는 경우만 바쁜 대기가 사용된다. 바쁜 대기를 사용하는 락을 **스핀 락(spin lock)**이라 부른다.<br/>
　프로세스 0이 임계구역을 떠나면서 turn을 1로 설정하여 프로세스 1이 임계구역에 진입할 수 있도록 한다. 이제 프로세스 1이 재빨리 임계구역 실행을 마치고, turn은 0으로 설정되어, 두 프로세스 모두 임계구역 밖에 있다고 하자. 다시 프로세스 0이 루프를 수행하고 임계구역을 벗어나면서 turn을 1로 설정한다. 이 순간 turn은 1이며 두 프로세스 모두 비임계구역을 수행 중이다.<br/>
　갑자기 프로세스 0이 비임계구역의 수행을 마치고 루프의 맨 윗부분을 실행한다. 불행하게도 이 프로세스는 임계구역 진입이 허가되지 않는데 이는 turn이 1이기 때문이며 이 순간 프로세스 1은 비임계구역을 바쁘게 실행하고 있다. 프로세스 1이 turn을 0으로 바꿀 때까지 프로세스 0은 while 루프에 묶여 있어야 한다. 다르게 표현하면 한 프로세스가 다른 프로세스보다 상당히 느린 경우 교대로 일하는 것은 좋은 생각이 아니다.<br/>
　프로세스 0은 임계구역에 존재하지 않는 다른 프로세스에 의해 블록되므로 이러한 상황은 앞에서 설정한 조건 3을 위반한다. 앞에서 살펴봤던 스풀러 디렉터리 문제에 대입해 보면 스풀러 디렉터리에 읽고 쓰는 동작을 임계구역이라고 할 때, 이 상황은 프로세스 1이 다른 일을 하고 있어서 프로세스 0이 또 다른 파일을 프린트 할 수 없는 것과 같다.<br/>
　이 해법은 두 프로세스가 엄격하게 교대로 임계구역에 진입하는 것을(예를 들어, 교대로 파일을 스풀링할 것을) 요구한다. (어떠한 프로세스도 연속해서 두 개의 파일을 스풀링 할 수 없다.) 이 알고리즘은 비록 경쟁조건을 피할 수는 있지만 조건 3을 위반하므로 진정한 해결책의 후보가 될 수 없다.<br/>

**Peterson의 해법**<br/>
　엄격한 교대를 요구하지 않는 간단한 방법의 상호배제 문제를 당성하는 소프트웨어 해결책을 제시하였다.<br/>
<p align="center"><img src="/assets/img/Operating-Systems/2장-프로세스와-스레드/2-2-4.jpg" width="500"></p>

　공유 변수를 사용하기 전에(즉, 임계구역에 진입하기 직전에) 각 프로세스는 자신의 프로세스 번호 0 또는 1을 인자로 제공하면서 enter_region을 호출한다. 이 호출은 필요한 경우 안전하게 진입할 때 까지 기다리게 할 수도 있다. 임계구역에 진입하여 공유 변수 사용을 마친 후 프로세스는 leave_region을 호출하여 자신의 임계구역 수행 종료와 임계구역 진입을 원하는 다른 프로세스가 진입할 수 있음을 알려준다.<br/>
　이 해법이 어떻게 동작하는지 살펴보자.
* 초기에 어떤 프로세스도 임계구역에 존재하지 않는다. 이때 프로세스 0이 enter_region을 호출하였다. 이 프로세스는 자신의 배열 변수를 설정(interested[0]을 TRUE)하고 turn을 0으로 설정하여 자신이 임계구역에 진입하고 싶어함을 표시한다. 프로세스 1은 임계구역 진입에 관심이 없으므로 enter_region은 즉시 복귀하고 프로세스 0은 임계구역에 진입한다.
* 이제 프로세스 1이 enter_region을 호출하면 프로세스 1은 interested[0]이 FALSE가 될 때까지 기다려야 하며 이러한 변경은 프로세스 0이 임계구역을 나가기 위해 leave_region가 호출할 때 이루어진다.

　이제 두 프로세스가 거의 동시에 enter_region을 호출하는 경우를 보자. 누구의 변수 값 변경이 늦게 수행되었는지가 중요한데 이는 처음 값이 다음 변경에 의해 덮어 쓰여져서 사라지기 때문이다.
* 프로세스 1이 마지막에 변경하여 turn이 1이라고 하자.
* 두 프로세스 모두 while 문장에 도차하면 프로세스 0은 루프를 수행하지 않고 임계구역에 진입한다.
* 프로세스 0이 임계구역을 나올 때 까지 프로세스 1은 루프를 돌면서 임계구역에 진입하지 못한다.
<br/>

**TSL 명령**<br/>
　하드웨어의 도움을 약간 필요로 하는 해결책을 살펴보자. 다중처리기를 염두에 두고 설계된 컴퓨터들은 다음과 같은 명령을 가지고 있다.<br/>
<center> TSL RX(REGISTER), LOCK </center>

　**TSL(Test and SetLock)** 명령은 다음과 같이 작동한다.
* 메모리 워드 LOCK의 값을 읽어 레지스터 RX에 저장하고 메모리 주소 LOCK에 0이 아닌 값을 기록한다. 이 연산이 완료될 때까지 다른 어떤 처리기도 메모리 워드에 접근할 수 없다.
  - TSL 명령을 수행하는 CPU는 수행이 끝날 때까지 메모리 버스를 잠금으로써 다른 어떤 CPU도 메모리에 접근할 수 없도록 한다.
* TSL 명령과 공유 변수 lock을 사용하여 공유 메모리에 대한 접근을 조정할 수 있다.
  - Lock이 0이면 어떤 프로세스도 TSL을 사용하여 이를 1로 설정하고 공유 메모리에 읽기와 쓰기를 수행할 수 있다.
* 작업을 마치면 프로세스는 일반적인 move 명령을 사용하여 lock을 다시 0으로 설정한다.

　두 개의 프로세스가 동시에 임계구역에 진입하는 것을 방지하는 방법은 다음과 같다.<br/>
<p align="center"><img src="/assets/img/Operating-Systems/2장-프로세스와-스레드/2-2-5.jpg" width="500"></p>

　첫 번째 명령은 lock의 (이전) 값을 레지스터로 복사하고 lock을 (새로운 값) 1로 설정한다. 그리고 이전 값이 0인지를 비교한다. 이것이 0이 아니면 lock은 이미 전에 설정되었으며 따라서 프로그램은 서브루틴의 처음으로 돌아가 TSL 명령을 다시 시작한다. 현재 임계구역에 진입한 프로세스가 임계구역 작업을 마치면 lock 값은 0이 되고 이 서브루틴은 lock을 다시 설정하려고하며 락을 자신이 설정하면 복귀한다.<br/>
　임계구역 문제의 해결책은 이제 명확하다. 임계구역에 진입하기 위해서 프로세스는 enter_region을 호출하며 이 루틴은 락이 풀릴 때까지 바쁜 대기를 한 다음 락을 획득하고 복귀한다. 임계구역을 수행한 후 프로세스는 leave_region을 호출하며 이 루틴은 lock에 0을 저장한다. 임계구역의 다른 모든 해법과 마찬가지로 이 기법이 동작하기 위해서는 프로세스가 enter_region과 leave_region을 적절한 시점에 호출해야 한다.

슬립과 깨움
------
　앞의 기법들은 CPU 사간을 낭비할 뿐 아니라 예기치 못한 결과인 **우선순위 역전 문제(priority inversion problem)**이 발생한다.<br/>
　임계 구역 진입이 허용되지 않을 때 CPU 시간을 낭비하는 대신 블록하는 프로세스간 통신 프로미티브를 살펴보자. 가장 간단한 것이 **슬립(sleep)과 깨움(wakeup)**쌍이다. Sleep은 호출자를 블록 상태로 만드는 시스템 호출로 다른 프로세스가 호출자를 꺠워출 떄까지 블록 상태에 머물게 된다. Wakeup 호출은 깨울 프로세스를 가리키는 인자 하나를 가지고 있다.<br/>

**생산자-소비자 문제**<br/>
　두 프로세스가 고정된 크기의 버퍼를 공유한다. 이중 하나는 생산자로 정보를 버퍼에 저장하고 다른 하나는 소비자로 버퍼에서 정보를 꺼내온다.<br/>
　생산자가 새로운 아이템을 버퍼에 넣으려고 하는데 버퍼가 가득 차 있을 때 문제가 발생한다. 해결책은 생산자가 잠들고 소비자가 아이템을 하나 제거할 때 깨워주는 것이다. 마찬가지로 소비자가 아이템을 버퍼에서 가져오려고 하는데 버퍼가 비어 있으면 소비자는 잠들고 생산자가 버퍼에 아이템을 넣을 때 꺠워준다.<br/>
　이 방법은 경쟁조건과 동일한 일이 발생할 수 있다. 버퍼에 존재하는 아이템의 개수를 표시하기 위해 count 변수를 사용한다고 하자. 버퍼에 존재하는 아이템의 최대 개수는 N이고 생산자 코드의 앞부분에서 count가 N인지를 검사한다. 만약 N이면 생산자는 잠들며 그렇지 않으면 생산자는 아이템을 추가하고 count를 증가시킨다.<br/>
　소비자 코드도 유사하다. 먼저 count가 0인지를 검사한다. 0이면 잠들고 0이 아니면 아이템을 제거하고 count를 감소시킨다. 각 프로세스는 또한 다른 프로세스를 깨워야 하는지 검사하여 필요하면 해당 프로세스를 깨운다. 이러한 생산자와 소비자 코드는 다음과 같다.<br/>
<p align="center"><img src="/assets/img/Operating-Systems/2장-프로세스와-스레드/2-2-6.jpg" width="500"></p>

세마포어(Semaphore)
------
　**세마포어(semaphore)**라 부르는 새로운 변수형을 도입한다. 세마포어는 깨움이 저장되지 않은 0값 또는 하나 이상의 깨움이 대기 중인 양수 값을 가질 수 있다. down(P)과 up(V) 두 개의 연산을 제한하였다.
* down 연산
  - 값이 0보다 큰 지를 검사한다. 만약 그렇다면 이 값을 감소시키고 수행을 계속한다. 만약 이 값이 0이면 프로세스는 down의 수행을 완료하지 않고 즉시 잠들게 된다.
* up 연산
  - 세마포어 값을 증가시킨다.
  - 하나 또는 그 이상의 프로세스가 down 연산을 완료할 수 없어서 세마포어에서 잠들어 있으면 이 중 한 프로세스가 시스템에 의해 선택되어 down 수행을 완료할 수 있다.
  - 따라서 프로세스가 잠들어 있는 세마포어에 대해 up을 수행하면 세마포어 값은 여진히 0이지만 잠들어 있는 프로세스의 개수는 하나가 감소한다.
* 값을 검사하고, 변경하고, 경우에 따라 잠드는 이러한 모든 동작은 분할할 수 없는 하나의 **원자적행위(atomic action)**이다.
  - 한 번 세마포어 연산이 시작되면 이러한 원자성이 보장되어야 하며 이 연산이 완료되거나 프로세스가 잠들 때까지 다른 프로세스가 세마포어에 접근할 수 없도록 보장되어야 한다.

**세마포어를 이용한 생산자-소비자 문제의 해결**<br/>
<p align="center"><img src="/assets/img/Operating-Systems/2장-프로세스와-스레드/2-2-7.jpg" width="500"></p>

　세마포어가 제대로 동작하게 만들기 위해 이들을 분할할 수 없는 방식으로 구현하는 것이 필수적이다. Up과 down을 구현하는 일반적인 방식은 시스템 호출 형태로 구현하는 것으로 운영체제가 잠시 모든 인터럽트를 끄고, 세마포어를 검사하고, 변경하고, 필요하다면 프로세스를 잠들도록 한다. 이러한 모든 행위는 단지 몇 개의 명령어로 수행되므로 인터럽트를 끄는 것은 큰 해를 끼치지 않는다.
* 생산자-소비자 문제의 해법은 세 개의 세마포어를 사용한다.
  - 하나는 full이라 불리며 아이템으로 채워진 슬롯의 개수를 나타내고 다른 하나는 empty라 불리며 빈 슬롯의 개수를 나타내며 나머지 하나는 mutex로 생산자와 소비자가 동시에 버퍼에 접근하지 못하도록 한다.
  - Full은 0으로 초기화 되고 empty는 버퍼에 있는 슬롯의 개수로 초기화되며 mutex는 1로 초기화된다.
  - mutex는 다음에 배울 뮤텍스와는 다르다.
* 세마포어가 1로 초기화되고 둘 또는 그 이상의 프로세스가 사용되면서 이 들 중 한 프로세스만 임계구역에 진입할 수 있도록 하는 용도로 사용되는 세마포어를 이진 세마포어(binary semaphore)라 부른다. 만약 각 프로세스가 임계구역에 진입할 때 down을 수행하고 임계구역을 나오면서 up을 부르면 상호배체가 이루어진다.
* Mutex 세마포어는 상호배체를 위해 사용되었다. 이것은 한 번에 단 하나의 프로세스만 버퍼나 관련된 변수를 읽고 쓰도록 보장하는 용도로 사용된다. 이러한 상호배제는 혼란을 막기 위해 필요하다.
* 세마포어의 다른 용도는 **동기화(synchronization)**이다.
  - Full과 empty 세마포어는 특정 이벤트 순서들이 발생하거나 발생하지 않도록 보장하기 위해 필요하다.
  - 이 세마포어들은 버퍼가 가득찬 경우 생산자가 정지하도록 하는 것을, 그리고 버퍼가 빈 경우 소비자가 정지하도록 하는 것을 보장한다.

뮤텍스
------
　세마포어의 개수를 세는 능력이 필요없는 경우 뮤텍스라 불리는 세마포어의 단순한 버전이 사용될 수 있다.(세마포어 자체는 아님)<br/>
　**뮤텍스(mutex)**는 변수로서, 언락(unlock)과 락(lock), 두 가지 중 한 상태를 가진다. 실제 구현에서 종종 하나의 정수가 사용되어 0인 경우 언락을, 그리고 다른 값은 락을 의미한다. 뮤텍스와 함께 두개의 프로시듀어가 사용된다. 스레드가 임계구역에 접근할 때 mutex_lock을 호출한다. 뮤텍스가 현재 언락이면 호출은 성공하고 호출한 스레드는 임계구역에 진입할 수 있다.<br/>
　이와 달리 뮤텍스가 이미 락 상태이면 스레드는 임계구역에 있는 스레드가 수행을 마치고 mutex_unlock을 호출할 때까지 블록된다. 락이 해지될 때 다수의 스레드가 하나의 뮤텍스에서 대기 중이면 이들 중 하나가 임의로 선택되어 락을 획득한다.
<p align="center"><img src="/assets/img/Operating-Systems/2장-프로세스와-스레드/2-2-8.jpg" width="500"></p>

　mutex_lock 코드는 전의 enter_region 코드와 유사하지만 중요한 차이점이 있다.
* enter_region이 임계구역 진입에 실패하는 경우 락을 반복적으로 검사한다(바쁜대기). 그리고 시간이 흘러가면 다른 프로세스가 스케줄 되어 실행한다. 조만간 락을 획득한 프로세스가 수행되면서 락을 반환한다.
* mutex_lock의 경우 락을 획득하지 못하면 thread_yield를 호출하여 다른 스레드에게 CPU를 양보한다. 결과적으로 바쁜 대기는 존재하지 않는다. 나중에 스레드가 다시 수행하게 되면 락을 다시 검사한다.

모니터
------
　세마포어와 뮤텍스를 이용한 프로세스간 통신은 사용할 떄 매우 조심해야 한다. 한 가지 사소한 오류가 전체를 완전히 엉망으로 만든다. 정확한 프로그램을 좀 더 쉽게 작성할 수 있도록 **모니터(monitor)**라는 고급 동기화 프리미티브가 제안되었다.<br/>
* 모니터는 특별한 형태의 모듈 또는 패키지에 모아진 프로시듀어, 변수, 그리고 자료구조의 모음이다.
* 프로세스는 필요하면 언제든지 모니터의 프로시듀어를 호출할 수 있지만 모니터 밖의 프로시듀어에서 모니터늬 내부 자료 구조를 직접 접근하는 것은 불가능하다.

　모니터는 상호배제를 성취하는데 유용한 중요한 속성을 가지는데 이 속성은 바로 "단 하나의 프로세스만 한 순간에 모니터에서 활동할 수 있다"는 것이다. 모니터를 진입할 때 상호배제를 구현하는 것은 컴파일러의 책임이지만 일반적으로 뮤텍스나 이진 세마포어를 사용한다. 상호배제를 달성하는 것은 프로그래머가 아닌 컴파일러의 책임이므로 잘못될 가능성은 훨씬 적다.<br/>
　생산자-소비자 문제에서 버퍼가 찼는지 또는 버퍼가 비어 있는지 검사하는 것을 모니터의 프로시듀어로 쉽게 만들 수 있지만 버퍼가 가득 차면 생산자는 어떨게 블록되어야 하는지의 문제는 **조건 변수(condition variables)**와 이들에 대한 두가지 연산 wait과 signal을 도입하여 해결할 수 있다.
* 모니터 프로시듀어가 더 이상 진행할 수 없음을 인식하면, 어떤 조건 변수에 대해 **wait**을 수행한다.
  - 이 동작은 호출한 프로세스를 대기하게 만든다. 이것은 또한 현재 모니터 진입을 금지 당하고 있는 다른 프로세스가 모니터에 진입할 수 있게 만든다.
* 파트너 프로세스가 대기 중인 조건 변수에 대해 **signal**을 수행하여 대기 중인 파트너를 깨울 수 있다.

메시지 패싱
------
　**메시지 패싱(message passing)**을 이용한 프로세스간 통신은 send와 receive 두 가지 프리미티브를 사용하는데 이들은 모니터처럼 프로그래밍 언어의 구조체가 아니라 세마포어처럼 시스템 호출의 일종이다. 이들은 다음과 같이 간단하게 라이브러리 프로시듀어로 만들어질 수 있다.
* send(destination, &message);
  - 메시지를 명시된 목적지에 전송한다.
* receive(source, &message);
  - 명시된 정보원으로부터 메시지를 받는다.
  - 전달된 메시지가 없으면 수신자는 메시지가 도착할 때까지 대기한다. 또는 이와 달리 오류 코드와 함께 즉시 복귀할 수도 있다.

**메시지 전달 시스템의 설계 쟁점**<br/>
* 메시지는 네트워크 상에서 사라질 수 있다.
* 메시지 전달 시스템은 또한 send와 receive 호출에서 지정하는 프로세스가 모호하지 않도록 각 프로세스의 이름을 어떻게 부여할 것인지를 해결해야 한다.
* 인증(authentication) 또한 메시지 전달 시스템의 쟁점이다.
* 송신자와 수신자가 같은 기계에 있는 경우 중요한 설계 쟁점들중 하나는 성능이다.

장벽
------
　어떤 응용들은 단계별로 구성되며 모든 프로세스가 다같이 다음 단계로 진행할 준비가 되기 전에 어떤 프로세스만 먼저 다음 단계로 진행할 수 없다는 규칙을 가지고 있다. 이러한 동작은 각 단계의 끝에 **장벽(barrier)**을 설치함으로써 달성할 수 있다.

스케줄링
======


스레드
======

