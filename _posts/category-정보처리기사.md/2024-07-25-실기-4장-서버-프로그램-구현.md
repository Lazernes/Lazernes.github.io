---
title: "실기 4장 서버 프로그램 구현"
excerpt: "서버 프로그램 구현"

wirter: Myeongwoo Yoon
categories:
  - 정보처리기사
tags:
  - 정보처리기사

toc: true
toc_sticky: true
 
date: 2024-07-25
last_modified_at: 2024-07-25
---

개발 환경 구축
======

&ensp;**개발 환경 구축**은 응용 소프트웨어 개발을 위해 **개발 프로젝트를 이해하고 소프트웨어 및 하드웨어 장비를 구축하는 것**을 의미한다. 개발 환경은 응용 소프트웨어가 운영될 환경과 유사한 구조로 구축하고 분석 단계의 산출물을 바탕으로 개발에 필요한 하드웨어와 소프트웨어를 선정한다. 하드웨어와 소프트웨어의 성능, 편의성, 라이선스 등의 비즈니스 환경에 적합한 제품들을 최종적으로 결정하여 구축한다.<br/>
&ensp;**하드웨어 환경**은 사용자와의 인터페이스 역할을 하는 클라이언트(Client) 그리고 클라이언트와 통신하여 서비스를 제공하는 서버(Server)로 구성된다. 클라이언트의 종류로는 개인용 컴퓨텨(PC)와 스마트폰 등이 있고 서버의 종류는 다음과 같다.
* 웹 서버(Web Server)
  - 클라이언트부터 직접 요청을 받아 처리함
  - 저용량의 정적 파일들을 제공함
* 웹 애플리케이션 서버(WAS, Web Application Server)
  - 동적 서비스를 제공하거나, 웹 서버와 데이터베이스 서버 또는 웹 서버와 파일 서버 사이에서 인터페이스 역할을 수행함
* 데이터베이스 서버(DB Server)
  - 데이터베이스와 이를 관리하는 DBMS를 운영함
* 파일 서버(File Server)
  - 데이터베이스에 저장하기에는 비효율적이거나, 서비스 제공을 목적으로 유지하는 파일들을 저장함

&ensp;**소프트웨어 환경**은 클라이언트와 서버 운영을 위한 시스템 소프트웨어와 개발에 사용되는 개발 소프트웨어로 구성된다. 시스템 소프트웨어의 종류는 "운영체제(OS), 웹 서버 및 WAS 운용을 위한 서버 프로그램, DBMS" 등이 있고, 개발 소프트웨어의 종류는 다음과 같다.
* 요구사항 관리 도구: 요구사항의 수집과 분석, 추적 등을 편리하게 도와주는 소프트웨어
* 설계/모델링 도구: UML(통합 모델링 언어)을 지원하며, 개발의 전 과정에서 설계 및 모델링을 도와주는 소프트웨어
* 구현 도구: 개발 언어를 통해 애플리케이션의 실제 구현을 지원하는 소프트웨어
* 빌드 도구: 구현 도구를 통해 작성된 소스의 빌드 및 배포, 라이브러리 관리를 지원하는 소프트웨어
* 테스트 도구: 모듈들이 요구사항에 적합하게 구현되었는지 테스트하는 소프트웨어
* 형상 관리 도구: 산출물들을 버전별로 관리하여 품질 향상을 지원하는 소프트웨어

&ensp;**웹 서버(Web Server)의 기능**은 다음과 같다.
* HTTP/HTTPS 지원: 브라우저로부터 요청을 받아 응답할 때 사용되는 프로토콜
* 통신 기록(Communication Log): 처리한 요청들을 로그 파일로 기록하는 기능
* 정적 파일 관리(Managing Static Files): HTML, CSS, 이미지 등의 정적 파일들을 저장하고 관리하는 기능
* 대역폭 제한(Bandwidth Throttling): 네트워크 트래픽의 포화를 방지하기 위해 응답 속도를 제한하는 기능
* 가상 호스팅(Virtual Hosting): 하나의 서버로 여러 개의 도메인 이름을 연결하는 기능
* 인증(Authentication): 사용자가 합법적인 사용자인지를 확인하는 기능

&ensp;**개발 언어의 선정 기준**은 다음과 같다.
* 적절성: 개발하려는 소프트웨어 목적에 적합해야 함
* 효율성: 코드의 작성 및 구현이 효율적이어야 함
* 이식성: 다양한 시스템 및 환경에 적용이 가능해야 함
* 친밀성: 개발 언어에 대한 개발자들의 이해도와 활용도가 높아야 함
* 범용성: 다른 개발 사례가 존재하고 여러 분야에서 활용되고 있어야 함

소프트웨어 아키텍처
======

&ensp;**소프트웨어 아키텍처**는 **소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체**이다. 애플리케이션의 분할 방법과 분할된 모듈에 할당될 기능, 모듈 간의 인터페이스 등을 결정한다. 소프트웨어 아키텍처 설게의 기본 원리로는 모듈화, 추상화, 단계적 분해, 정보은닉이 있다.
* **모듈화(Modularity)**
  - 소프트웨어의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 **시스템의 기능들을 모듈단위로 나누는 것**을 의미한다.
  - 모듈의 크기를 너무 작게 나누면 개수가 많아져 모듈 간의 통합 비용이 많이 든다.
  - 모듈의 크기를 너무 크게 나누면 개수가 적어 통합 비용은 적게 들지만 모듈 하나의 개발 비용이 많이 든다.
* **추상화(Abstraction)**
  - 문제의 **전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화시켜 나가는 것**이다.
  - 완전한 시스템을 구축하기 전에 그 시스템과 유사한 모델을 만들어서 여러 가지 요인들을 테스트할 수 있다.
  - 추사화의 유형은 다음과 같다.
    + 과정 추상화: 자세한 수행 과정을 정의하지 않고, 전반적인 흐름만 파악할 수 있게 설계하는 방법
    + 데이터 추상화: 데이터의 세부적인 속성이나 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법
    + 제어 추상화: 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체하는 방법
* **단계적 분해(Stepwise Refinement)**
  - Niklaus Wirth에 의해 제안된 하향식 설계 전략으로, 문제를 **상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법**이다.
  - 소프트웨어의 포괄적인 기능에서부터 시작하여 점차적으로 구체화하고, 알고리즘, 자료 구조 등 상세한 내역은 가능한 한 뒤로 미루어 진행한다.
* **정보 은닉(Information Hiding)**
  - 한 **모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법**이다.
  - 정보 은닉을 통해 모듈을 독립적으로 수행할 수 있다.
  - 하나의 모듈이 변경되더라도 다른 모듈에 영향을 주지 않으므로 수정, 시험, 유지보수가 용이하다.

&ensp;소프트웨어 개발의 설계 단계는 크게 **상위 설계와 하위 설계**로 구분할 수 있다.
* 상위 설계
  - 아키텍처 설계, 예비 설계
  - 시스템의 전체적인 구조
  - 구조, DB, 인터페이스
* 하위 설계
  - 모듈 설계, 상세 설계
  - 시스템의 내부 구조 및 행위
  - 컴포넌트, 자료 구조, 알고리즘

&ensp;**소프트웨어 아키텍처의 품질 속성**은 소프트웨어 아키텍처가 이해 관계자들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계되었는지를 확인하기 위해 품질 평가 요소들을 구체화 시켜 놓은 것으로, 품질 평가 요소의 종류는 다음과 같다.
* 시스템 측면: 성능, 보안, 가용성, 사용성, 변경 용이성, 확장성 등
* 비지니스 측면: 시작 적시성, 비용과 혜택, 예상 시스템 수명, 목표 시장, 공개 일정 등
* 아키텍처 측면: 개념적 무결성, 정확성, 구축 가능성, 변경성, 시험성 등

&ensp;**소프트웨어 아키텍처의 설게 과정**은 다음과 같다.
1. 설계 목표 설정: 요구사항을 분석하여 전체 시스템의 설계 목표를 설정
2. 시스템 타입 결정: 시스템과 서브시스템의 타입을 결정하고, 아키텍처 패턴 선택
3. 아키텍처 패턴 적용: 시스템의 표준 아키텍처를 설계
4. 서브시스템 구체화: 서브시스템의 기능 및 서브시스템 간의 상호작용을 위한 동작과 인터페이스를 정의
5. 검토: 설계 목표, 요구사항, 설계의 기본 원리 등을 만족하는지 아키텍처 검토 

&ensp;**협약(Contract)에 의한 설계**는 **컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것**으로, 소프트웨어 컴포넌트에 대한 정확한 인터페이스를 명세한다. 명세에 포함될 조건은 다음과 같다.
* 선행 조건(Precondition): 오퍼레이션이 호출되기 전에 참이 되어야 할 조건
* 결과 조건(Postcondition): 오퍼레이션이 수행된 후 만족되어야 할 조건
* 불변 조건(Invariant): 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건

아키텍처 패턴
======

&ensp;**아키텍처 패턴(Patterns)**은 **아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제**를 의미한다. 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽을 제시한다. 아키텍처 패턴에는 서브시스템들과 그 역할이 정의되어 있으며, 서브시스템 사이의 관계와 여러 규칙, 지침 등이 포함되어 있다. 아키텍처 패턴의 종류는 다음과 같다.
* **레이터 패턴(Layers pattern)**
  - **시스템을 계층(Layer)으로 구분하여 구성하는 고전적인 방법의 패턴**이다.
  - 하위 계층은 상위 계층에 대한 서비스 제공자가 되고, 상위 계층은 하위 계층의 클라이언트가 된다.
  - 서로 마주보는 두 개의 계층 사이에서만 상호작용이 이루어진다.
  - 대표적으로 OSI 참조 모델이 있다.
* **클라이언트-서버 패턴(Client-Server Pattern)**
  - **하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴**이다.
  - 사용자가 클라이언트를 통해 서버에 요청하고 클라이언트가 응답을 받아 사용자에게 제공하는 방식으로 서비스를 제공한다.
* **파이프-필터 패턴(Pipe-Filter Pattern)**
  - **데이터 스크림 절차**의 각 단계를 **필터(Filter) 컴포넌트로 캡슐화하여 파이프(Pipe)를 통해 데이터를 전송하는 패턴**이다.
  - 앞 시스템의 처리 결과물을 파이프를 통해 전달받아 처리한 후 그 결과물을 다시 파이프를 통해 다음 시스템으로 넘겨주는 패턴을 반복한다.
  - 데이터 변환, 버퍼링, 동기화 등에 주로 사용된다.
  - 대표적으로 UNIX, 쉘(Shell)이 있다.
* **모델-뷰-컨트롤러 패턴(Model-View-Controller Pattern)**
  - **서브시스템을 3개의 부분으로 구조화하는 패턴**이다.
  - 컨트롤러가 사용자의 요청을 받으면 핵심 기능과 데이터를 보관하는 모델을 이용하여 뷰에 정보를 출력하는 구조이다.
  - 여러 개의 뷰를 만들 수 있다.
  - 한 개의 모델에 대해 여러 개의 뷰를 필요로 하는 대화형 애플리케이션에 적합하다.

&ensp;**기타 패턴**들은 다음과 같다.
* 마스터-슬레이브 패턴(Master-Slave Pattern)
  - 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행하는 패턴이다.
  - 장애 허용 시스템, 병렬 컴퓨팅 시스템 등이 있다.
* 브로커 패턴(Broker Patttern)
  - 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결해주는 패턴이다.
  - 분산 환경 시스템에서 주로 활용된다.
* 피어-투-피어 패턴(Peer-To-Peer Pattern)
  - 피어(Peer)라고 불리는 하나의 컴포넌트가 클라이언트가 될 수도, 서비스를 제공하는 서버가 될 수도 있는 패턴이다.
  - 파일 공유 네트워크 등이 있다.
* 이벤트-버스 패턴(Event-Bus Pattern)
  - 소스가 특정 채널에 이벤트 메시지를 발행(Publish)하면, 해당 채널을 구독(Subscribe)한 리스너들이 메시지를 받아 이벤트를 처리하는 방식이다.
  - 알림 서비스가 있다.
* 블랙보드 패턴(Blackboard Pattern)
  - 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 패턴이다.
  - 음성 인식, 차량 식별, 신호 해석 등에 주로 활용된다.
* 인터프리터 패턴(Interpreter Pattern)
  - 프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성된 패턴이다.
  - 번역기, 컴파일러, 인터프리터 등이 있다.

객체지향(Object-Oriented)
======

&ensp;**객체지향**은 소프트웨어의 각 요소들을 **객체(Object)로 만들어, 객체들을 조립해서 소프트웨어를 개발하는 기법**이다. 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택되어야 사용되고 있다. 소프트웨어의 재사용 및 확장이 용이하여 고품질의 소프트웨어를 빠르게 개발할 수 있고 유지보수가 쉽다.<br/>
&ensp;객체지향의 구성 요소는 다음과 같다.
* **객체(Object)**
  - **데이터와 데이터를 처리하는 함수를 묶어 놓은(캡슐화한) 하나의 소프트웨어 모듈**이다.
  - 데이터
    + 객체가 가지고 있는 정보로 속성이나 상태, 분류 등을 나타낸다.
  - 함수
    + 객체가 수행하는 기능으로 객체가 갖는 데이터(속성, 상태)를 처리하는 알고리즘이다.
    + 객체의 상태를 참조하거나 변경하는 수단이다.
* **클래스(Class)**
  - **공통된 속성과 연산(행위)을 갖는 객체의 집합**이다.
  - 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀이다.
  - 클래스에 속한 각각의 객체를 인스턴스(Instance)라고 한다.
* **메시지(Message)**
  - **객체들 간의 상호작용을 하는데 사용되는 수단**으로, 객체에게 어떤 행위를 하도록 지시하는 명령 또는 요구사항이다.
  - 메시지를 받은 객체는 대응하는 연산을 수행하여 예상된 결과를 반환한다.

&ensp;객체지향의 성질은 다음과 같다.
* **캡슐화(Encapsulation)**
  - **외부에서의 접근을 제한하기 위해 인터페이스를 제외한 세부 내용을 은닉하는 것**이다.
  - 캡슐화된 객체는 외부 모듈의 변경으로 인한 파급 효과가 적다.
  - 객체들 간의 메시지를 주고받을 때 상대 객체의 세부 내용은 알 필요가 없으므로 인터페이스가 단순해지고, 객체 간의 결합도가 낮아진다.
* **상속(Inheritance)**
  - **상위 클래스(부모 클래스)의 모든 속성과 연산을 하위 클래스(자식 클래스)가 물려받는 것**이다.
  - 상속을 이용하면 하위 클래스는 상위 클래스의 모든 속성과 연산을 자신의 클래스 내에서 다시 정의하지 않고서도 즉시 자신의 속성으로 사용할 수 있다.
  - 하위 클래스는 상위 클래스로부터 상속받은 속성과 연산 외에 새로운 속성과 연산을 첨가하여 사용할 수 있다.
* **다형성(Polymorphism)**
  - **하나의 메시지에 대해 각각의 객체(클래스)가 가지고 있는 고유한 방법(특성)으로 응답할 수 있는 능력**을 의미한다.
  - 객체(클래스)들은 동일한 메소드명을 사용하며 같은 의미의 응답을 한다.
* **연관성(Relationship)**
  - **두 개 이상의 객체(클래스)들이 상호 참조하는 관계**를 말하며 종류는 다음과 같다.
  - is member of
    + 연관화(Association): 2개 이상의 객체가 상호 관련되어 있음을 의미함
  - is instance of
    + 분류화(Classfication): 동일한 형의 특성을 갖는 객체들을 모아 구성하는 것
  - is part of
    + 집단화(Aggregation): 관련 있는 객체들을 묶어 하나의 상위 객체를 구성하는 것
  - is a
    + 일반화: 공통적인 성질들로 추상화한 객체들을 구성하는 것
    + 특수화/상세화(Specialization): 상위 객체를 구체화하여 하위 객체를 구성하는 것

객체지향 분석 및 설계
======

&ensp;**객체지향 분석(OOA; Object Oriented Analysis)**은 **사용자의 요구사항과 관련된 모든 클래스(객체), 속성, 연산 등을 정의하여 모델링하는 작업**이다. 개발을 위한 업무를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석한다. 클래스를 식별하는 것이 객체지향 분석의 주요한 목적이다.<br/>
&ensp;**객체지향 분석의 방법론**은 다음과 같다.
* 럼바우(Rumbaugh) 방법
  - 분석 활동을 객체 모델, 동적 모델, 기능 모델로 나누어 수행함
* Booch(부치) 방법
  - 미시적(Micro) 개발 프로세스와 거시적(Macro) 개발 프로세스를 모두 사용하는 분석 방법으로, 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의함
* Jacobson 방법
  - Use Case를 강조하여 사용함
* Coad와 Yourdon 방법
  - E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성함
* Wirfs-Brock 방법
  - 분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행함

&ensp;**럼바우(Rumbaugh)의 분석 기법**은 **모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법**으로, 객체 모델링 기법(OMT, Object-Modeling Technique)이라고도 한다. 분석 활동은 '객체 모델링, 동적 모델링, 기능 모델링' 순으로 통해 이루어진다.
* 객체 모델링(Object Modeling)
  - 정보 모델링(Information Modeling)이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 것
* 동적 모델링(Dynamic Modeling)
  - 상태 다이어그램(상태도)을 이용하여 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적 행위를 표현하는 모델링
* 기능 모델링(Fuctional Modeling)
  - 자료 흐름도(DFD)를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링

&ensp;**객체지향 설계 원칙**은 **변경이나 확장에 유연한 시스템을 설계하기 위해 지켜야할 다섯 가지 원칙**으로, SOLID 원칙이라고도 불린다. 객체지향 설계 원칙의 종류는 다음과 같다.
* 단일 책임 원칙(SRP,Single Responsibility Principle)
  - 객체는 단 하나의 책임만 가져야 한다는 원칙
* 개방-폐쇄 원칙(OCP, Open-Closed Principle)
  - 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 한다는 원칙
* 리스코프 치환 원칙(LSP, Liskov Substitution Principle)
  - 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다는 설계 원칙
* 인터페이스 분리 원칙(ISP, Interface Segregation Principle)
  - 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 원칙
* 의존 역전 원칙(DIP, Dependency Inversion Principle)
  - 의존 관계가 성립될 시 추상성이 높은 클래스와 의존 관계를 맺어야 한다는 원칙

모듈
======

&ensp;**모듈(Module)**은 **모듈화를 통해 분리된 시스템의 각 기능**으로, 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위 등과 같은 의미로 사용된다. 모듈의 기능적 독립성은 소프트웨어를 구성하는 각 모듈의 기능이 서로 독립됨을 의미하는 것으로, 모듈의 독립성은 결합도(Coupling)와 응집도(Cohesion)에 의해 측정된다.<br/>
&ensp;**결합도(Coupling)**는 **모듈 간의 상호 의존하는 정도** 또는 두 모듈 사이의 연관 관계를 의미한다. 결합도가 약할수록 품질이 높고, 강할수록 품질이 낮다.<br/>
&ensp;**결합도의 종류**는 다음과 같다.
* 자료 결합도(Data Coupling)
  - 모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도
* 스탬프(검인) 결합도(Stamp Coupling)
  - 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도
* 제어 결함도(Control Coupling)
  - 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호를 이용하여 통신하거나 제어 요소(Function Code, Switch, Flag)를 전달하는 결합도
  - 하위 모듈에서 상위 모듈로 제어 신호가 이동하여 하위 모듈이 상위 모듈에게 처리 명령을 내리는 권리 전도현상이 발생하게 된다.
* 외부 결함도(External Coupling)
  - 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도
* 공통(공유) 결함도(Common Coupling)
  - 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도
  - 파라미터가 아닌 모듈 밖에 선언된 전역변수를 사용하여 전역 변수를 갱신하는 방식으로 상호작용하는 때의 결합도
* 내용 결함도(Content Coupling)
  - 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도

<p align="center"><img src="/assets/img/정보처리기사/소프트웨어 설계/3장 애플리케이션 설계/5-1.jpeg" width="600"></p>

&ensp;**응집도(Cohesion)**는 정보 은닉 개념을 확장한 것으로, 명령어나 호출문 등 **모듈의 내부 요소들의 서로 관련되어 있는 정도**이다. 응집도가 강할수록 품질이 높고, 약할수록 품질이 낮다.<br/>
&ensp;**응집도의 종류**는 다음과 같다.
* 우연적 응집도(Coincidental Cohesion)
  - 모듈 내부의 각 구성 요소들이 서로 관련 없는 요소들로만 구성된 경우의 응집도
* 논리적 응집도(Logical Cohesion)
  - 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도
* 시간적 응집도(Temporal Cohesion)
  - 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도
* 절차적 응집도(Procedural Cohesion)
  - 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 순차적으로 수행할 경우의 응집도
* 교환(통신)적 응집도(Communication Cohesion)
  - 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도
* 순차적 응집도(Sequential Cohesion)
  - 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도
* 기능적 응집도(Functional Cohesion)
  - 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도

<p align="center"><img src="/assets/img/정보처리기사/소프트웨어 설계/3장 애플리케이션 설계/5-2.jpeg" width="600"></p>

&ensp;**팬인(Fan-In)**은 **어떤 모듈을 제어(호출)하는 모듈의 수**를 나타내고 **팬아웃(Fan-out)**은 **어떤 모듈에 의해 제어(호출)되는 모듈의 수**를 나타낸다. 팬인과 팬아웃을 분석하여 시스템의 복잡도를 알 수 있다. 팬인이 높다는 것은 재사용 측면에서 설계가 잘 되어있다고 볼 수 있으나, 단일 장에점이 발생할 수 있으므로 중첩적인 관리 및 테스트가 필요하다. 팬아웃이 높은 경우 불필요하게 다른 모듈을 호출하고 있는지 검토하고, 단순화시킬 수 있는지 여부에 대한 검토가 필요하다. 시스템의 복잡도를 최적화하려면 팬인은 높게, 판아웃은 낮게 설계해야 한다.<br/>
&ensp;**N-S 차트(Nassi-Schneidermon Chart)**는 **논리의 기술에 중첩을 두고 도형을 이용한 표현 방법**으로 박스 다이어그램, Chain Chart라고도 한다. GOTO나 화살표를 사용하지 않는다. 연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조를 표현하며, 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는 데 적합하다.

단위 모듈
======

&ensp;**단위 모듈(Unit Module)**은 소프트웨어 구현에 필요한 여러 동작 중 **한 가지 동작을 수행하는 기능을 모듈로 구현한 것**이다. 단위 모듈로 구현되는 하나의 기능을 단위 기능이라고 부른다. 독집적인 컴파일이 가능하며, 다른 모듈에 호출되거나 삽입되기도 한다. 단위 모듈의 구현 과정은 다음과 같다.
1. 단위 기능 명세서 작성: 기능 및 코드 명세서나 설계 지침과 같은 단위 기능을 명세화하는 단계
2. 입•출력 기능 구현: 입•출력 기능을 위한 알고리즘 및 데이터를 구현하는 단계
3. 알고리즘 구현: 단위 기능별로 모듈을 구현하는 단계

&ensp;**IPC(Inter-Process Communication)**은 **모듈 간 통산 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합**이다. 복수의 프로세스를 수행하며 이뤄지는 프로세스 간 통신까지 구현이 가능하다. IPC의 대표 메소드 5가지는 다음과 같다.
* Shared Memory
  - 공유 가능한 메모리를 구성하여 다수의 프로세스가 통신하는 방식
* Socket
  - 네트워크 소켓을 이용하여 네트워크를 경유하는 프로세스 간에 통신하는 방식
* Semaphores
  - 공유 자원에 대한 접근 제어를 통해 통신하는 방식
* Pipes&names Pipes
  - 'Pipe'라고 불리는 선입선출 형태로 구성된 메모리를 여러 프로세스가 공유하여 통신하는 방식
  - Pipe는 하나의 프로세스가 이용 중이라면 다른 프로세스는 접근할 수 없음
* Message Queueing
  - 메시지가 발생하면 이를 전달하는 방식으로 통신하는 방식

&ensp;**단위 모듈 테스트**는 프로그램의 단위 기능으로 구현된 **모듈이 정해진 기능을 정확히 수행하는지 검증하는 것**이다. 단위 테스트(Unit Test)라고도 불리며, 단위 모듈 테스트의 기준은 단위 모듈에 대한 코드이므로 시스템 수준의 오류는 잡아낼 수 없다.<br/>
&ensp;**테스트 케이스(Test Case)**는 구현된 **소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위한 테스트 항목에 대한 명세서**이다. 테스트 케이스를 이용하지 않은 테스트는 특정 요소에 대한 검증이 누락되거나 불필요한 검증의 반복으로 인해 인력과 시간을 낭비할 수 있다. ISO/IEC/IEEE 29119-3 표준에 따른 테스트 케이스의 구성 요소는 다음과 같다.
* 식별자(Identifier): 항목 식별자, 일렬번호
* 테스트 항목(Test Item): 테스트 대상(모듈 또는 기능)
* 입력 명세(Input Specification): 입력 데이터 또는 테스트 조건
* 출력 명세(Output Specification): 테스트 케이스 수행 시 예상되는 출력 결과
* 환경 설정(Environmental Needs): 필요한 하드웨어나 소프트웨어의 환경
* 특수 절차 요구(Special Procedure Requirement): 테스트 케이스 수행 시 특별히 요구되는 절차
* 의존성 기술(Inter-case Dependencies): 테스트 케이스 간의 의존성

공통 모듈
======

&ensp;**공통 모듈**은 **여러 프로그램에서 공통적으로 사용할 수 있는 모듈**을 의미한다. 자주 사용되는 계산식이나 매번 필요한 사용자 인증과 같은 기능들이 공통 모듈로 구성될 수 있다. 공통 모듈을 구현할 때는 다른 개발자들이 해당 기능을 명확히 이해할 수 있도록 다음의 **명세 기법**을 준수해야 한다.
* 정확성(Correctness): 시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성한다.
* 명확성(Clarity): 해당 기능을 이해할 때 중의적으로 해석되지 않도록 명확하게 작성한다.
* 완전성(Completeness): 시스템 구현을 위해 필요한 모든 것을 기술한다.
* 일관성(Consistency): 공통 기능들 간 상호 충돌이 발생하지 않도록 작성한다.
* 추적성(Traceability): 기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성한다.

&ensp;**재사용(Reuse)**은 비용과 개발 시간을 절약하기 위해 **이미 개발된 기능들을 파악하고 재구성하여 새로운 시스템 또는 기능 개발에 사용하기 적합하도록 최적화 시키는 작업**이다. 재사용을 위해서는 누구나 이해할 수 있고 사용이 가능하도록 사용법을 공개해야한다. 재사용 규모에 따른 분류는 다음과 같다.
* 함수와 객체
  - 클래스나 메소드 단위의 소스 코드를 재사용한다.
* 컴포넌트
  - 독립적인 업무 또는 기능을 수행하는 실행 코드 기반으로 작성된 모듈이다.
  - 컴포넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식으로 재사용한다.
* 애플리케이션
  - 공통된 기능들을 제공하는 애플리케이션을 공유하는 방식으로 재사용한다.

&ensp;**효과적인 모듈 설계방안**은 다음과 같다.
* 결합도는 줄이고 응집도는 높여서 모듈의 독립성과 재사용성을 높인다.
* 복잡도와 중복성을 줄이고 일관성을 유지시킨다.
* 모듈의 기능은 예측이 가능해야 하며 지나치게 제한적이어서는 안 된다.
* 모듈 크기는 시스템의 전반적인 기능과 구조를 이해하기 쉬운 크기로 분해한다.
* 효과적인 제어를 위해 모듈 간의 계층적 관계를 정의하는 자료가 제시되어야 한다.

코드
======

&ensp;**코드(Code)**는 **자료의 분류, 조합, 집계, 추출을 용이하게 하기 위해 사용되는 기호**이다. 정보를 신속, 정확, 명료하게 전달할 수 있게 한다. 일정한 규칙에 따라 작성되며, 정보 처리의 효율과 처리된 정보의 가치에 많은 영향을 미친다. **코드의 주요 기능**은 다음과 같다.
* 식별 기능: 데이터 간의 성격에 따라 구분이 가능하다.
* 분류 기능: 특정 기준이나 동일한 유형에 해당하는 데이터를 그룹화 할 수 있다.
* 배열 기능: 의미를 부여하여 나열할 수 있다.
* 표준화 기능: 다양한 데이터를 기준에 맞추어 표현할 수 있다.
* 간소화 기능: 복잡한 데이터를 간소화 할 수 있다.

&ensp;**코드의 종류**는 다음과 같다.
* 순차 코드(Sequence Code)
  - 자료의 발생 순서, 크기 순서 등 일정 기준에 따라서 최초의 자료부터 차례로 일련번호를 부여하는 방법으로, 순서 코드 또는 일련번호 코드라고도 한다.
* 블록 코드(Block Code)
  - 코드화 대상 항목 중에서 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 방법으로, 구분 코드라고도 한다.
* 10진 코드(Decimal Code)
  - 코드화 대상 항목을 0~9까지 10진 분할 하고, 다시 그 각각에 대하여 10진 분할하는 방법을 필요한 만큼 반복하는 방법으로, 도서 분류식 코드라고도 한다.
* 그룹 분류 코드(Group Classification Code)
  - 코드화 대상 항목을 일정 기준에 따라 대분류, 중분류, 소분류 등으로 구분하고, 각 그룹 안에서 일련번호를 부여하는 방법이다.
* 연상 코드(Mnemonic Code)
  - 코드화 대상 항목의 명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용하여 코드를 부여하는 방법이다.
* 표의 숫자 코드(Significant Digit Code)
  - 코드화 대상 항목의 성질, 즉 길이, 넓이, 부피, 지름, 높이 등의 물리적인 수치를 그대로 코드에 적용시키는 방법으로 유효 숫자 코드라고도 한다.
* 합성 코드(Combined Code)
  - 필요한 기능을 하나의 코드로 수행하기 어려운 경우 2개 이상의 코드를 조합아여 만드는 방법이다.

디자인 패턴
======

&ensp;**디자인 패턴(Design Pattern)**은 **모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제**를 의미한다. 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드 등으로 구성되어 있다. 개발 과정 중에 문제가 발생하면 새로 해결책을 구상하는 것보다 문제에 해당하는 디자인 패턴을 참조하여 적용하는 것이 더 효율적이다. **GoF(Gang of Four)**의 디자인 패턴유형에 따라 생성 패턴 5개, 구조 패턴 7개, 행위 패턴 11개 총 23개의 패턴으로 구성된다.<br/>
&ensp;**생성 패턴(Creational Pattern)**은 **클래스나 객체의 생성과 참조 과정을 정의하는 패턴**이다.
* 추상 팩토리(Abstract Factory)
  - 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관, 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현한다.
  - 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능하다.
* 빌더(Builder)
  - 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성한다.
  - 객체의 생성 과정과 표현 방법을 분리하고 있어, 동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있다.
* 팩토리 메소드(Factory Method)
  - 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴이다.
  - 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당한다.
  - 가상 생성자(Virtual Constructor) 패턴이라고도 한다.
* 프로토타입(Prototype)
  - 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴이다.
  - 일반적인 방법으로 객체를 생성하며, 비용이 큰 경우 주로 이용한다.
* 싱글톤(Singleton)
  - 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없다.
  - 클래스 내에서 인스턴스가 하나뿐임을 보장하며, 불필요한 메모리 낭비를 최소화 할 수 있다.

&ensp;**구조 패턴(Structural Pattern)**은 구조가 복잡한 시스템을 개발하기 쉽도록 **클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴**이다.
* 어댑터(Adapter)
  - 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴이다.
  - 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용한다.
* 브리지(Bridge)
  - 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴이다.
  - 기능과 구현을 두 개의 별도 클래스로 구현한다.
* 컴포지트(Composite)
  - 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴이다.
  - 객체들을 트리 구조로 구성하여 디렉터리 안에 디렉터리가 있듯이 복합 객체 안에 복합 객체가 포함되는 구조를 구현할 수 있다.
* 데코레이터(Decorator)
  - 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴이다.
  - 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현한다.
* 퍼싸드(Facade)
  - 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴이다.
  - 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요하다.
* 플라이웨이트(Flyweight)
  - 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴이다.
  - 다수의 유사 객체를 생성하거나 조작할 때 유용하게 사용할 수 있다.
* 프록시(Proxy)
  - 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴으로, 대리자라고도 불린다.
  - 내부에서는 객체 간의 복잡한 관계를 단순하게 정리하고 외부에서는 객체의 세부적인 내용을 숨긴다.

&ensp;**행위 패턴(Behavior Pattern)**은 **클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴**이다.
* 책임 연쇄(Chain of Responsibility)
  - 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴이다.
  - 요청을 처리할 수 있는 각 객체들이 고리(Chain)로 묶여 있어 요청이 해결될 때까지 고리를 따라 책임이 넘어간다.
* 커맨드(Command)
  - 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴이다.
  - 요청에 사용되는 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화한다.
* 인터프리터(Interpreter)
  - 언어에 문법 표현을 정의하는 패턴이다.
  - SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용한다.
* 반복자(Iterator)
  - 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴이다.
  - 내부 표현 방법의 노출 없이 순차적인 접근이 가능하다.
* 중재자(Mediator)
  - 수많은 객체들 간의 복잡한 상호작용(Interface)을 캡슐화하여 객체로 정의하는 패턴이다.
  - 객체 사이의 의존성을 줄여 결합도를 감소시킬 수 있다.
* 메멘토(Memento)
  - 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴이다.
  - Crtl + Z와 같은 되돌리기 기능을 개발할 때 주로 이용한다.
* 옵서버(Observer)
  - 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴이다.
  - 주로 분산된 시스템 간에 이벤트를 생성•발행(Publish)하고, 이를 수신(Subscribe)해야 할 때 이용한다.
* 상태(State)
  - 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴이다.
  - 객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리한다.
* 전략(Strategy)
  - 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴이다.
  - 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향 없이 알고리즘의 변경이 가능하다.
* 템플릿 메소드(Template Method)
  - 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴이다.
  - 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의함으로써 코드의 양을 줄이고 유지보수를 용이하게 해준다.
* 방문자(Visitor)
  - 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴이다.
  - 분리된 처리 기능은 각 클래스를 방문(Visit)하여 수행한다.

개발 지원 도구
======

&ensp;**통합 개발 환경(IDE; Integrated Development Environment)**은 **개발에 필요한 환경 즉, 편집기(Editor), 컴파일러(Compiler), 디버거(Debugger) 등의 다양한 툴을 하나의 인터페이스로 통합하여 제공하는 환경**을 말한다. 통합 개발 환경 도구는 통합 개발 환경을 제공하는 소프트웨어를 의미한다. 통합 개발 환경 도구는 코드를 실행하거나 테스트할 때 오류가 발생한 부분을 시각화하므로 수정이 용이하다.<br/>
&ensp;**통합 개발 환경 도구의 종류**는 이클립스, 비주얼 스튜디도, 엑스 코드, 안드로이드 스튜디오, IDEA가 있다.<br/>
&ensp;**빌드**는 **소스 코드 파일들을 컴퓨터에서 실행할 수 있는 제품 소프트웨어로 변환하는 과정 또는 결과물**을 말한다. **빌드 도구**는 소스 코드를 소프트웨어로 변환하는 과정에 필요한 전처리(Preprocessing), 컴파일(Compile) 등의 작업등을 수행하는 소프트웨어를 말한다. 대표적인 도구는 다음과 같다.
* **Ant(Another Neat Tool)**
  - 아피치 소프트웨어 재단(Apache Software Foundation)에서 개발한 소프트웨어로, 자바 프로젝트의 공식적인 빌드 도구로 사용되고 있다.
  - 정해진 규칙이나 표준이 없다.
* **Maven**
  - Ant와 동일한 아피지 소프트웨어 재단에서 개발된 것으로, Ant의 대안으로 개발되었다.
  - 규칙이나 표준이 존재하여 예외 사항만 기록
  - 의존성(Dependency)을 설정하여 라이브러리를 관리함
* **Gradle**
  - 기존의 Ant와 Maven을 보완하여 개발된 빌드 도구이다.
  - 안드로이드 스튜디오의 공식 빌드 도구
  - 그루비(Groovy) 기반의 빌드 스크립트를 사용함

&ensp;**협업 도구**는 **개발에 참여하는 사람들이 서로 다른 작업 환경에서 원할히 프로잭트를 수행할 수 있도록 도와주는 도구(Tool)**로, 협업 소프트웨어, 그룹웨어(Groupware) 등으로도 불린다. 일정 관리, 업무흐름 관리, 정보 공유, 커뮤니케이션 등의 업무 보조 도구가 포함된다.

서버 개발
======

&ensp;**서버 개발**은 **웹 애플리케이션의 로직을 구현할 서버 프로그램을 제작하여 웹 애플리케이션 서버(WAS)에 탑재하는 것**을 의미한다. 서버 개발에 사용되는 프로그래밍 언어에는 Java, Javascript, Python, PHP, Puby 등이 있다. 각 프로그래밍 언어에는 해당 언어로 서버 프로그램을 개발할 수 있도록 지원하는 프레임워크가 있다.<br/>
&ensp;**서버 개발 프레임워크**는 서버 프로그램 개발 시 **다양한 네트워크 설정, 요청 및 응답 처리, 아키텍처 모델 구현 등을 손쉽게 처리할 수 있도록 클래스나 인터페이스를 제공하는 소프트웨어**를 의미한다. 서버 개발 프레임워크의 대부분은 모델-뷰-컨트롤러(MVC) 패턴을 기반으로 개발되었다. 대표적인 서버 프레임워크의 종류는 다음과 같다.
* Spring
  - JAVA를 기반으로 만들어진 프레임워크로, 전자정부 표준 프레임워크의 기반 기술로 사용되고 있다.
* Node.js
  - JavaScript를 기반으로 만들어진 프레임워크로, 비동기 입•출력 처리와 이벤트 위주이 높은 처리 성능을 갖고 있어 실시간으로 입•출력이 빈번한 애플리케이션에 적합하다.
* Django
  - Python을 기반으로 만들어진 프레임워크로, 컴포넌트의 재사용과 플러그인화를 강조하여 신속한 개발이 가능하도록 지원한다.
* Codeigniter
  - PHP를 기반으로 만들어진 프레임워크로, 인터페이스가 간편하여 서버 자원을 적게 사용한다.
* Ruby on Ralls
  - Puby를 기반으로 만들어진 프레임워크로, 테스트를 위한 웹 서버를 지원하여 데이터베이스 작업을 단순화, 자동화시켜 개발 코드의 길이가 짧아 신속한 개발이 가능하다.

&ensp;**서버 개발 과정**은 **DTO/VO, SQL, DAO, Service, Controller를 각각 구현하는 과정**이다. 구현 순서는 개발자가 임의로 변경할 수 있다. 개발하려는 서버 프로그램의 목적, 개발 언어, 규모 등의 이유로 통합되거나 세분화할 수 있다. 구현 과정은 다음과 같다.<br/>
* DTO/VO 구현
  - 데이터 교환을 위해 사용할 객체를 만드는 과정
  - 송•수신할 데이터의 자료형(Data Type)에 맞는 변수 및 객체를 생성함
* SQL 구현
  - 데이터의 삽입, 변경, 삭제 등의 작업을 수핼할 SQL문을 생성하는 과정
  - SQL문은 소스 코드 내에 직접 입력, 또는 별도의 XML 파일로 관리함
* DAO 구현
  - 데이터베이스에 접근하고, SQL을 활용하여 데이터를 실제로 조작하는 코드를 구현하는 과정
* Service 구현
  - 사용자의 요청에 응답하기 위한 로직을 구현하는 과정
* Controller 구현
  - 사용자의 요청에 적절한 서비스를 호출하여, 그 결과를 사용자에게 반환하는 코드를 구현하는 과정정

배치 프로그램
======

&ensp;**배치 프로그램(Batch Program)**은 사용자와의 상호 작용 없이 **여러 작업들을 미리 정해진 일련의 순서에 따라 일관적으로 처리하도록 만든 프로그램**을 의미한다. 배치 프로그램의 필수 요소는 다음과 같다.
* 대용량 데이터: 대량의 데이터를 가져오거나, 전달하거나, 계산하는 등의 처리가 가능해야 한다.
* 자동화: 심각한 오류가 발생하는 상황을 제외하고는 사용자의 개입 없이 수행되어야 한다.
* 견고성: 잘못된 데이터나 데이터 중복 등의 상황으로 중단되는 일 없이 수행되어야 한다.
* 안정성/신뢰성: 오류가 발생하면 오류의 발생 위치, 시간 등을 추적할 수 있어야 한다.
* 성능: 다른 응용 프로그램의 수행을 방해하지 않아야 하고, 지정된 시간 내에 처리가 안료되어야 한다.

&ensp;**배치 스케줄러(Batch Scheduler)**는 **일괄 처리(Batch Processing) 작업이 설정된 주기에 맞춰 자동으로 수행되도록 지원해주는 도구**이다. 특정 업무(Job)를 원하는 시간에 처리할 수 있도록 지원한다는 특성 때문에 잡 스케줄러(Job Scheduler)라고도 불린다. 주로 사용되는 배치 스케줄러는 다음과 같다.
* 스프링 배치(Spring Batch)
  - Spring Source 사와 Accenture 사가 공동 개발한 오픈 소스 프레임워크이다.
  - 로그 관리, 추적, 트랜잭션 관리, 작업 처리 통계, 작업 재시작 등의 다양한 기능을 제공한다.
* Quartz
  - 스프링 프레임워크로 개발되는 응용 프로그램들의 일괄 처리를 위한 다양한 기능을 제공하는 오픈 소스 라이브러리이다.
  - 수행할 작업과 수행 시간을 관리하는 요소들을 분리하여 일괄 처리 작업에 유연성을 제공한다.
* Cron
  - 리눅스의 기본 스케줄러 도구이다.
  - crontab 명령어를 통헤 작업을 예약할 수 있다.