---
title: "소프트웨어 설계 3장 애플리케이션 설계"
excerpt: "애플리케이션 설계"

wirter: Myeongwoo Yoon
categories:
  - 정보처리기사
tags:
  - 정보처리기사

toc: true
toc_sticky: true
 
date: 2024-02-23
last_modified_at: 2024-02-23
---

소프트웨어 아키텍처
======

소프트웨어 아키텍처의 설계
------
　**소프트웨어 아키텍처**는 소프트웨어의 골격이 되는 기본 구조이자,소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체이다. 소프트웨어 개발 시 적용되는 원칙과 지침이며, 이해 관계자들의 의사소통 도구로 활용된다. 소프트웨어 아키텍처의 설계는 기본적으로 좋은 품질을 유지하면서 사용자의 비기능적 요구사항으로 나타난 제약을 반영하고, 기능적 요구사항을 구현하는 방법을 찾는 해결 과정이다. 애플리케이션의 분할 방법과 분할된 모듈에 할당될 기능, 모듈 간의 인터페이스 등을 결정한다. 소프트웨어 아키텍처 설게의 기본 원리로는 모듈화, 추상화, 단계적 분해, 정보은닉이 있다.

| |상위 설계|하위 설계|
|---|---|---|
|별칭|아키텍처 설계, 예비 설계|모듈 설계, 상세 설계|
|설계 대상|시스템의 전체적인 구조|시스템의 내부 구조 및 행위|
|세부 목록|구조, DB, 인터페이스|컴포넌트, 자료 구조, 알고리즘|

모듈화(Modularity)
------
　**모듈화**란 소프트웨어의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈단위로 나누는 것을 의미한다. 자주 사용되는 계산식이나 사용자 인증과 같은 기능들을 공통 모듈로 구성하여 프로젝트의 재사용성을 향상시킬 수 있다. 모듈의 크기를 너무 작게 나누면 개수가 많아져 모듈 간의 통합 비용이 많이 들고, 너무 크게 나누면 개수가 적어 통합 비용은 적게 들지만 모듈 하나의 개발 비용이 많이 든다. 모둘화를 통해 기능의 분리가 가능하여 인터페이스가 단순해진다. 모듈화를 통해 프로그램의 효율적인 관리가 가능하고 오류의 파급 효과를 최소화 할 수 있다.

추상화(Abstraction)
------
　**추상화**는 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화시켜 나가는 것이다. 인간이 복잡한 문제를 다룰 때 가장 기본적으로 사용하는 방법으로, 완전한 시스템을 구축하기 전에 그 시스템과 유사한 모델을 만들어서 여러 가지 요인들을 테스트할 수 있다. 추상화는 최소의 비용으로 실제 상황에 대처할 수 있고, 시스템의 구조 및 구성을 대략적으로 파악할 수 있게 해준다. 추사화의 유형은 다음과 같다.
* **과정 추상화**: 자세한 수행 과정을 정의하지 않고, 전반적인 흐름만 파악할 수 있게 설계하는 방법
* **데이터 추상화**: 데이터의 세부적인 속성이나 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법
* **제어 추상화**: 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체하는 방법

단계적 분해(Stepwise Refinement)
------
　**단계적 분해**는 Niklaus Wirth에 의해 제안된 하향식 설계 전략으로, 문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법이다. 추상화 반복에 의해 세분화된다. 소프트웨어의 기능에서부터 시작하여 점차적으로 구체화하고, 알고리즘, 자료 구조 등 상세한 내역은 가능한 한 뒤로 미루어 진행한다.

정보 은닉(Information Hiding)
------
　**정보 은닉**은 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법이다. 어떤 모듈이 소프트웨어 기능을 수행하는데 반드시 필요한 기능이 있어 정보 은닉된 모듈과 커뮤니케이션 할 필요가 있을 때는 필요한 정보만 인터페이스를 통해 주고 받는다. 정보 은닉을 통해 모듈을 독립적으로 수행할 수 있고, 하나의 모듈이 변경되더라도 다른 모듈에 영향을 주지 않으므로 수정, 시험, 유지보수가 용이하다.

소프트웨어 아키텍처의 품질 속성
------
　**소프트웨어 아키텍처의 품질 속성**은 소프트웨어 아키텍서가 이해 관계자들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계되었는지를 확인하기 위해 품질 평가 요소들을 시스템 측면, 비지니스 측면, 아케텍처 측면으로 구분하여 구체화시켜 놓은 것이다.
* 시스템 측면

  |품질 속성|내용|
  |---|---|
  |성능|사용자의 요청과 같은 이벤트가 발생했을 때, 이를 적정하고 빠르게 처리하는 것이다.|
  |보안|허용되지 않은 접근을 막고, 허용된 접근에는 적절한 서비스를 제공하는 것이다.|
  |가용성|장애 없이 정상적으로 서비스를 제공하는 것이다.|
  |기능성|사용자가 요구한 기능을 만족스럽게 구현하는 것이다.|
  |사용성|사용자가 소프트웨어를 사용하는데 헤매지 않도록 명확하고 편리하게 구현하는 것이다.|
  |변경 용이성|소프트웨어가 처음 설계 목표화 다른 하드웨어나 플랫폼에서도 동작할 수 있도록 구현하는 것이다.|
  |확장성|시스템의 용량, 처리능력 등을 확장시켰을 때 이를 효과적으로 활용할 수 있도록 구현하는 것이다.|
  |기타 속성|테스트 용이성, 배치성, 안정성 등이 있다.|

* 비지니스 측면

  |품질 속성|내용|
  |---|---|
  |시장 적시성|정해진 시간에 맞춰 프로그램을 출시하는 것이다.|
  |비용과 혜택|개발 비용을 더 투자하여 유연성이 높은 아키텍처를 만들 것인지를 결정하는 것이다.<br/> 유연성이 떨어지는 경우 유지보수에 많은 비용이 소모될 수 있다는 것을 고려해야 한다.|
  |예상 시스템 수명|시스템을 얼마나 오랫동안 사용할 것인지를 고려하는 것이다.<br/> 수명이 길어야 한다면 시스템 품질의 '변경 용이성', '확장성'을 중요하게 고려해야 한다.|
  |기타 속성|목표 시장, 공개 일정, 기존 시스템과의 통합 등이 있다.|

* 아키텍처 측면

  |품질 속성|내용|
  |---|---|
  |개념적 무결성|전체 시스템과 시스템을 이루는 구성요소들 간의 일관성을 유지하는 것이다.|
  |정확성, 완결성|요구사항과 요구사항을 구현하기 위해 발생하는 제약사항들을 모두 충족시키는 것이다.|
  |구축 가능성|모듈 단위로 구분된 시스템을 적절하게 분배하여 유연하게 일정을 변경할 수 있도록 하는 것이다.|
  |기타 속성|변경성, 시험성, 적응성, 일치성, 대체성 등이 있다.|

소프트웨어 아키텍처의 설게 과정
------
　아키텍처의 설계 과정은 설계 목표 설정, 시스템 타입 결정, 아키텍처 패턴 적용, 서브시스템 구체화, 검토 순으로 진행된다.
* **설계 목표 설정**: 시스템의 개발 방향을 명확히 하기 위해 설계에 영향을 주는 비지니스 목표, 우선순위 등의 요구사항을 분석하여 전체 시스템의 설계 목표를 설정한다.
* **시스템 타입 결정**: 시스템과 서브시스템의 타입을 결정하고, 설계 목표와 함께 고려하여 아키텍처 패턴을 선택한다.
  - 시스템 타입은 일반적으로 다음 네가지 타입으로 나눌 수 있다.
    + 대화형 시스템: 사용자의 요구사 발생하면 시스템이 이를 처리하고 반응하는 시스템
    + 이벤트 중심 시스템: 외부의 상태 변화에 따라 동작하는 시스템
    + 변환형 시스템: 데이터가 입력되면 정해진 작업들을 수행하여 결과를 출력하는 시스템
    + 객체 영속형 시스템: 데이터베이스를 사용하여 파일을 효과적으로 저장, 검색, 갱신할 수 있는 시스템
* **아키텍처 패턴 적용**: 아키텍처 패턴을 참조하여 시스템의 표준 아키텍처를 설계한다.
* **서스시스템 구체화**: 서브시스템의 기능 및 서브시스템 간의 상호작용을 위한 동작과 인터페이스를 정의한다.
* **검토**: 아키텍처가 설계 목표에 부합하는지, 요구사항이 잘 반영되었는지, 설계의 기본 원리를 만족하는지 등을 검토한다.

　**협약(Contract)에 의한 설계**는 컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것으로, 소프트웨어 컴포넌트에 대한 정확한 인터페이스를 명세한다.
* 선행 조건(Precondition): 오퍼레이션이 호출되기 전에 참이 되어야 할 조건
* 결과 조건(Postcondition): 오퍼레이션이 수행된 후 만족되어야 할 조건
* 불변 조건(Invariant): 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건

아키텍처 패턴
======

아키텍처 패턴(Patterns)의 개요
------
　**아키텍처 패턴**은 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미한다. 아키텍처 패턴은 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽을 제시한다. 아키텍처 패턴에는 서브시스템들과 그 역할이 정의되어 있으며, 서브시스템 사이의 관계와 여러 규칙, 지침 등이 포함되어 있다. 아키텍처 스타일 또는 표준 아키텍처라고도 한다.
　아키텍처 패턴의 장점은 다음과 같다.
* 시행착오를 줄여 개발 시간을 단축시키고, 고품질의 소프트웨어를 생산할 수 있다.
* 검증괸 구조로 개발하기 때문에 안정적인 개발이 가능하다.
* 이해관계자들이 공통된 아키텍처를 공유할 수 있어 의사소통이 간편해진다.
* 시스템의 구조를 이해하는 것이 쉬워 개발에 참여하지 않은 사람도 손쉽게 유지보수를 수행할 수 있다.
* 시스템의 특성을 개발 전에 예측하는 것이 가능해진다.

　아키텍처 패턴의 종류에는 레이어 패턴, 클라이언트-서버 패턴, 파이프-필터 패턴, 모델-뷰-컨트롤러 패턴 등이 있다.

레이터 패턴
------
　**레이어 패턴**은 시스템을 계층(Layer)으로 구분하여 구성하는 고전적인 방법 중의 하나다. 레이어 패턴은 각각의 서브시스템들이 계층 구조를 이루며, 하위 계층은 상위 계층에 대한 서비스 제공하자 되고, 상위 계층은 하위 계층의 클라이언트가 된다. 레이어 패턴은 서로 마주보는 두 개의 계층 사이에서만 상호작용이 이루어지며, 변경 사항을 적용할 때도 서로 마주보는 두개의 계층에만 영향을 미치므로 변경 작업이 용이하고 특정 계층만을 교체해 시스템을 개선하는 것이 가능하다. 대표적으로 OSI 참조 모델이 있다.

클라이언트-서버 패턴
------
　**클라이언트-서버 패턴**은 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴이다. 사용자는 클라이언트와만 의사소통을 한다. 즉 사용자가 클라이언트를 통해 서버에 요청하고 클라이언트가 응답을 받아 사용자에게 제공하는 방식으로 서비스를 제공한다. 서버는 클라이언트의 요청에 대비해 항상 대기 상태를 유지해야 한다. 클라이언트나 서버는 요청과 응답을 받기 위해 동기화되는 경우를 제외하고는 서로 독립적이다.

파이프-필터 패턴
------
　**파이프-필터 패턴**은 데이터 스크림 절차의 각 단계를 필터(Filter) 컴포넌트로 캡슐화하여 파이프(Pipe)를 통해 데이터를 전송하는 패턴이다. 필터 컴포넌트는 재사용성이 좋고, 추가가 쉬워 확장이 용이하다. 필터 컴포넌트들을 재배치하여 다양한 파이프라인을 구축하는 것이 가능하다. 파이프-필터 패턴은 데이터 변환, 버퍼링, 동기화 등에 주로 사용된다. 필터 간 데이터 이동 시 데이터 변환으로 인한 오버헤드가 발생한다. 대표적으로 UNIX, 쉘(Shell)이 있다.

모델-뷰-컨트롤러 패턴
------
　**모델-뷰-컨트롤러 패턴**은 서브시스템을 3개의 부분으로 구조화하는 패턴이며, 각 부분의 역할은 다음과 같다.
* **모델(Model)**: 서브시스템의 핵심 기능과 데이터를 보관한다.
* **뷰(View)**: 사용자에게 정보를 표시한다.
* **컨트롤러(Controller)**: 사용자로부터 입력된 변경 요청을 처리하기 위해 모델에게 명령을 보낸다.

　모델-뷰-컨트롤러 패턴의 각 부분은 별도의 컴포넌트로 분리되어 있으므로 서로 영향을 받지 않고 개발 작업을 수행할 수 있고 여러 개의 뷰를 만들 수 있으므로 한 개의 모델에 대해 여러 개의 뷰를 필요로 하는 대화형 애플리케이션에 적합하다.

기타 패턴
------
* **마스터-슬레이브 패턴(Master-Slave Pattern)**
  - 마스터 컴포넌트는 동일한 구조의 슬레이브 컴포넌트로 작업을 분할한 후, 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행하는 패턴이다.
  - 마스터 컴포넌트는 모든 작업의 주체이고, 슬레이브 컴포넌트는 마스터 컴포넌트의 지시에 따라 작업을 수행하여 결과를 반환한다.
  - 장애 허용 시스템에서 주로 활용된다.
* **브로커 패턴(Broker Patttern)**
  - 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결해준다.
  - 원격 서비스 호출에 응답하는 컴포넌트들이 여러 개 있을 때 적합한 패턴이다.
  - 분산 환경 시스템에서 주로 활용된다.
* **피어-투-피어 패턴(Peer-To-Peer Pattern)**
  - 피어(Peer)를 하나의 컴포넌트로 간주하며, 각 피어는 서비스를 호출하는 클라이언트가 될 수도, 서비스를 제공하는 서버가 될 수도 있는 패턴이다.
  - 피어-투-피어 패턴에서 클라이언트와 서버는 전형적인 멀티스레딩 방식을 사용한다.
* **이벤트-버스 패턴(Event-Bus Pattern)**
  - 소스가 특정 채널에 이벤트 메시지를 발행(Publish)하면, 해당 채널을 구독(Subscribe)한 리스너들이 메시지를 받아 이벤트를 처리하는 방식이다.
  - 4가지 주요 컴포넌트
    + 이벤트를 생성하는 소스(Source)
    + 이벤트를 수행하는 리스너(Listener)
    + 이벤트의 통로인 채널(Channel)
    + 채널들을 관리하는 버스(Bus)
* **블랙보드 패턴(Blackboard Pattern)**
  - 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 형태로, 컴포넌트들은 검색을 통해 블랙보드에서 원하는 데이터를 찾을 수 있다.
  - 해결책이 명확하지 않은 문제를 처리하는데 유용한 패턴이다.
  - 음성 인식, 차량 식별, 신호 해석 등에 주로 활용된다.
* **인터프리터 패턴(Interpreter Pattern)**
  - 프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성된다.
  - 특정 언어로 작성된 프로그램 코드를 해석하는 컴포넌트를 설계할 때 사용되어진다.

객체지향(Object-Oriented)
======

객체지향의 개요
------
　**객체지향**은 현실 세계의 개체(Entity)를 기계의 부품처럼 하나의 객체(Object)로 만들어, 기계적인 부품들을 조립하여 제품을 만들 듯이 소프트웨어를 개발할 때에도 객체들을 조립해서 작성할 수 있는 기법을 말한다.
* 객체지향 기법은 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택되어 사용되고 있다.
* 소프트웨어의 재사용 및 확장이 용이하여 고품질의 소프트웨어를 빠르게 개발할 수 있고 유지보수가 쉽다.
* 복잡한 구조를 단계적, 계층적으로 표현하고, 멀티미디어 데이터 및 병렬 처리를 지원한다.
* 현실 세계를 모형화하므로 사용자와 개발자가 쉽게 이해할 수 있다.
* 주요 구성 요소와 개념에는 객체(Object), 클래스(Class), 캡슐화(Encapsulation), 상속(Inheritance), 다형성(Polymorphism), 연관성(Relationship)이 있다.

객체(Object)
------
　**객체**는 데이터와 데이터를 처리하는 함수를 묶어 놓은(캡슐화한) 하나의 소프트웨어 모듈이다.
* 데이터
  - 객체가 가지고 있는 정보로 속성이나 상태, 분류 등을 나타낸다.
  - 속성(Attribute), 상태, 변수, 상수, 자료 구조라고도 한다.
* 함수
  - 객체가 수행하는 기능으로 객체가 갖는 데이터(속성, 상태)를 처리하는 알고리즘이다.
  - 객체의 상태를 참조하거나 변경하는 수단이 되는 것으로 메소드(Method), 서비스(Service), 동작(Operation), 연산이라고도 한다.

　객체의 특성은 다음과 같다.
* 객체는 독립적으로 식별 가능한 이름을 가지고 있다.
* 객체가 가질 수 있는 조건을 상태(State)라고 하고 시간에 따라 변한다.
* 객체와 객체는 상호 연관성에 의한 관계가 형성된다.
* 객체가 반응할 수 있는 메시지(Message)의 집합을 행위라고 하며, 객체는 행위의 특징을 나타낼 수 있다.
* 객체는 일정한 기억장소를 가지고 있다.

클래스(Class)
------
　**클래스**는 공통된 속성과 연산(행위)을 갖는 객체의 집합으로, 객체의 일반적인 타입(Type)을 의미한다.
* 클래스는 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀이다.
* 클래스는 객체지향 프로그램에서 데이터를 추상화하는 단위이다.
* 클래스에 속한 각각의 객체를 인스턴스(Instance)라 하며, 클래스로부터 새로운 객체를 생성하는 것을 인스턴스화(Instantiation)라고 한다.
* 동일 클래스에 속한 각각의 객체(인스턴스)들은 공통된 속성과 행위를 가지고 있으면서, 그 속성에 대한 정보가 서로 달라서 동일 기능을 하는 여러 가지 객체를 나타내게 된다.
* 최상위 클래스는 상위 클래스를 갖지 않는 클래스를 의미한다.
* 슈퍼 클래스(Super Class)는 특정 클래스의 상위(부모) 클래스이고, 서브 클래스(Sub Class)는 특정 클래스의 하위(자식) 클래스를 의미한다.

캡슐화(Encapsulation)
------
　**캡슐화**는 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것을 의미한다.
* 캡슐화된 객체는 인터페이스를 제외한 세부 내용이 은폐(정보 은닉)되어 외부에서의 접근이 제한적이기 때문에 외부 모듈의 변경으로 인한 파급 효과가 적다/
* 캡슐화된 객체들은 재사용이 용이하다.
* 객체들 간의 메시지를 주고받을 때 상대 객체의 세부 내용은 알 필요가 없으므로 인터페이스가 단순해지고, 객체 간의 결합도가 낮아진다.

상속(Inheritance)
------
　**상속**은 이미 정의된 상위 클래스(부모 클래스)의 모든 속성과 연산을 하위 클래스(자식 클래스)가 물려받는 것이다.
* 상속을 이용하면 하위 클래스는 상위 클래스의 모든 속성과 연산을 자신의 클래스 내에서 다시 정의하지 않고서도 즉시 자신의 속성으로 사용할 수 있다.
* 하위 클래스는 상위 클래스로부터 상속받은 속성과 연산 외에 새로운 속성과 연산을 첨가하여 사용할 수 있다.
* 상위 클래스의 속성과 연산을 하위 클래스가 사용할 수 있기 때문에 객체와 클래스의 재사용, 즉 소프트웨어의 재사용(Reuse)을 높이는 중요한 개념이다.
* **다중 상속(Multiple Inheritance)**은 한 개의 클래스가 두 개 이상의 상위 클래스로부터 속성과 연산을 상속받는 것이다.

다형성(Polymorphism)
------
　**다형성**은 메시지에 의해 객체(클래스)가 연산을 수행하게 될 때 하나의 메시지에 대해 각각의 객체(클래스)가 가지고 있는 고유한 방법(특성)으로 응답할 수 있는 능력을 의미한다.
* 객체(클래스)들은 동일한 메소드명을 사용하며 같은 의미의 응답을 한다.
* 응용 프로그램 상에서 하나의 함수나 연산자가 두 개 이상의 서로 다른 클래스의 인스턴스들을 같은 클래스에 속한 인스턴스처럼 수행할 수 있도록 하는 것이다.

연관성(Relationship)
------
　**연관성**은 두 개 이상의 객체(클래스)들이 상호 참조하는 관계를 말하며 종류는 다음과 같다.

|종류|의미|특징|
|---|---|---|
|is member of|연관화(Association)|2개 이상의 객체가 상호 관련되어 있음을 의미함|
|is instance of|분류화(Classfication)|동일한 형의 특성을 갖는 객체들을 모아 구성하는 것|
|is part of|집단화(Aggregation)|관련 있는 객체들을 묶어 하나의 상위 객체를 구성하는 것|
|is a|일반화<br/>특수화/상세화(Specialization)|공통적인 성질들로 추상화한 객체들을 구성하는 것<br/>상위 객체를 구체화하는 것|

객체지향 분석 및 설계
======

객체지향 분석의 개념
------
　**객체지향 분석(OOA; Object Oriented Analysis)**은 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스(객체), 이와 관련된 속성과 연산, 그들 간의 관계 등을 정의하여 모델링하는 작업이다. 소프트웨어를 개발하기 위한 비지니스를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석한다. 분석가에게 중요한 모델링 구성 요소인 클래스, 객체, 속성, 연산들을 표현해서 문제를 모형화할 수 있게 해준다. 객체는 클래스로부터 인스턴스화되고, 이 클래스를 식별하는 것이 객체지향 분석의 주요한 목적이다.

객체지향 분석의 방법론
------
* **럼바우(Rumbaugh) 방법**
  - 가장 일반적으로 사용되는 방법으로 분석 활동을 객체 모델, 동적 모델, 기능 모델로 나누어 수행하는 방법이다.
* **Booch(부치) 방법**
  - 미시적(Micro) 개발 프로세스와 거시적(Macro) 개발 프로세스를 모두 사용하는 분석 방법으로, 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의한다.
* **Jacobson 방법**
  - Use Case를 강조라여 사용하는 분석 방법이다.
* **Coad와 Yourdon 방법**
  - E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성하는 기법이다.
* **Wirfs-Brock 방법**
  - 분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속저으로 수행하는 기법이다.

럼바우(Rumbaugh)의 분석 기법
------
　**럼바우의 분석 기법**은 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법으로, 객체 모델링 기법(OMT, Object-Modeling Technique)이라고도 한다. 분석 활동은 '객체 모델링, 동적 모델링, 기능 모델링' 순으로 통해 이루어진다.
* **객체 모델링**
  - 정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 것이다.
* **동적 모델링**
  - 상태 다이어그램(상태도)을 이용하여 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적 행위를 표현하는 모델링이다.
* **기능 모델링**
  - 자료 흐름도(DFD)를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링이다.

객체지향 설계 원칙
------
　객체지향 설계의 원칙은 시스템 변경이나 확장에 유연한 시스템을 설계하기 위해 지켜야할 다섯 가지 원칙으로, SOLID 원칙이라고도 불린다.
* **단일 책임 원칙(SRP,Single Responsibility Principle)**
  - 객체는 단 하나의 책임만 가져야 한다는 원칙이다.
  - 응집도는 높고, 결합도는 낮게 설계하는 것을 의미한다.
* **개방-폐쇄 원칙(OCP, Open-Closed Principle)**
  - 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 한다는 원칙이다.
  - 공통 인터페이스를 하나의 인터페이스로 묶어 캡슐화하는 방법이 대표적이다.
* **리스코프 치환 원칙(LSP, Liskov Substitution Principle)**
  - 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다는 설계 원칙이다.
  - 자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행하도록 해야한다.
* **인터페이스 분리 원칙(ISP, Interface Segregation Principle)**
  - 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 원칙이다.
  - 단일 책임 원칙이 객체가 갖는 하나의 책임이라면, 인터페이스 분리 원칙은 인터페이스가 갖는 하나의 책임이다.
* **의존 역전 원칙(DIP, Dependency Inversion Principle)**
  - 각 개체들 간의 의존 관계가 성립될 때, 추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어야 한다는 원칙이다.
  - 일반적으로 인터페이스를 활용하면 이 원칙은 준수된다.

모듈
======

모듈(Module)의 개요
------
　**모듈**은 모듈화를 통해 분리된 시스템의 각 기능들로, 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위 등과 같은 의미로 사용된다.
* 모듈은 단독으로 컴파일이 가능하며, 재사용할 수 있다.
* 모듈의 기능적 독립성은 소프트웨어를 구성하는 각 모듈의 기능이 서로 독립됨을 의미하는 것으로, 모듈이 하나의 기능만을 수행하고 다른 모듈과의 과도한 상호작용을 배제함으로써 이루어진다.
* 독립성이 높은 모듈일수록 모듈을 수정하더라도 다른 모듈들에게는 거의 영향을 미치지 않으며, 오류가 발생해도 쉽게 발견하고 해결할 수 있다.
* 모듈의 독립성은 결합도(Coupling)와 응집도(Cohesion)에 의해 측정되며, 독립성을 높이려면 모듈의 결합도는 약하게, 응집도는 강하게, 모듈의 크기는 작게 만들어야 한다. 

결합도(Coupling)
------
　**결합도**는 모듈 간의 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계를 의미한다.
* 다양한 결합으로 모듈을 구성할 수 있으나 결합도가 약할수록 품질이 높고, 강할수록 품질이 낮다.
* 결합도가 강하면 시스템 구현 및 유지보수 작업이 어렵다.
* 결합도의 종류
  - **자료 결합도(Data Coupling)**
    + 모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도이다.
    + 어떤 모듈이 다른 모듈을 호출하면서 매개 변수나 인수로 데이터를 넘겨주고, 호출 받은 모듈은 받은 데이터에 대한 처리 결과를 다시 돌려주는 방식이다.
    + 모듈 간의 내용을 전혀 알 필요가 없는 상태로서 한 모듈의 내용을 변경하더라고 다른 모듈에는 전혀 영향을 미치지 않는 가장 바람직한 결합도이다.
  - **스탬프(검인) 결합도(Stamp Coupling)**
    + 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도이다.
    + 두 모듈이 동일한 자료 구조를 조화하는 경우의 결합도이며, 자료 구조의 어떠한 변화, 즉 포맷이나 구조의 변화는 그것을 조화하는 모든 모듈 및 변화되는 필드를 실제로 조회하지 않는 모듈에까지도 영향을 미치게 된다.
  - **제어 결함도(Control Coupling)**
    + 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호를 이용하여 통신하거나 제어 요소(Function Code, Switch, Flag)를 전달하는 결합도이다.
    + 한 모듈이 다른 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우나 처리 기능이 두 모듈에 분리되어 설계된 경우에 발생한다.
    + 하위 모듈에서 상위 모듈로 제어 신호가 이동하여 하위 모듈이 상위 모듈에게 처리 명령을 내리는 권리 전도현상이 발생하게 된다.
  - **외부 결함도(External Coupling)**
    + 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도이다.
    + 참조되는 데이터의 범위를 각 모듈에서 제한할 수 있다.
  - **공통(공유) 결함도(Common Coupling)**
    + 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도이다.
    + 공통 데이터 영역의 내용을 조금만 변경하더라고 이를 사용하는 모든 모듈에 영향을 미치므로 모듈의 독립성을 약하게 만든다.
  - **내용 결함도(Content Coupling)**
    + 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도이다.
    + 한 모듈에서 다른 모듈의 내부로 제어가 이동하는 경우에도 내용 결합도에 해당한다.
  <p align="center"><img src="/assets/img/정보처리기사/소프트웨어 설계/3장 애플리케이션 설계/5-1.jpeg" width="600"></p>

응집도(Cohesion)
------
　**응집도**는 정보 은닉 개념을 확장한 것으로, 명령어나 호출문 등 모듈의 내부 요소들의 서로 관련되어 있는 정도, 즉 모듈이 독립적인 기능으로 정의되어 있는 정도를 의미한다. 다양한 기준으로 모듈을 구성할 수 있으나 응집도가 강할수록 품질이 높고, 약할수록 품질이 낮다. 응집도의 종류는 다음과 같다.
* **우연적 응집도(Coincidental Cohesion)**
  - 모듈 내부의 각 구성 요소들이 서로 관련 없는 요소들로만 구성된 경우의 응집도
* **논리적 응집도(Logical Cohesion)**
  - 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 현성되는 경우의 응집도
* **시간적 응집도(Temporal Cohesion)**
  - 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도
* **절차적 응집도(Procedural Cohesion)**
  - 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 순차적으로 수행할 경우의 응집도
* **교환(통신)적 응집도(Communication Cohesion)**
  - 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도
* **순차적 응집도(Sequential Cohesion)**
  - 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도
* **기능적 응집도(Functional Cohesion)**
  - 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도
<p align="center"><img src="/assets/img/정보처리기사/소프트웨어 설계/3장 애플리케이션 설계/5-2.jpeg" width="600"></p>

팬인(Fan-In)/팬아웃(Fan-out)
------
　**팬인**은 어떤 모듈을 제어(호출)하는 모듈의 수를 나타내고 **팬아웃**은 어떤 모듈에 의해 제어(호출)되는 모듈의 수를 나타낸다. 팬인과 팬아웃을 분석하여 시스템의 복잡도를 알 수 있다. 팬인이 높다는 것은 재사용 측면에서 설계가 잘 되어있다고 볼 수 있으나, 단일 장에점이 발생할 수 있으므로 중첩적인 관리 및 테스트가 필요하다. 팬아웃이 높은 경우 불필요하게 다른 모듈을 호출하고 있는지 검토하고, 단순화시킬 수 있는지 여부에 대한 검토가 필요하다. 시스템의 복잡도를 최적화하려면 팬인은 높게, 판아웃은 낮게 설계해야 한다.

N-S 차트(Nassi-Schneidermon Chart)
------
　**N-S 차트**는 논리의 기술에 중첩을 둔 도형을 이용한 표현 방법으로 박스 다이어그램, Chain Chart라고도 한다.
* 연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조를 표현한다.
* GOTO나 화살표를 사용하지 않는다.
* 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는 데 적합하다.
* 선택과 반복 구조를 시각적으로 표현한다.
* 이해하기 쉽고, 코드 변환이 용이하다.
* 읽기는 쉽지만 작성하기가 어려우며, 임의로 제어를 전이하는 것이 불가능하다.
* 총체적인 구조 표현과 인터페이스를 나타내기가 어렵다.
* 단일 입구와 단일 출구로 표현한다.

공통 모듈
======

코드
======

코드(Code)의 개요
------
　**코드**는 컴퓨터를 이용하여 자료를 처리하는 과정에서 분류, 조합 및 집계를 용이하게 하고, 특정 자료의 추출을 쉽게 하기 위해서 사용하는 기호이다.
* 코드는 정보를 신속, 정확, 명료하게 전달할 수 있게 한다.
* 코드는 일정한 규칙에 따라 작성되며, 정보 처리의 효율과 처리된 정보의 가치에 많은 영향을 미친다.
* 일반적인 코드의 예로는 주민등록번호, 학번, 전화번호 등이 있다.
* 코드의 주요 기능
  - 식별 기능: 데이터 간의 성격에 따라 구분이 가능하다.
  - 분류 기능: 특정 기준이나 동일한 유형에 해당하는 데이터를 그룹화 할 수 있다/
  - 배열 기능: 의미를 부여하여 나열할 수 있다.
  - 표준화 기능: 다양한 데이터를 기준에 맞추어 표현할 수 있다.
  - 간소화 기능: 복잡한 데이터를 간소화 할 수 있다.

코드의 종류
------
* **순차 코드(Sequence Code)**
  - 자료의 발생 순서, 크기 순서 등 일정 기준에 따라서 최초의 자료부터 차례로 일련번호를 부여하는 방법으로, 순서 코드 또는 일련번호 코드라고도 한다.
* **블록 코드(Block Code)**
  - 코드화 대상 항목 중에서 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 방법으로, 구분 코드라고도 한다.
* **10진 코드(Decimal Code)**
  - 코드화 대상 항목을 0~9까지 10진 분할 하고, 다시 그 각각에 대하여 10진 분할하는 방법을 필요한 만큼 반복하는 방법으로, 도서 분류식 코드라고도 한다.
* **그룹 분류 코드(Group Classification Code)**
  - 코드화 대상 항목을 일정 기준에 따라 대분류, 중분류, 소분류 등으로 구분하고, 각 그룹 안에서 일련번호를 부여하는 방법이다.
* **연상 코드(Mnemonic Code)**
  - 크드화 대상 항목의 명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용하여 코드를 부여하는 방법이다.
* **표의 숫자 코드(Significant Digit Code)**
  - 코드화 대상 항목의 성질, 즉 길이, 넓이, 부피, 지름, 높이 등의 물리적인 수치를 그대로 코드에 적용시키는 방법으로 유효 숫자 코드라고도 한다.
* **합성 코드(Combined Code)**
  - 필요한 기능을 하나의 코드로 수행하기 어려운 경우 2개 이상의 코드를 조합아여 만드는 방법이다.

코드 부여 체계
------
　코드 부여 체계는 이름만으로 개체의 용도와 적용 범위를 알 수 있도록 코드를 부여하는 방식을 말한다. 각 개체에 유일한 코드를 부여하여 개체들의 식별 및 추출을 용이하게 한다. 코드를 부여하기 전에 각 단위 시스템의 고유한 코드와 개체를 나타내는 코드 등이 정의되어야 한다. 코드 부여 체계를 담당하는 자는 코드의 자릿수와 구분자, 구조 등을 상세하게 명시해야 한다. 

디자인 패턴
======