---
title: "소프트웨어 개발 3장 제품 소프트웨어 패키징"
excerpt: "제품 소프트웨어 패키징"

wirter: Myeongwoo Yoon
categories:
  - 정보처리기사
tags:
  - 정보처리기사

toc: true
toc_sticky: true
 
date: 2024-02-25
last_modified_at: 2024-02-25
---

소프트웨어 패키징
======

소프트웨어 패키징의 개요
------
　소프트웨어 패키징이란 모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것을 말한다. 개발자가 아니라 사용자를 중심으로 진행하고 소스 코드는 향후 관리를 고려하여 모듈화해 패키징한다. 사용자가 소프트웨어를 사용하게 될 환경을 이해하여, 다양한 환경에서 소프트웨어를 손쉽게 사용할 수 있도록 일반적인 배포 형태로 패키징한다.

패키징 시 고려사항
------

* 사용자의 시스템 환경, 즉 운영체제(OS), CPU, 메모리 등에 필요한 최소 환경을 정의한다.
* UI는 사용자가 눈으로 직접 확인할 수 있도록 시각적인 자료와 함께 제공하고 매뉴얼과 일치시켜 패키징한다.
* 소프트웨어는 단순히 패키징하여 배포하는 것으로 끝나는 것이 아니라 하드웨어와 함께 관리될 수 있도록 Managed Service 형태로 제공하는 것이 좋다.
* 사용자에게 배포되는 소프트웨어이므로 내부 콘텐츠에 대한 암호화 및 보안을 고려한다.
* 다른 여러 콘텐츠 및 단말기 간 DRM(디지털 저작권 관리) 연동을 고려한다.
* 사용자의 편의성을 위한 복잡성 및 비효율성 문제를 고려한다.
* 제품 소프트웨어 종류에 적합한 암호화 알고리즘을 작성한다.

패키징 작업 순서
------
　패키징 주기는 소프트웨어 개발 기법에 따라 달라지는데, 짧은 개발 주기를 반복하는 애자일 기법인 경우에는 보통 2~4주 내에서 지정하며, 각 주기가 끝날 때마다 패키징을 수행한다. 프로젝트 개발 과정에서 주기별로 패키징한 결과물은 테스트 서버에 배포하고 마지막 개발 과정을 거쳐 최종 패키징한 결과물은 고객이 사용할 수 있도록 온라인 또는 오프라인으로 배포한다.
* **온라인 배포**: 별도로 마련한 운영 서버에 설치 및 사용 매뉴얼과 함께 배포 파일을 등록하여 고객이 직접 다운받아 사용할 수 있도록 한다.
* **오프라인 배포**: CD-ROM이나 DVD, USB 등에 설치 및 사용자 매뉴얼과 함께 배포 파일을 담는다.

　순서를 정리하면 다음과 같다.
* 기능 식별: 작성된 코드의 기능을 확인한다.
* 모듈화: 확인된 기능 단위로 코드들을 분류한다.
* 빌드 진행: 모듈 단위별로 실행 파일을 만든다.
* 사용자 환경 분석: 웹, 모바일, PC 등 소프트웨어가 사용될 환경이나 운영체제, CPU, RAM 등의 최소 운영 환경을 정의한다.
* 패키징 및 적용 시험: 빌드된 실행 파일들을 정의된 환경에 맞게 배포용 파일 형식으로 패키징하고 정의된 환경과 동일한 환경에서 패키징 결과를 테스팅한 후 소프트웨어에 대한 불편사항을 사용자 입장에서 확인한다.
* 패키징 변경 개선: 확인된 불편 사항을 반영하기 위한 패키징의 변경 및 개선을 진행한다.
* 배포: 배포 수행 시 오류가 발생하면 해당 개발자에게 전달하여 수정을 요청한다.

디지털 저작권 관리(DRM)
======

저작권의 개요
------
　저작권이란 소설, 시, 논문, 컴퓨터 프로그램 저작물 등에 대하여 창작자가 가지는 배타적 독점적 권리로 타인의 침해를 받지 않을 고유한 권한이다. 컴퓨터 프로그램들과 같이 복제하기 쉬운 저작물에 대해 불법 복제 및 배포 등을 막기 위한 기술적인 방법을 통칭해 저작권 보호 기술이라고 한다.

디지털 저작권 관리(DRM; Digital Right Management)의 개요
------
　디지털 저작권 관리는 저작권자가 배포한 디지털 콘텐츠가 저작권자가 의도한 용도로만 사용되도록 디지털 콘텐츠의 생성, 유통, 이용까지의 전 과정에 걸쳐 사용되는 디지털 콘텐츠 관리 및 보호 기술이다. 원본 콘텐츠가 아날로그인 경우에는 디지털로 변환한 후 패키저(Packager)에 의해 DRM 패키징을 수행한다.<br/>
　콘텐츠의 크기에 따라 음원이나 문서와 같이 크가가 작은 경우에는 사용자가 콘텐츠를 요청하는 시점에서 실시간으로 패키징을 수행하고, 크기가 큰 경우에는 미리 패키징을 수행한 후 배포한다. 패키징을 수행하면 콘텐츠에는 암호화된 저작권자의 전자서명이 포함되고 저작권자가 설정한 라이센스 정보가 클리어링 하우스(Clering House)에 등록된다. 사용자가 콘텐츠를 사용하기 위해서는 클리어링 하우스에 등록된 라이센스 정보를 통해 사용자 인증과 콘텐츠 사용 권한 소유 여부를 확인받아야 한다. 종량제 방식을 적용한 소프트웨어의 경우 클리어링 하우스를 통해 서비스의 실제 사용량을 측정하여 이용한 만큼의 요금을 부과한다.

디지털 저작권 관리의 흐름 및 구성 요소
------

<p align="center"><img src="/assets/img/정보처리기사/소프트웨어 개발/제품 소프트웨어 패키징/2-1.jpeg" width="600"></p>

* **클리어링 하우스(Clearing House)**: 저작권에 대한 사용 권한, 라이센스 발급, 암호화된 키 관리, 사용량에 따른 결제 관리 등을 수행하는 곳
* **콘텐츠 제공자(Contents Provider)**: 콘텐츠를 제공하는 저작권자
* **패키저(Packager)**: 콘텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램
* **콘텐츠 분배자(Contents Distributor)**: 암호화된 콘텐츠를 유통하는 곳이나 사람
* **콘텐츠 소비자(Customer)**: 콘텐츠를 구매해서 사용하는 주체
* **DRM 컨트롤러(DRM Controller)**: 배포된 콘텐츠의 이용 권한을 통제하는 프로그램
* **보안 컨테이너(Security Container)**: 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치

디지털 저작권 관리의 기술 요소
------
　디지털 저작권 관리를 위해 사용되는 기술은 다음과 같다.
* **암호화(Encryption)**: 콘텐츠 및 라이센스를 암호화하고 전자 서명을 할 수 있는 기술
* **키 관리(Key Management)**: 콘텐츠를 암호화한 키에 대한 저장 및 분배 기술
* **암호화 파일 생성(Packager)**: 콘텐츠를 암호화된 콘텐츠로 생성하기 위한 기술
* **식별 기술(Identification)**: 콘텐츠에 대한 식별 체계 표현 기술
* **저작권 표현(Right Expression)**: 라이센스의 내용 표현 기술
* **정책 관리(Policy Management)**: 라이센스 발급 및 사용에 대한 정책 표현 및 관리 기술
* **크랙 방지(Tamper Resistance)**: 크랙에 의한 콘텐츠 사용 방지 기술
* **인증(Authentication)**: 라이센스 발급 및 사용의 기준이 되는 사용자 인증 기술

소프트웨어 설치 매뉴얼 작성
======

소프트웨어 설치 매뉴얼의 개요
------
　소프트웨어 설치 매뉴얼은 개발 초기에서부터 적용된 기준이나 사용자가 소프트웨어를 설치하는 과정에 필요한 내용을 기록한 설명서와 안내서이다. 설치 매뉴얼을 사용자 기준으로 작성하고 설치 시작부터 완료할 때까지의 전 과정을 빠짐없이 순서대로 설명한다. 설치 과정에서 표시될 수 있는 오류 메시지 및 예외 상황에 관란 내용을 별도로 분류하여 설명한다.<br/>
　소프트웨어 설치 매뉴얼에는 목차 및 개요, 서문, 기본 사항 등이 기본적으로 포함되어야 한다. 소프트웨어 설치 매뉴얼의 목차에는 전체 설치 과정을 순서대로 요약한 후 관련 내용의 시작 페이지를 함께 기술한다. 소프트웨어 설치 매뉴얼의 개요에는 설치 매뉴얼의 주요 특징, 구성과 설치 방법, 순서 등의 내용을 기술한다.

서문
------
　서문에는 문서 이력, 설치 매뉴얼의 주석, 설치 도구의 구성, 설치 환경 체크 항목을 기술한다.
* **문서 이력**
* **설치 매뉴얼의 주석**: 주의 사항과 참고 사항을 기술한다.
  - 주의 사항: 소프트웨어를 설치할 때 사용자가 반드시 알고 있어야 하는 중요한 내용을 기술한다.
  - 참고 사항: 설치에 영향을 미칠 수 있는 사용자의 환경이나 상황에 대한 내용을 기술한다.
* **설치 도구의 구성**
  - exe, dll, ini, chm 등의 설치 관련 파일에 대해 설명한다.
  - 폴더 및 설치 프로그램 실행 파일에 대해 설명한다.
  - 설치 과정 및 결과가 기록되는 log 폴더에 대해 설명한다.
* **설치 환경 체크 항목**
  - 사용자 환경: CPU, Memory. OS 등
  - 응용 프로그램: 설치 전 다른 응용 프로그램 종료
  - 업그레이드 버전: 업그레이드 이전 버전에 대한 존재 유무 확인
  - 백업 폴더 확인: 데이터 저장 폴더를 확인하여 설치 시 폴더를 동기화시킴

기본 사항
------
　소프트웨어와 관련하여 기본적으로 설명되어야 할 항목들은 다음과 같다.
* **소프트웨어 개요**
  - 소프트웨어의 주요 기능 및 UI 설명
  - UI 및 화면 상의 버튼, 프레임 등을 그림으로 설명
* **설치 관련 파일**
  - 소프트웨어 설치에 필요한 파일 설명
  - exe, ini, log 등의 파일 설명
* **설치 아이콘(Installation)**
  - 설치 아이콘 설명
* **프로그램 삭제**
  - 설치된 소프트웨어의 삭제 방법 설명
* **관련 추가 정보**
  - 소프트웨어 이외의 관련 설치 프로그램 정보
  - 소프트웨어 제작사 등의 추가 정보 기술

설치 매뉴얼 작성 순서
------
* **기능 식별**
  - 소프트웨어의 개발 목적과 주요 기능을 흐름 순으로 정리하여 기록한다.
* **UI 분류**
  - 설치 매뉴얼을 작성할 순서대로 UI를 분류한 후 기록한다.
* **설치 파일/ 백업 파일 확인**
  - 폴더 위치, 설치 파일, 백업 파일 등의 개별적인 기능을 확인하여 기록한다.
* **Uninstall 절차 확인**
  - 직접 Unintall을 수행하면서 그 순서를 단계별로 자세히 기록한다.
* **이상 Case 확인**
  - 설치 과정에서 발생할 수 있는 다양한 Case를 만들어 확인하고 해당 Case에 대한 대처법을 자세하게 기록한다.
* **최종 매뉴얼 적용**
  - 설치가 완료된 화면과 메시지를 캡처하여 추가한다.
  - 완성된 매뉴얼을 검토하고 고객 지원에 대한 내용을 기록한다.

소프트웨어 사용자 매뉴얼 작성
======

소프트웨어 사용자 매뉴얼의 개요
------
　소프트웨어 사용자 매뉴얼은 사용자가 소프트웨어를 사용하는 과정에서 필요한 내용을 문서로 기록한 설명서와 안내서이다. 사용자 매뉴얼은 사용자가 소프트웨어 사용에 필요한 절차, 환경 등의 제반 사항이 모두 포함되도록 작성하고 소프트웨어 배포 후 발생될 수 있는 오류에 대한 패치나 기능에 대한 업그레이드를 위해 매뉴얼의 버전을 관리한다.<br/>
　개별적으로 동작이 가능한 컴포넌트 단위로 매뉴얼을 작성한다. 사용자 매뉴얼은 컴포넌트 명세서와 컴포넌트 구현 설계서를 토대로 작성하고 목차 및 개요, 서문, 기본 사항 등이 기본적으로 포함되어야 한다. 사용자 매뉴얼의 목차에는 매뉴얼 전체의 내용을 순서대로 요약한 후 관련 내용을 순서대로 요약한 후 관련 내용의 시작 페이지를 함께 기술한다. 사용자 매뉴얼의 개요에는 소프트웨어의 주요 특징, 매뉴얼의 구성과 실행 방법, 사용법, 항목별 점검 기준, 항목별 설정 방법 등에 대한 내용을 기술한다.

서문
------
　서문에는 문서 이력, 사용자 매뉴얼의 주석, 기록 보관을 위해 필요한 내용을 기술한다.
* **문서 이력**
* **사용자 매뉴얼의 주석**: 주의 사항과 참고 사항을 기술한다.
  - 주의 사항: 소프트웨어를 사용할 때 사용자가 반드시 알고 있어야 하는 중요한 내용을 기술한다.
  - 참고 사항: 특별한 사용자의 환경이나 상황에 대한 내용을 기술한다.
* **기록 보관 내용**
  - 소프트웨어를 사용하면서 필요한 기술 지원이나 추가 정보를 얻기 위한 소프트웨어 등록 정보를 기술한다.
  - 소프트웨어 등록 시 필요한 정보는 소프트웨어 명칭, 모델명, 문서 번호, 제품 번호, 구입 날짜 등이다.

기본 사항
------
* **소프트웨어 개요**
  - 소프트퉤어의 주요 기능 및 UI 설명
  - UI 및 화면 상의 버튼, 프레임 등을 그림으로 설명
* **소프트웨어 사용 환경**
  - 소프트웨어 사용을 위한 최소 환경 설명
  - CPU, 메모리 등의 PC 사양, 운영체제 버전 설명
  - 최초 구동에 대한 설명
  - 소프트웨어 사용 시 발생할 수 있는 프로그램 충돌이나 개인정보, 보안 등에 관한 주의사항을 설명한다.
* **소프트웨어 관리**
  - 소프트웨어의 사용 종료 및 관리 등에 관한 내용 설명
* **모멜, 버전별 특징**
  - 모델 및 버전별로 UI 및 기능의 차이점을 간락하게 요약한다.
* **기능, 인터페이스의 특징**
  - 제품의 기능과 인터페이스의 특징을 간략하게 요약한다.
* **소프트웨어 구동 환경**
  - 개발에 사용한 언어 및 호환 가능한 운영체제에 대해 설명한다.
  - 설치 후 구동하기까지의 과정을 운영체제별로 설명한다.

사용자 매뉴얼 작성 순서
------

* **작성 지침 정의**
  - 사용자 매뉴얼을 작성하기 위한 지침을 기록한다.
  - 작성 지침은 사용자 환경에 필요한 정보를 제공할 수 있는 형태로 기록한다.
* **사용자 매뉴얼 구성 요소 정의**
  - 소프트웨어의 기능, 구성 객체 목록, 객체별 메소드, 메소드의 파라미터, 실제 사용예, 사용자 환경 셋팅 방법 등을 기록한다.
* **구성 요소별 내용 작성**
  - 사용자 매뉴얼 구성 요소별로 내용을 기록한다.
* **사용자 매뉴얼 검토**
  - 작성된 구성 요소별 내용이 올바른지, 부족한 부분은 없는지 등을 검토하여 수정 및 보완한다.

소프트웨어 버전 등록
======

소프트웨어 패키징의 형상 관리
------
　**형상 관리(SCM; Software Configuration Mannagement)**는 소프트웨어의 개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 행동이다. 소프트웨어 변경의 원인을 알아내고 제어하며, 적절히 변경되고 있는지 확인하여 해당 담장자에게 통보한다. 형상 관리는 소프트웨어 개발의 전 단계에 적용되는 활동이며, 유지보수 단계에서도 수행한다.<br/>
　형상 관리는 소프트웨어 개발의 전체 비용을 줄이고, 개발 과정의 여러 방해 요인이 최소화되도록 보증하는 것을 목적으로 한다. 관리 항목에는 소스 코드 뿐만 아니라 프로젝트 계획, 분석서, 설계서, 프로그램, 테스트 케이스 등이 포함된다. 형상 관리를 통해 가시성과 추적성을 보장함으로써 소프트웨어의 생산성과 품질을 높일 수 있다. 대표적인 형상 관리 도구에는 Git, CVS, Subversion 등이 있다.

형상 관리의 중요성
------
* 지속적인 소프트웨어의 변경 사항을 체계적으로 추적하고 통제할 수 있다.
* 제품 소프트웨어에 대한 무절제한 변경을 방지할 수 있다.
* 제품 소프트웨어에서 발견된 버그나 수정 사항을 추적할 수 있다.
* 소프트웨어는 형태가 없어 가시성이 결핍되므로 진행 정도를 확인하기 위한 기준으로 사용될 수 있다.
* 소프트웨어의 배포본을 효율적으로 관리할 수 있다.
* 소프트웨어를 여러 명의 개발자가 동시에 개발할 수 있다.

형상 관리 기능
------
　형상 관리는 품질 보증을 위한 중요한 요소로서 다음과 같은 기능을 수행한다.
* **형상 식별**: 형상 관리 대상에 이름과 관리 번호를 부여하고, 계층(Tree) 구조로 구분하여 수정 및 추적이 용이하도록 하는 작업
* **버전 제어**: 소프트웨어 업그레이드나 유지 보수 과정에서 생성된 다른 버전의 형상 항목을 관리하고, 이를 위해 특정 절차와 도구(Tool)를 결합시키는 작업
* **형상 통제(변경 관리)**: 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선(Base Line)이 잘 반영될 수 있도록 조정하는 작업
* **형상 검사**: 기준선의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업
* **형상 기록(상태 보고)**: 형상의 식별, 통제, 감사 작업의 결과를 기록•관리하고 보고서를 작성하는 작업

소프트웨어의 버전 등록 관련 주요 기능
------
　소프트웨어 개발 과정에서 코드와 라이브러리, 관련 문서 등의 버전을 관리하기 위해 자료를 등록하고 갱신하는 과정에서 사용되는 주요 용어와 의미는 다음과 같다.
* **저장소(Repository)**
  - 최신 버전의 파일들과 변경 내역에 대한 정보들이 저장되어 있는 곳이다.
* **가져오기(Import)**
  - 버전 관리가 되고 있지 않은 아무것도 없는 저장소(Repository)에 처음으로 파일을 복사한다.
* **체크아웃(Check-Out)**
  - 프로그램을 수정하기 위해 저장소에서 파일을 받아온다.
  - 소스 파일과 함께 버전 관리를 위한 파일들도 받아온다.
* **체크인(Check-In)**
  - 체크아웃 한 파일의 수정을 완료한 후 저장소의 파일을 새로운 버전으로 갱신한다.
* **커밋(Commit)**
  - 체크인을 수행할 때 이전에 갱신된 내용이 있는 경우에는 충돌(Conflict)을 알리고 diff 도구를 이용해 수정한 후 갱신을 완료한다.
* **동기화(Update)**
  - 저장소에 있는 최신 버전으로 자신의 작업 공간을 동기화한다.

소프트웨어 버전 등록 과정
------
　소프트웨어 버전 등록은 다음과 같은 순서로 진행한다.
* **가져오기(Import)**: 개발자가 저장수에 신규로 파일을 추가한다.
* **인출(Check-Out)**: 수정 작업을 진행할 개발자가 저장소에 추가된 파일을 자신의 작업 공간으로 인출한다.
* **예치(Commit)**: 인출한 파일을 수정한 후 설명을 붙여 저장소에 예치한다.
* **동기화(Update)**: 커밋(Commit) 후 새로운 개발자가 자신의 작업 공간을 동기화(Update)한다. 이때 기존 개발자가 추가했던 파일이 전달된다.
* **차이(Diff)**: 새로운 개발자가 추가된 파일의 수정 기록(Change Log)을 확인하면서 이전 개발자가 처음 추가한 파일과 이후 변경된 파일의 차이를 확인한다.

소프트웨어 버전 관리 도구
======

공유 폴더 방식
------
　공유 폴더 방식은 버전 관리 자료가 로컬 컴퓨터의 공유 폴더에 저장되어 관리되는 방식으로, 다음과 같은 특징이 있다.
* 개발자들은 개발이 완료된 파일을 약속된 공유 폴더에 매일 복사한다.
* 담장자는 공유 폴더의 파일을 자기 PC로 복사한 후 컴파일 하여 이상 유무를 확인한다.
* 이상 유무 확인 과정에서 파일의 오류가 확인되면, 해당 파일을 등록한 개발자에게 수정을 의뢰한다.
* 파일에 이상이 없다면 다음날 각 개발자들이 동작 여부를 다시 확인한다.
* 파일을 잘못 복사하거나 다른 위치로 복사하는 것에 대비하기 위해 파일의 변경사항을 데이터베이스에 기록하여 관리한다.
* 종류에는 SCCS, RCS, PVCS, QVCS 등이 있다.

클라이언트/서버 방식
------
　클라이언트/서버 방식은 버전 관리 자료가 중앙 시스템(서버)에 저장되어 관리되는 방식으로, 다음과 같은 특징이 있다.
* 서버의 자료를 개발자 별로 자신의 PC(클라이언트)로 복사하여 작업한 후 변경된 내용을 서버에 반영한다.
* 모든 버전 관리는 서버에서 수행된다.
* 하나의 파일을 서로 다른 개발자가 작업할 경우 경고 메시지를 출력한다.
* 서버에 문제가 생기면, 서버가 복구되기 전까지 다른 개발자와의 협업 및 버전 관리 작업은 중단된다.
* 종류에는 CVS, SVN(Subversion), CVSNT, Clear Case, CMVC, Perforce 등이 있다.

분산 저장소 방식
------
　분산 저장소 방식은 버전 관리 자료가 하나의 원격 저장소와 분산된 개발자 PC의 로컬 저장소에 함께 저장되어 관리되는 방식으로, 다음과 같은 특징이 있다.
* 개발자별로 원격 저장소의 자료를 자신의 로컬 저장소로 복사하여 작업한 후 변경된 내용을 로컬 저장소에 우선 반영(버전 관리)한 다음 이를 원격 저장소에 반영한다.
* 로컬 저장소에서 버전 관리가 가능하므로 원격 저장소에 문제가 생겨도 로컬 저장소의 자료를 이용하여 작업할 수 있다.
* 종류에는 Git, GNU arch, DCVS, Bazaar, Mercurial, TeamWare, Bitkeeper, Plastic SCM 등이 있다.

Subversion(서브버전, SVN)
------
　Subversion은 CVS를 개선한 것으로, 아피치 소프트웨어 재단에서 2000년에 발표하였다.
* 클라이언트/서버 구조로, 서버(저장소, Repository)에는 최신 버전의 파일들과 변경 내역이 관리된다.
* 서버의 자료를 클라이언트로 복사해와 작업한 후 변경 내용을 서버에 반영(Commit)한다.
* 모든 개발 작업은 trunk 디렉터리에서 수행되며, 추가 작업은 branches 디렉터리 안에 별도의 디렉터리를 만들어 작업을 완료한 후 trunk 디렉터리와 병합(merge)한다.
* 커밋(Commit)할 때마다 리비전(Revision)이 1씩 증가한다.
* 클라이언트는 대부분의 운영체제에서 사용되지만, 서버는 주로 유닉스를 사용한다.
* 소스가 오픈되어 있어 무료로 사용할 수 있다.
* CVS의 단점이었던 파일이나 디렉터리의 이름 변경, 이동 등이 가능하다.
* 다음은 Subversion의 주요 명령어이다.
  - add
    + 새로운 파일이나 디렉터리를 버전 관리 대상으로 등록한다.
    + add로 등록되지 않은 대상은 commit이 적용되지 않는다.
  - commit
    + 버전 관리 대상으로 등록된 클라이언트의 소스 파일을 서버의 소스 파일에 적용한다.
  - update
    + 서버의 최신 commit 이력을 클라이언트의 소스 파일에 적용한다.
    + commit 전에는 매번 update를 수행하여 클라이언트에 적용되지 않은 서버의 변동 내역을 클라이언트에 적용한다.
  - checkout
    + 버전 관리 정보와 소스 파일을 서버에서 클라이언트로 받아온다.
  - lock/unlock
    + 서버의 소스 파일이나 디렉터리를 잠그거나 해제한다.
  - import
    + 아무것도 없는 서버의 저장소에 맨 처음 소스 파일을 저장하는 명령으로, 한 번 사용하면 다시 사용하지 않는다.
  - export
    + 버전 관리에 대한 정보를 제외한 순수한 소스 파일만을 서버에서 받아온다.
  - info
    + 지정한 파일에 대한 위치나 마지막 수정 일자 등에 대한 정보를 표시한다.
  - diff
    + 지정된 파일이나 경로에 대해 이전 리버전과의 차이를 표시한다.
  - merge
    + 다른 디렉터리에서 작업된 버전 관리 내역을 기본 개발 작업과 병합한다.

Git(깃)
------
　Git은 분산 버전 관리 시스템으로 2개의 저장소, 즉 지역(로컬) 저장소와 원격 저장소가 존재한다. 지역 저장소는 개발자들이 실제 개발을 진행하는 장소로, 버전 관리가 수행된다. 원격 저장소는 여러 사람들이 협업을 위해 버전을 공동 관리하는 곳으로, 자신의 버전 관리 내역을 반영하거나 다른 개발자의 변경 내용을 가져올 때 사용한다. 버전 관리가 지역 저장소에서 진행되므로 버전 관리가 신속하게 처리되고, 원격 저장소나 네트워크에 문제가 있어도 작업이 가능하다.<br/>
　브렌치를 이용하면 기본 버전 관리 틀에 영향을 주지 않으면서 다양한 형태의 기능 테스팅이 가능하다. 파일의 변화를 스냅샷(Snapshot)으로 저장하는데, 스냅샷은 이전 스냅샷의 포인터를 가지므로 버전의 흐름을 파악할 수 있다. 다음은 Git의 주요 명령어이다.
* add
  - 작업 내역을 지역 저장소에 저장하기 위해 스테이징 영역(Staging Area)에 추가한다.
  - '--all' 옵션으로 작업 디텍터리의 모든 파일을 스테이징 영역에 추가할 수 있다.
* commit
  - 작업 내역을 지역 저장소에 저장한다.
* branch
  - 새로운 브렌치를 생성한다.
  - 최초로 commit을 하면 마스터(master) 브렌치가 생성된다.
  - commit할 때마다 해당 브랜치는 가장 최근의 commit한 내용을 가리키게 된다.
  - '-d' 옵션으로 브렌치를 삭제할 수 있다.
* checkout
  - 지정한 브랜치로 이동한다.
  - 현재 작업 중인 브랜치는 HEAD 포인터가 가리키는데, checkout 명령을 통해 HEAD 포인터를 지정한 브랜치로 이동시킨다.
* merge
  - 지정한 브렌치의 변경 내역을 현재 HEAD 포인터가 가리키는 브랜치에 반영함으로써 두 브렌치를 병합한다.
* init
  - 지역 저장소를 생성한다.
* remote add
  - 원격 저장소에 연결한다.
* push
  - 로컬 저장소의 변경 내역을 원격 저장소에 반영한다.
* fetch
  - 원격 저장소의 변경 이력만을 지역 저장소로 가져와 반영한다.

빌드 자동화 도구
======

빌드 자동화 도구의 개요
------
　**빌드**란 소스 코드 파일들을 컴파일한 후 여러 개의 모듈을 묶어 실행 파일로 만드는 과정이며, 이러한 빌드를 포함하여 테스트 및 배포를 자동화하는 도구를 빌드 자동화 도구라고 한다. 애자일 환경에서는 하나의 작업이 마무리될 때마다 모듈 단위로 나눠서 개발된 코드들이 지속적으로 통합되는데, 이러한 지속적인 통합(Continuous Integration) 개발 환경에서 빌드 자동화 도구는 유용하게 활용된다. 빌드 자동화 도구에는 Ant, Make, Maven, Gradle, Jenkins 등이 있으며, 이중 Jenkins와 Gradle이 가장 대표적이다.

Jenkins
------
　**Jenkins**는 JAVA 기반의 오픈 소스 형태로, 가장 많이 사용되는 빌드 자동화 도구이다. 서블릿 컨테이너에서 샐행되며 서버 기반 도구이다. SVN, Git 등 대부분의 형상 관리 도구와 연동이 가능하다. 친숙한 Web GUI 제공으로 사용이 쉽다. 여러 대의 컴퓨터를 이용한 분산 빌드나 테스트가 가능하다.

Gradle
------
　**Gradle**은 Groovy를 기반으로 한 오픈 소스 형태의 자동화 도구로, 안드로이드 앱 개발 환경에서 사용된다. 안드로이드 뿐만 아니라 플러그인을 설치하면, JAVA, C++, Python 등의 언어도 빌드가 가능하다. Groovy를 사용해서 만든 DSL(Domain Specific Language)을 스크립트 언어로 사용한다. Gradle은 실행할 처리 명령어들을 모아 태스크(Task)로 만든 후 태스크 단위로 실행한다. 이전에 사용했던 태스크를 재사용하거나 다른 시스템의 태스크를 공유할 수 있는 빌드 캐시 기능을 지원하므로 빌드 속도를 향상시킬 수 있다.