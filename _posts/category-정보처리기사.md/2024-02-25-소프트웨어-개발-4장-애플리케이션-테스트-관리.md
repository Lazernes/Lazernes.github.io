---
title: "소프트웨어 개발 4장 애플리케이션 테스트 관리"
excerpt: "애플리케이션 테스트 관리"

wirter: Myeongwoo Yoon
categories:
  - 정보처리기사
tags:
  - 정보처리기사

toc: true
toc_sticky: true
use_math: true 

date: 2024-02-25
last_modified_at: 2024-02-25
---

애플리케이션 테스트
======

애플리케이션 테스트의 개요
------
　애플리케이션 테스트는 애플리케이션에 잠재되어 있는 결함을 찾아내는 일련의 행위 또는 절차이다. 애플리케이션 테스트는 개발된 소프트웨어가 고객의 요구사항을 만족시키는지 확인(Validation)하고 소프트웨어가 기능을 정확히 수행하는지 검증(Verification)한다. 애플리케이션 테스트를 실행하기 저에 개발한 소프트웨어의 유형을 분류하고 특성을 정리해서 중점적으로 테스트할 사항을 정리해야 한다.

애플리케이션 테스트의 필요성
------
* 애플리케이션 테스트를 통해 프로그램 실행 전에 오류를 발견하여 예방할 수 있다.
* 애플리케이션 테스트는 프로그램이 사용자의 요구사항이나 기대 수준 등을 만족시키는지 반복적으로 테스트하므로 제품의 신뢰도를 향상시킨다.
* 애플리케이션의 개발 초기부터 애플리케이션 테스트를 계획하고 시작하면 단순한 오류 발견뿐만 아니라 새로운 오류의 유입도 예방할 수 있다.
* 애플리케이션 테스트를 효과적으로 수행하면 최소한의 시간과 노력으로 많은 결함을 찾을 수 있다.

애플리케이션 테스트의 기본 원리
------
* 애플리케이션 테스트는 소프트웨어의 잠재적인 결함을 줄일 수 있지만 소프트웨어에 결함이 없다고 증명할 수는 없다. 즉 완벽한 소프트웨어 테스팅은 불가능하다.
* 애플리케이션의 결함은 대부분 개발자의 특성이나 애플리케이션의 기능적 특징 때문에 특정 모듈에 집중되어 있다. 애플리케이션의 20%에 해당하는 코드에서 전체 80%의 결함이 발견된다고 하여 파레토 법칙을 적용하기도 한다.
* 애플리케이션 테스트에서 동일한 테스트 케이스로 동일한 테스트를 반복하면 더 이상 결함이 발견되지 않는 '살충제 패러독스(Pesricide Paradox)' 현상이 발생한다. 살충제 패러독스를 방지하기 위해서 테스트 케이스를 지속적으로 보완 및 개선해야 한다.
* 애플리케이션 테스트는 소프트웨어 특징, 테스트 환경, 테스터 역량 등 정황(Context)에 따라 테스트 결과가 달라질 수 있으므로, 정황에 따라 테스트를 다르게 수행해야 한다.
* 소프트웨어의 결함을 모두 제거해도 사용자의 요구사항을 만족시키지 못하면 해당 소프트웨어는 품질이 높다고 말할 수 없다. 이것을 오류-부재의 궤변(Absence of Errors Fallacy)이라고 한다.
* 테스트와 위험은 반비례한다. 테스트를 많이 하면 할수록 미래에 발생할 위험을 줄일 수 있다.
* 테스트는 작은 부분에서 시작하여 점점 확대하며 진행해야 한다.
* 테스트는 개발자와 관계없는 별도의 팀에서 수행해야 한다.

애플리케이션 테스트의 분류
======

프로그램 실행 여부에 따른 테스트
------
　애플리케이션을 테스트 할 때 프로그램의 실행 여부에 따라 정적 테스트와 동적 테스트로 나뉜다.
* **정적 테스트**
  - 프로그램을 실행하지 않고 명세서나 소스 코드를 대상으로 분석하는 테스트이다.
  - 소프트웨어 개발 초기에 결함을 발견할 수 있어 소프트웨어의 개발 비용을 낮추는데 도움이 된다.
  - 워크스루, 인스펙션, 코드 검사 등이 있다.
* **동적 테스트**
  - 프로그램을 실행하여 오류를 찾는 테스트로, 소프트웨어 개발의 모든 단계에서 테스트를 수행할 수 있다.
  - 블랙박스 테스트, 화이트박스 테스트

테스트 기반(Test Bases)에 따른 테스트
------
　애플리케이션을 테스트 할 때 무엇을 기반으로 수행하느냐에 따라 명세 기반, 구조 기반, 경험 기반 테스트로 나뉜다.
* **명세 기반 테스트**
  - 사용자의 요구사항에 대한 명세를 빠짐없이 테스트 케이스로 만들어 구현하고 있는지 확인하는 테스트
  - 동등 분할, 경계 값 분석 등
* **구조 기반 테스트**
  - 소프트웨어 내부의 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 테스트
  - 구문 기반, 결정 기반, 조건 기반 등
* **경험 기반 테스트**
  - 유사 소프트웨어나 기술 등에 대한 테스터의 경험을 기반으로 수행하는 테스트
  - 경험 기반 테스트는 사용자의 요구사항에 대한 명세가 불충분하거나 테스트 시간에 제약이 있는 경우 수행하면 효과적이다.
  - 에러 추정, 체크 리스트, 탐색적 테스팅

시각에 따른 테스트
------
　애플리케이션을 테스트 할 때 누구를 기준으로 하느냐에 따라 검증(Verification) 테스트와 확인(Validation) 테스트로 나뉜다.
* **검증(Verification) 테스트**: 개발자의 시각에서 제품의 생산 과정을 테스트하는 것으로, 제품이 명세서대로 완성됐는지를 테스트한다.
* **확인(Validation) 테스트**: 사용자의 시각에서 생성된 제품의 결과를 테스트하는 것으로, 사용자가 요구한대로 제품이 완성됐는지, 제품이 정상적으로 동작하는지를 테스트한다.

목적에 따른 테스트
------
　애플리케이션을 테스트 할 때 무엇을 목적으로 테스트를 진행하느냐에 따라 다음과 같이 나뉜다.
* **회복(Recovery) 테스트**: 시스템에 여러 가지 결함을 주어 실패하도록 한 후 올바르게 복구되는지를 확인하는 테스트
* **안전(Security) 테스트**: 시스템에 설치된 시스템 보호 도구가 불법적인 침입으로부터 시스템을 보호할 수 있는지를 확인하는 테스트
* **강도(Stress) 테스트**: 시스템에 과도한 정보량이나 빈도 등을 부과하여 과부하 시에도 소프트웨어가 정상적으로 실행되는지를 확인하는 테스트
* **성능(Performance) 테스트**: 소프트웨어의 실시간 성능이나 전체적인 효율성을 진단하는 테스트로, 소프트웨어의 응답 시간, 처리량 등을 테스트한다.
* **구조(Structure) 테스트**: 소프트웨어 내부의 논리적인 경로, 소스 코드의 복잡도 등을 평가하는 테스트
* **회귀(Regression) 테스트**: 소프트웨어의 변경 또는 수정된 코드에 새로운 결함이 없음을 확인하는 테스트
* **병행(Parallel) 테스트**: 변경된 소프트웨어와 기존 소프트웨어에 동일한 데이터를 입력하여 결과를 비교하는 테스트

테스트 기법에 따른 애플리케이션 테스트
======

화이트박스 테스트(White BoX Test)
------
　**화이트박스 테스트**는 모듈의 원시 코드를 오픈시킨 상태에서 원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법이다. 화이트박스 테스트는 설계된 절차에 초점을 둔 구조적 테스트로 프로시저 설계의 제어 구조를 사용하여 테스트 케이스를 설계하여, 테스트 과정의 초기에 적용된다. 모듈 안의 작동을 직접 관찰하고 원시 코드(모듈)의 모든 문장을 한 번 이상 실행함으로써 수행된다. 프로그램의 제어 구조에 따라 선택, 반복 등의 분기점 부분들을 수행함으로써 논리적 경로를 제어한다.

화이트박스 테스트의 종류
------
* **기초 경로 검사(Basic Path Testing)**
  - 대표적인 화이트박스 테스트 기법이다.
  - 테스트 케이스 설계자가 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법으로, 테스트 측정 결과는 실행 경로의 기초를 정의하는 데 지침으로 사용된다.
* **제어 구조 검사(Control Structure Testing)**
  - **조건 검사(Condition Testing)**: 프로그램 모듈 내에 있는 논리적 조건을 테스트하는 테스트 케이스 설계 기법
  - **루프 검사(Loop Testing)**: 프로그램의 반복(Loop) 구조에 초점을 맞춰 실시하는 테스트 케이스 설계 기법
  - **데이터 흐름 검사(Data Flow Testing)**: 프로그램에서 변수의 정의와 변수 사용의 위치에 초점을 맞춰 실시하는 테스트 케이스 설계 기법

화이트박스 테스트의 검증 기준
------
　화이트박스 테스트의 검증 기준은 테스트 케이스들이 테스트에 얼마나 적정한지를 판단하는 기준으로 다음과 같다.
* **문장 검증 기준(Statement Coverage)**
  - 소스 코드의 모든 구문이 한 번 이상 수행되도록 테스트 케이스 설계
* **분기 검증 기준(Branch Coverage)**
  - 결정 검증 기준(Decision Coverage)이라고도 불리며, 소스 코드의 모든 조건문에 대해 조건이 True인 경우와 False인 경우가 한 번 이상 수행되도록 테스트 케이스 설계
* **조건 검증 기준(Condition Coverage)**
  - 소스 코드의 조건문에 포함된 개별 조건식의 결과가 True인 경우와 False인 경우가 한 번 이상 수행되도록 테스트 케이스 설계
* **분기/조건 기준(Branch/Condition Coverage)**
  - 분기 검증 기준과 조건 검증 기준을 모두 만족하는 설계로, 조건문이 True인 경우와 False인 경우에 따라 조건 검증 기준의 입력 데이터를 구분하는 테스트 케이스 설계

블랙박스 테스트(Black Box Test)
------
　**블랙박스 테스트**는 소프트웨어가 수행할 특정 기능을 알기 위해서 각 기능이 완전히 작동되는 것을 입증하는 테스트로, 기능 테스트라고도 한다. 프로그램의 구조를 고려하지 않기 때문에 테스트 케이스는 프로그램 또는 모듈의 요구나 명세를 기초로 결정한다. 소프트웨어 인터페이스에서 실시되는 테스트이다.<br/>
　부정확하거나 누락된 기능, 인터페이스 오류, 자료 구조나 외부 데이텁이스 접근에 따른 오류, 행위나 성능 오류, 초기화와 종료 오류 등을 발견하기 위해 사용되며, 테스트 과정의 후반부에 적용된다.

블랙박스 테스트의 종류
------
* **동치 분할 검사(Equivalence Partitioning Testing, 동치 클래스 분해)**
  - 입력 자료에 초점을 맞춰 테스트 케이스(동치 클래스)를 만들고 검증하는 방법으로 동등 분할 기법이라고도 한다.
  - 프로그램의 입력 조건에 타당한 입력 자료와 타당하지 않은 입력 자료의 개수를 균등하게 하여 테스트 케이스를 정하고, 해당 입력 자료에 맞는 결과가 출력되는지 확인하는 기법이다.
* **경계값 분석(Boundary Value Analysis)**
  - 입력 자료에만 치중한 동치 분할 기법을 보완하기 위한 기법이다.
  - 입력 조건의 중간값보다 경계값에서 오류가 발생할 확률이 높다는 점을 이용하여 입력 조건의 경계값을 테스트 케이스로 선정하여 검사하는 기법이다.
* **원인-효과 그래프 검사(Cause-Effect Graphing Testing)**
  - 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스를 선정하여 검사하는 기법이다.
* **오류 예측 검사(Error Guessing)**
  - 과거의 경험이나 확인자의 감각으로 테스트하는 기법이다.
  - 다른 블랙박스 테스트 기법으로는 찾아낼 수 없는 오류를 찾아내는 일련의 보충적 검사 기법이며, 데이터 확인 검사라고도 한다.
* **비교 검사(Comparison Testing)**
  - 여러 버전의 프로그램이 동일한 테스트 자료를 제공하여 동일한 결과가 출력되는지 테스트하는 기법이다.

개발 단계에 따른 애플리케이션 테스트
======

통합 테스트
======

테스트 케이스/ 테스트 시나리오/ 테스트 오라클
======

테스트 자동화 도구
======

결함 관리
======

복잡도
======

복잡도의 개요
------
　**복잡도(Complexity)**는 시스템이나 시스템 구성 요소 또는 소프트웨어의 복잡한 정도를 나타내는 말로, 시스템 또는 소프트웨어를 어느 정도의 수준까지 테스트해야 하는지 또는 개발하는데 어느 정도의 자원이 소요되는지 예측하는데 사용된다. 시스템의 복잡도가 높으면 장애가 발생할 수 있으므로 정밀한 테스트를 통해 미리 오류를 제거할 필요가 있다. 주요 복잡도 측정에는 LOC(Line Of Code), 순환 복잡도(Cyclomatic Complexity) 등이 있다.

시간 복잡도
------
　시간 복잡도는 알고리즘의 시행시간, 즉 알고리즘을 수행하기 위해 프로세스가 수행하는 연산 횟수를 수치화한 것으로 시간 복잡도가 낮을수록 알고리즘의 실행시간이 짧고, 높을수록 실행시간이 길어진다. 시간 복잡도는 알고리즘의 실행시간이 하드웨어적 성능이나 프로그래밍 언어의 종류에 따라 달라지기 때문에 시간이 아닌 명령어의 실행 횟수를 표기하는데, 이러한 표기법을 점근 표기법이라고 한다. 점근 표기법의 종류는 다음과 같다.
* **빅오 표기법(Big-O Notation)**
  - 알고리즘의 실행시간이 최악일 때를 표기하는 방법이다.
  - 입력값에 대해 알고리즘을 수행했을 때 명령어의 실행 횟수는 어떠한 경우에도 표기 수치보다 많을 수 없다.
* **세타 표기법(Big-$\Theta$ Notation)**
  - 알고리즘의 실행시간이 평균일 때를 표기하는 방법이다.
  - 입력값에 대해 알고리즘을 수행했을 때 명령어의 실행 횟수는 평균적인 수치를 표기한다.
* **오메가 표기법(Big-$\Omega$ Notation)**
  - 알고리즘의 실행시간이 최상일 때를 표기하는 방법이다.
  - 입력값에 대해 알고리즘을 수행했을 때 명령어의 실행 횟수는 어떠한 경우에도 표기 수치보다 적을 수 없다.

빅오 표기법(Big-O Notation)
------
　빅오 표기법은 알고리즘의 실행시간이 최악일 때를 표기하는 방법으로, 신뢰성이 떨어지는 오메가 표기법이나 평가하기 어려운 세타 표기법에 비해 성능을 예측하기 용이하여 주로 사용된다. 일반적인 알고리즘에 대한 최악의 시간 복잡도를 빅오 표기법으로 표현하면 다음과 같다.
* **O(1)**
  - 입력값(n)에 관계없이 일정하게 문제 해결에 하나의 단계만을 거친다.
  - 스택의 삽입, 삭제
* **O(logn)**
  - 문제 해결에 필요한 단계가 입력값(n) 또는 조건에 의해 감소한다.
  - 이진 트리, 이진 검색
* **O(n)**
  - 문제 해결에 필요한 단계가 입력값(n)과 1:1의 관계를 거친다.
  - for문
* **O(nlogn)**
  - 문제 해결에 필요한 단계가 nlogn번만큼 수행된다.
  - 힙 정렬, 2-Way 합병 정렬
* **O($n^2$)**
  - 문제 해결에 필요한 단계가 입력값(n)의 제곱만큼 수행된다.
  - 삽입 정렬, 쉘 정렬, 선택 정렬, 버블 정렬, 퀵 정렬
* **O($2^n$)**
  - 문제 해결에 필요한 단계가 2의 입력값(n) 제곱만큼 수행된다.
  - 피보나치 수열

순환 복잡도
------
　순환 복잡도(Cyclomatic Complexity)는 한 프로그램의 논리적인 복잡도를 측정하기 위한 소프트웨어의 척도로, 맥케이브 순환도(McCabe's Cyclomatic) 또는 맥케이브 복잡도 매트릭(McCabe's Complexity Metrics)라고도 하며, 제어 흐름도 이론에 기초를 둔다.<br/>
　순환 복잡도를 이용하여 계산된 값은 프로그램의 독립적인 경로의 수를 정의하고, 모든 경로가 한 번 이상 수행되었음을 보장하기 위해 행해지는 테스트 횟수의 상한선을 제공한다. 제어 흐름도 G에서 순환 복잡도 V(G)는 다음과 같은 방법으로 계산할 수 있다.
* 방법1: 순환 복잡도는 제어 흐름도의 영역 수와 일치하므로 영역 수를 계산한다.
* 방법2: V(G) = E - N + 2: E는 화살표 수, N은 노드의 수

애플리케이션 성능 개선
======