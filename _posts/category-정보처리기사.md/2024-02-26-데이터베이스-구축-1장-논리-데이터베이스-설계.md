---
title: "데이터베이스 구축 1장 논리 데이터베이스 설계"
excerpt: "논리 데이터베이스 설계"

wirter: Myeongwoo Yoon
categories:
  - 정보처리기사
tags:
  - 정보처리기사

toc: true
toc_sticky: true
use_math: true
 
date: 2024-02-26
last_modified_at: 2024-02-26
---

데이터베이스 설계
======

데이터베이스 설계의 개념
------
　데이터베이스 설계란 사용자의 요구를 분석하여 그것들을 컴퓨터에 저장할 수 있는 데이터베이스의 구조에 맞게 변형한 후 특정 DBMS로 데이터베이스를 구현하여 일반 사용자들이 사용하게 하는 것이다.

데이터베이스 설계 시 고려사항
------

* **무결성**: 삽입, 삭제, 갱신 등의 연산 후에도 데이터베이스에 저장된 데이터가 정해진 제약 조건을 항상 만족해야 한다.
* **일관성**: 데이터베이스에 저장된 데이터들 사이나, 특정 질의에 대한 응답이 처음부터 끝까지 변함없이 일정해야 한다.
* **회복**: 시스템에 장애가 발생했을 때 장애 발생 직전의 상태로 복구할 수 있어야 한다.
* **보안**: 불법적인 데이터의 노출 또는 병경이나 손실로부터 보호할 수 있어야 한다.
* **효율성**: 응답시간의 단축, 시스템의 생산성, 저장 공간의 최적화 등이 가능해야 한다.
* **데이터베이스 확장**: 데이터베이스 운영에 영향을 주지 않으면서 지속적으로 데이터를 추가할 수 있어야 한다.

데이터베이스 설계 순서
------
* 요구 조건 분석: 요구 조건 명세서 작성
* 개념적 설계: 개념 스키마, 트랜잭션 모델링, E-R 모델
* 논리적 설계: 목표 DBMS에 맞는 논리 스키마 설계, 트랜잭션 인터페이스 설계
* 물리적 설계: 목표 DBMS에 맞는 물리적 구조의 데이터로 변환
* 구현: 목표 DBMS의 DDL(데이터 정의어)로 데이터베이스 생성, 트랜잭션 작성

요구 조건 분석
------
　요구 조건 분석은 데이터베이스를 사용할 사람들로부터 필요한 용도를 파악하는 것이다. 데이터베이스 사용자에 따른 수행 업무와 필요한 데이터의 종류, 용도, 처리 형태, 흐름, 제약 조건 등을 수집한다. 수집된 정보를 바탕으로 요구 조건 명세를 작성한다.

개념적 설계(정보 모델링, 개념화)
------
　개념적 설계란 정보의 구조를 얻기 위하여 현실 세계의 무한성과 게속성을 이해하고, 다른 사란과 통신하기 위하여 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정이다. 개념적 설계 단계에서는 개념 스키마 모델링과 트랜잭션 모델링을 병행 수행한다. 개념적 설계 단계에서는 요구 분석 단계에서 나온 결과인 요구 조건 명세를 DBMS에 독립적인 E-R 다이어그램을 작성한다. DBMS에 독립적인 스키마를 작성한다.

논리적 설계(데이터 모델링)
------
　논리적 설계 단계란 현실 세계에서 발생하는 자료를 컴퓨터가 이해하고 처리할 수 있는 물리적 저장장치에 저장할 수 있도록 변환하기 위해 특정 DBMS가 지원하는 논리적 자료 구조로 변환(mapping)시키는 과정이다. 개념 세계의 데이터를 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계로 표현되는 논리적 구조의 데이터로 모델화 한다. 개념적 설계가 개념 스키마를 설계하는 단계라면 논리적 설계에서는 개념 스키마를 평가 및 정재하고 DBMS에 따라 서로 다른 논리적 스키마를 설계하는 단계이다. 트랜잭션의 인터페이스를 설계한다. 관계형 데이터베이스라면 테이블을 설계하는 단계이다.

물리적 설계(데이터 구조화)
------
　물리적 설계란 논리적 설계 단계에서 논리적 구조로 표현된 데이터를 디스크 등의 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정이다. 물리적 설계 단계에서는 다양한 데이터베이스 응용에 대해 처리 성능을 얻기 위해 데이터베이스 파일의 저장 구조 및 액세스 경로를 결정한다. 저장 레코드의 양식, 순서, 접근 경로, 조회가 집중되는 레코드와 같은 정보를 사용하여 데이터가 컴퓨터에 저장되는 방법을 묘사한다. 트랜잭션 처리량, 응답 시간, 디스크 용량, 저장 공간의 효율화 등을 고려한다.

데이터베이스 구현
------
　데이터베이스 구현 단계란 논리적 설계 단계와 물리적 설계 단계에서 도출된 데이터베이스 스키마를 파일로 생성하는 것이다. 사용하려는 특정 DBMS의 DDL(데이터 정의어)을 이용하여 데이터베이스 스키마를 기술한 후 컴파일하여 빈 데이터베이스 파일을 생성한다. 생성된 빈 데이터베이스 파일에 데이터를 입력한다. 응용 프로그램을 위한 트랜잭션을 작성한다. 데이터베이스 접근을 위한 응용 프로그램을 작성한다.

데이터 모델의 개념
======

데이터 모델의 정의
------
　데이터 모델은 현실 세계의 정보들을 컴퓨터에 표현하기 위해 단순화, 추상화하여 체계적으로 표현한 개념적 모형이다. 데이터 모델은 데이터, 데이터의 관계, 데이터의 의미 및 일관성, 제약 조건 등을 기술하기 위한 개념적 도구들의 모임이다. 현실 세계를 데이터베이스에 표현하는 중간 과정, 즉 데이터베이스 설계 과정에서 데이터의 구조(Schema)를 논리적으로 표현하기 위해 사용되는 지능적 도구이다.
* **데이터 모델의 구성 요소**: 개체, 속성, 관계
* **데이터 모델 종류**: 개념적 데이터 모델, 논리적 데이터 모델, 물리적 데이터 모델
* **데이터 모델에 표시할 요소**: 구조, 연산, 제약 조건

데이터 모델의 구성 요소
-----
* **개체(Entity)**: 데이터베이스에 표현하려는 것으로, 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체이다.
* **속성(Attribute)**: 데이터의 가장 작은 논리적 단위로서 파일 구조상의 데이터 항목 또는 데이터 필드에 해당한다.
* **관계(Relationship)**: 개체 간의 관계 또는 속성 간의 논리적인 연결을 의미한다.

개념적 데이터 모델
------
　개념적 데이터 모델은 현실 세계에 대한 인간의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정이다. 개념적 데이터 모델은 속성들로 기술된 개체 타입과 이 개체 타입들 간의 관계를 이용하여 현실 세계를 표현한다. 개념적 데이터 모델은 현실 세계에 존재하는 개체를 인간이 이해할 수 있는 정보 구조로 표현하기 때문에 정보 모델이라고도 한다. 대표적인 개념적 데이터 모델로는 E-R 모델이 있다.

논리적 데이터 모델
------
　논리적 데이터 모델은 개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터가 이해하고 처리할 수 있는 컴퓨터 세계의 환경에 맞도록 변환하는 과정이다. 논리적 데이터 모델은 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계를 이용하여 현실 세계를 표현한다. 단순히 데이터 모델이라고 하면 논리적 데이터 모델을 의미한다. 특정 DBMS는 특정 논리적 데이터 모델 하나만 선정하여 사용한다. 논리적 데이터 모델은 데이터 간의 관계를 어떻게 표현하느냐에 따라 관계 모델, 계층 모델, 네트워크 모델로 구분한다.

데이터 모델에 표시할 요소
------
* **구조(Structure)**: 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질을 표현한다.
* **연산(Operation)**: 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 데이터베이스를 조작하는 기본 도구이다.
* **제약 조건(Constraint)**: 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건이다.

E-R(개체-관계) 모델
======

E-R(Entity-Relationship, 개체-관계) 모델의 개요
------
　**E-R 모델**은 개념적 데이터 모델의 가장 대표적인 것으로 개체와 개체 간의 관계를 기본 요소로 이용하여 현실 세계의 무질서한 데이터를 개념적인 논리 데이터로 표현하기 위한 방법으로 많이 사용되고 있다. E-R 모델은 개체 타입(Entity Type)와 이들 간의 관계 타입(Relationship Type)을 이용해 현실 세계를 개념적으로 표현하고 데이터를 개체(Entity), 관계(Relationship), 속성(Attribute)으로 묘사한다. E-R 모델은 특정 DBMS를 고려한 것은 아니고 다이어그램으로 표현하며, 1:1, 1:N, N:M 등의 관계 유형을 제한 없이 나타낼 수 있다.

E-R 다이어그램(Entity-Relationship Diagram)
------
　**E-R 다이어그램**은 E-R 모델의 기본 아이디어를 시각적으로 표현하기 위한 그림으로, 실체 간의 관계는 물론 조직, 사용자, 프로그램, 데이터 등 시스템 내에서 역할을 가진 모든 실체들을 표현한다.
<p align="center"><img src="/assets/img/정보처리기사/데이터베이스 구축/논리 데이터베이스 설계/3-1.jpeg" width="500"></p>

관계형 데이터베이스의 구조
======

관계형 데이터베이스의 개요
------
　관계형 데이터베이스를 구성하는 개체(Entity)나 관계(Relationship)를 모두 릴레이션(Relation)이라는 표(Table)로 표현한다. 릴레이션은 개체를 표현하는 개체 릴레이션, 관계를 나타내는 관계 릴레이션으로 구분할 수 있다. 장점으로는 간결하고 보기 편리하며, 다른 데이터베이스로의 변환이 용이하지만, 단점으로는 성능이 다소 떨어진다.

관계형 데이터베이스의 Relation 구조
------
　릴레이션은 데이터들을 표(Table)의 형태로 표현한 것으로 구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레이션 인스턴스로 구성된다.
<p align="center"><img src="/assets/img/정보처리기사/데이터베이스 구축/논리 데이터베이스 설계/4-1.jpeg" width="600"></p>

* **튜플(Tuple)**
  - 튜플은 릴레이션을 구성하는 각각의 행을 말한다.
  - 튜플은 속성의 모임으로 구성된다.
  - 파일 구조에서 레코드와 같은 의미이고 튜플의 수를 카디널리티(Cardinality) 또는 기수, 대응수라고 한다.
* **속성(Attribute)**
  - 속성은 데이터베이스를 구성하는 가장 작은 논리적 단위이다.
  - 파일 구조상의 데이터 항목 또는 데이터 필드에 해당한다.
  - 속성은 개체의 특성을 기술하고 속성의 수를 디그리(Degree) 또는 차수라고 한다.
* **도메인(Domain)**
  - 도메인은 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자(Atomic)값들의 집합이다.
  - 도메인은 실제 애트리뷰트 값이 나타날 때 그 값의 합법 여부를 시스템이 검사하는데에도 이용된다.

릴레이션의 특징
------
* 한 릴레이션에는 똑같은 튜플이 포함될 수 없으므로 릴레이션에 포함된 튜플들은 모두 상이하다.
* 한 릴레이션에 포함된 튜플 사이에는 순서가 없다.
* 튜플들의 삽입, 삭제 등의 작업으로 릴레이션은 시간에 따라 변한다.
* 릴레이션 스키마를 구성하는 속성들 간의 순서는 중요하지 않다.
* 속성의 유일한 식별을 위해 명칭은 유일해야 하지만, 속성을 구성하는 값은 동일한 값이 있을 수 있다.
* 릴레이션을 구성하는 튜플을 유일하게 식별하기 위해 속성들의 부분집합을 키(Key)로 성절한다.
* 속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자값만을 저장한다.

관계형 데이터베이스의 제약 조건 - 키(Key)
======
　제약 조건이란 데이터베이스에 저장되는 데이터의 정확성을 보장하기 위하여 키(Key)를 이용하여 입력되는 데이터에 제한을 주는 것으로 개체 무결성 제약, 참조 무결성 제약 등이 해당된다.

키(Key)의 개념 및 종류
------
　키는 데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 튜플들을 서로 구분할 수 있는 기준이 되는 애트리뷰트를 말한다. 키의 종류에는 후보키, 기본티, 대체키, 외래키 등이 있다.

후보키(Candidate Key)
------
　**후보키**는 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합, 즉 기본키로 사용될 수 있는 속성들을 말한다. 하나의 릴레이션내에서는 중복된 튜플들이 있을 수 없으므로 모든 릴레이션에는 반드시 하나 이상의 후보키가 존재한다. 후보키는 릴레이션에 있는 모든 튜플에 대해서 유일성과 최소 식별성을 만족시켜야 한다.
* **유일성(Unique)**: 하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 한다.
* **최소성(Minimality)**: 모든 레코드들을 유일하게 식별하는 데 꼭 필요한 속성으로만 구성되어야 한다.

기본키(Primary Key)
------
　**기본키**는 후보키 중에서 특별히 선정된 주키(Main Key)로 중복된 값을 가질 수 없다. 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성이다. 기본키는 후보키의 성질을 갖는다. 즉, 유일성과 최소헝을 가지며 튜플을 식별하기 위해 반드시 필요한 키이다. 기본키는 NULL 값을 가질 수 없다. 즉, 튜플에서 기본키로 설정된 속성에는 NULL 값이 있어서는 안된다.

대체키(Alternate Key)
------
　**대체키**는 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키를 의미하고 보조키라고도 한다.

슈퍼키(Super Key)
------
　**슈퍼키**는 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로서 릴레이션을 구성하는 모든 튜플들 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않는다. 슈퍼키는 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족시키지만, 최소성은 만족시키지 못한다.

외래키(Foreign Key)
------
　**외래키**는 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합을 의미한다. 외래키는 참조되는 릴레이션의 기본키와 대응되어 릴레이션 간에 참조 관계를 표현하는데 중요한 도구이다. 한 릴레이션에 속한 속성 A와 참조 릴레이션의 기본키인 B가 동일한 도메인 상에서 정의되었을 때의 속성 A를 외래키라고 한다. 외랰로 지정되면 참조 릴레이션의 기본키에 없는 값은 입력할 수 없다.

관계형 데이터베이스의 제약 조건 - 무결성
======


관계대수 및 관계해석
======

정규화(Nomalization)
======

정규화의 개요
------
　**정규화**란 함수적 종속성 등의 종속성 이론을 이용하여 잘못 설계된 관계형 스키마를 더 작은 속성의 세트로 쪼개어 바람직한 스키마로 만들어 가는 과정이다. 하나의 종속성이 하나의 릴레이션에 포현될 수 있도록 분해하는 과정이라고 할 수 있다.<br/>
　정규형에는 제1정규형, 제2정규형, 제3정규형, BCNF형, 제4정규형, 제5정규형이 있으며, 차수가 높아질수록 만족시켜야 할 제약 조건이 늘어난다. 정규화는 데이터베이스의 논리적인 설계 단계에서 수행되고 논리적 처리 및 품질에 큰 영향을 미친다. 정규화된 데이터 모델은 일관성, 정확성, 단순성, 비중복성, 안정성 등을 보장한다. 정규화 수준이 높을수록 유연한 데이터 구축이 가능하고 데이터의 정확성이 높아지는 반면 물리적 접근이 복잡하고 너무 많은 조인으로 인해 조회 성능이 저하된다.

정규화의 목적
------
* 데이터 구조의 안정성 및 무결성을 유지한다.
* 어떠한 릴레이션이라고 데이터베이스 내에서 표현 가능하게 만든다.
* 효과적인 검색 알고리즘을 생성할 수 있다.
* 데이터 중복을 배제하여 이상(Anomaly)의 발생 방지 및 자료 저장 공간의 최소화가 가능하다.
* 데이터 삽입 시 릴레이션을 재구성할 필요성을 줄인다.
* 데이터 모형의 단순화가 가능하다.
* 속성의 배열 상태 검증이 가능하다.
* 개체와 속성의 누락 여부 확인이 가능하다.
* 자료 검색과 추출의 효율성을 추구한다.

이상(Anomaly)의 개념 및 종류
------
　정규화를 거치지 않으면 데이터베이스 내에 데이터들이 불필요하게 중복되어 릴레이션 조작 시 예기치 못한 곤란한 형상이 발생하는데, 이를 이상(Anomaly)이라 하며 삽입 이상, 삭제 이상, 갱신 이상이 있다.

* 삽입 이상(Insert Anomaly): 릴레이션에 데이터를 삽입할 때 의도와는 상관없이 원하지 않은 값들도 함께 삽입되는 현상이다.
* 삭제 이상(Delete Anomaly): 릴레이션에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 연쇄가 일어나는 현상이다.
* 갱신 이상(Update Anomaly): 릴레이션에서 튜플에 있는 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상이다.

정규화의 원칙
------
* 정보의 무손실 표현, 즉 하나의 스키마를 다른 스키마로 변환할 때 정보으 손실이 있어서는 안된다.
* 분리의 원칙, 즉 하나의 독립된 관계성은 하나의 독립된 릴레이션으로 분리시켜 표현해야 한다.
* 데이터의 중복성이 감소되어야 한다.

정규화 과정
------
* **1NF(제1정규형)**
  - 1NF는 릴레이션에 속한 모든 도메인(Domain)이 원자값(Atomic Value)만으로 되어 있는 정규형이다. 즉, 릴레이션의 모든 속성 값이 원자 값으로만 되어 있는 정규형이다. 릴레이션의 모든 속성이 단순 영역에서 정의된다.
* **2NF(제2정규형)**
  - 2NF는 릴레이션 R이 1NF이고, 기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족하는 정규형이다.
* **3NF(제3정규형)**
  - 3NF는 릴레이션 R이 2NF이고, 기본키가 아닌 모든 속성이 기본키에 대해 이행적 종속을 만족하지 않는 정규형이다. 무손실 조인 또는 종속성 보존을 저해하지 않고도 항상 3NF 설계를 얻을 수 있다.
* **BCNF(Boyce-Code 정규형)**
  - BCNF는 릴레이션 R에서 결정자가 모두 후보키(Candidate Key)인 정규형이다. 3NF에서 후보키가 여러 개 존재하고 서로 중첩되는 경우에 적용하는, 강한 제3정규형이라고도 한다. 모든 BCNF가 종속성을 보존하는 것은 아니다.
  - BCNF의 제약 조건: 키가 아닌 모든 속성은 각 키에 대하여 완전 종속해야 한다. 키가 아닌 모든 속성은 그 자신이 부분적으로 들어가 있지 않은 모든 키에 대하여 완전 종속해야 한다. 어떤 속성도 키가 아닌 속성에 대해서는 완전 종속할 수 없다.
* **4NF(제4정규형)**
  - 4NF는 릴레이션 R에 다치 종속 A$\twoheadrightarrow$B가 성립하는 경우 R의 모든 속성이 A에 함수적 종속 관계를 만족하는 정규형이다.
* **5NF(제5정규형)**
  - 5NF는 릴레이션 R의 모든 조인 종속이 R의 후보키를 통해서만 성립되는 정규형이다.

<p align="center"><img src="/assets/img/정보처리기사/데이터베이스 구축/논리 데이터베이스 설계/8-1.jpeg" width="400"></p>

반정규화(Denormalization)
======

시스템 카탈로그
======