---
title: "3장 스프링 핵심 원리 이해2 - 객체 지향 원리 적용"
excerpt: "스프링 핵심 원리 이해2 - 객체 지향 원리 적용"

wirter: Myeongwoo Yoon
categories:
  - 김영한의 스프링 핵심 원리
tags:
  - Java
  - Spring

toc: true
toc_sticky: true
 
date: 2024-04-12
last_modified_at: 2024-04-12
---

새로운 할인 정책 개발
======
&ensp;새로운 할인 정책을 확장해본다.
* 서비스 오픈 직전에 할인 정책을 지금처럼 고정 금액 할인이 아니라 좀 더 합리적인 주문 금액당 할인하는 정률 할인으로 변경하고 싶다.

&ensp;DiscountPolicy에 FixedDiscountPolicy 대신 RateDiscountPolicy를 추가해주면 된다.<br/>
<p align="center"><img src="/assets/img/김영한의 스프링 핵심 원리/3장 스프링 핵심 원리 이해2/1-1.png" width="300"></p>

```java
package hello.core.discout;

import hello.core.member.Grade;
import hello.core.member.Member;

public class RateDiscountPolicy implements DiscountPolicy {

    private int discountPercent = 10; // 10% 할인

    @Override
    public int discount(Member member, int price) {
        if (member.getGrade() == Grade.VIP) {
            return price * discountPercent / 100;
            // 이 식이 실제로 10% 할인이 되는지 Test 하기 위해 Ctrl + Shift + T 단축키로 Test 생성
        } else {
            return 0;
        }
    }
}
```

&ensp;위 코드를 Test하기 위해 JUnit 테스트를 진핸한다.
```java
package hello.core.discout;

import hello.core.member.Grade;
import hello.core.member.Member;
import org.assertj.core.api.Assertions;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.*;
import static org.junit.jupiter.api.Assertions.*;

class RateDiscountPolicyTest {

    RateDiscountPolicy discountPolicy = new RateDiscountPolicy();

    @Test
    @DisplayName("VIP는 10% 할인이 저용되어야 한다.")
    void vip_o() {
        //given
        Member member = new Member(1L, "memberVIP", Grade.VIP);

        //when
        int discount = discountPolicy.discount(member, 10000);

        //then
        assertThat(discount).isEqualTo(1000);
        // Assertions.assertThat(discount).isEqualTo(1000);를 Alt + Enter 를 눌러서 on-demand로 만들 수 있음 >> 간결해짐
    }

    @Test
    @DisplayName("VIP가 아니면 할인이 적용되지 않아야 한다.")
    void vip_x() {
        //given
        Member member = new Member(2L, "memberBASIC", Grade.BASIC);

        //when
        int discount = discountPolicy.discount(member, 10000);

        //then
        assertThat(discount).isEqualTo(0);
    }
}
```

새로운 할인 정책 적용과 문제점
======
&ensp;할인 정책을 변경하려면 클라이언트인 OrderServiceImpl 코드를 고쳐야 한다.
```java
package hello.core.order;

import hello.core.discout.DiscountPolicy;
import hello.core.discout.FIxDiscountPolicy;
import hello.core.discout.RateDiscountPolicy;
import hello.core.member.Member;
import hello.core.member.MemberRepository;
import hello.core.member.MemoryMemberRepository;

public class OrderServiceImpl implements OrderService {

    private final MemberRepository memberRepository = new MemoryMemberRepository();
    //    private final DiscountPolicy discountPolicy = new FIxDiscountPolicy();
    private final DiscountPolicy discountPolicy = new RateDiscountPolicy();
    
    @Override
    public Order createOrder(Long memberId, String itemName, int itemPrice) {
        Member member = memberRepository.findById(memberId);
        int discountPrice = discountPolicy.discount(member, itemPrice);

        return new Order(memberId, itemName, itemPrice, discountPrice);
    }
}
```

&ensp;위에서는 다음과 같이 문제점이 발견된다.
* OCP, DIP 같은 객체지향 설계 원칙을 충실히 준수했다.
  - 준수하지 않음.
* DIP: 주문서비스 클라이언트(OrderServiceImpl)는 DiscountPolicy 인터페이스에 의존하면서 DIP를 지킨것 같음.
  - 클래스 의존관계를 분석해보면 추상(인터페이스) 뿐만 아니라 구체(구현) 클래스에도 의존하고 있다.
  - 추상 의존: DiscountPolicy
  - 구체 클래스: FixDiscountPolicy, RateDiscountPolicy
* OCP: 변경하지 않고 확장할 수 있다
  - 지금 코드는 기능을 확장해서 변경하면, 클라이언트 코드에 영향을 주므로 OCP를 위반한다.

&ensp;클래스 다이어그램으로 의존관계를 분석해보면, 기대했던 의존관계는 다음과 같다.<br/>
<p align="center"><img src="/assets/img/김영한의 스프링 핵심 원리/3장 스프링 핵심 원리 이해2/2-1.png" width="500"></p>

&ensp;하지만 실제 의존관계는 다음과 같았다.<br/>
<p align="center"><img src="/assets/img/김영한의 스프링 핵심 원리/3장 스프링 핵심 원리 이해2/2-2.png" width="500"></p>

&ensp;위 의존관계는 OrderServiceImpl이 DiscountPolicy 인터페이스 뿐만 아니라 FixDiscountPolicy인 구체 클래스도 함께 의존하고 있다. 이는 DIP를 위반하는 것이다.<br/>
&ensp;또한 정책을 FixedDiscountPolicy에서 RateDiscountPolicy로 변경하면 다음과 같이 의존관계가 바뀌게 된다.<br/>
<p align="center"><img src="/assets/img/김영한의 스프링 핵심 원리/3장 스프링 핵심 원리 이해2/2-3.png" width="500"></p>

&ensp;그래서 FixedDiscountPolicy를 RateDiscountPolicy로 변경하는 순간 OrderServiceImpl의 소스코드도 함께 변경해야 하므로 이는 OCP를 위반하는 것이다.<br/>
&ensp;DIP를 위반하지 않도옥 인터페이스에만 의존하도록 의존관계를 변경하면 된다. 다음과 같이 OrderServiceImpl.java를 변경해본다.
```java
package hello.core.order;

import hello.core.discout.DiscountPolicy;
import hello.core.discout.FIxDiscountPolicy;
import hello.core.discout.RateDiscountPolicy;
import hello.core.member.Member;
import hello.core.member.MemberRepository;
import hello.core.member.MemoryMemberRepository;

public class OrderServiceImpl implements OrderService {

    private final MemberRepository memberRepository = new MemoryMemberRepository();
//    private final DiscountPolicy discountPolicy = new FIxDiscountPolicy();
//    private final DiscountPolicy discountPolicy = new RateDiscountPolicy();
    private DiscountPolicy discountPolicy;
    
    @Override
    public Order createOrder(Long memberId, String itemName, int itemPrice) {
        Member member = memberRepository.findById(memberId);
        int discountPrice = discountPolicy.discount(member, itemPrice);

        return new Order(memberId, itemName, itemPrice, discountPrice);
    }
}
```

&ensp;하지만 실행해보면 NPE(Null Point Exception)가 발생한다. 이 문제를 해결하려면 클라이언트인 OrderServiceImpl에 DiscountPolicy의 구현 객체를 대신 생성하고 주입해주여야 한다.

관심사의 분리
======

AppConfig 등장
------
&ensp;애플리케이션의 전체 동작 방식을 구성(config)하기 위해, **구현 객체를 생성**하고, **연결**하는 책임을 가지는 별도의 설정 클래스르 만들어야 한다.

AppConfig 리팩터링
======

새로운 구조와 할인 정책 적용
======

전체 흐름 정리
======

좋은 객체 지향 설계의 5가지 원칙의 적용
======

Ioc, DI, 그리고 컨테이너
======

스프링으로 전환하기
======