---
title: "6장 데이터베이스 응용 개발"
excerpt: "SQL에 의해 제공되는 데이터 조작 기능 이외에 범용 프로그래밍 언어의 더 나은 유연성이 필요한 상황을 가끔 만난다. 예를 들면, 데이터베이스 응용을 좋은 그래픽 사용자 인터페이스와 통합하기를 원하거나, 다른 기존의 응용과 통합하기을 원할 수 있다."

wirter: Myeongwoo Yoon
categories:
  - Introduction To Database
tags:
  - Programing

toc: true
toc_sticky: true
 
date: 2023-10-22
last_modified_at: 2023-10-22
---

응용에서 데이터베이스 접근
======

　SQL 명령들이 C나 JAVA와 같은 **호스트 언어**의 프로그램 내부로부터 어떻게 실행될 수 있는지를 알아보자. 호스트 언어 프로그램 내에서 SQL 명령들을 사용하는 것을 **내장형(Embedded) SQL**이라고 한다. 내장형 SQL의 세부 항복들은 물론 호스트 언어에 종속된다.

내장형 SQL
------
　SQL 문은 호스트 언어에서 문장이 허용된 어디서든지 사용될 수 있다. SQL 문은 전처리기가 호스트 언어에 대한 컴파일러를 수행하기 전에 그들을 취급할 수 있도록 분명히 표시되어야 한다. 또한 SQL 명령으로 인수들을 전달하기 위해 사용되는 어떤 호스트 언어 변수들도 SQL에서 선언되어야 한다.<br/>
　내장형 SQL의 논의에서 호스트 언어는 C로 가정한다.<br/>

**변수 선언과 예외**<br/>
　SQL 문은 호스트 프로그램에서 정의된 변수들을 참조할 수 있다. 이러한 호스트 언어 변수들은 SQL 문에서 변수 이름 앞에 클론(:)을 붙여야 하며 EXEC SQL BEGIN DECLARE SECTION과 EXEC SQL END DECLARE SECTION 명령 사이에 선언되어야 한다. 예를 들어 다음과 같이 선언할 수 있다.
```c
EXEC SQL BEGIN DECLARE SECTION
char c_sname[20];
long c_sid;
short c_rating;
float c_age;
EXEC SQL END DECLARE SECTION
```

　SQL 문을 실행할 때 오류조건이 발생한다면, SQL이 무엇이 틀렸는지 알릴 방법이 필요하다. SQL-92 표준은 오류를 알리기 위해 SQLCODE와 SQLSTATE라는 두 개의 특수 변수를 인식한다.
* SQLCODE
  - 둘 중에 더 오래된 것이고 오류 조건이 발생할 때 어떤 음수를 반환하도록 정의되며, 이 때 특별한 음수가 무슨 오류를 나타내는지 하는 표시가 없다.
* SQLSTATE
  - 일반적인 몇 가지 오류 조건을 가진 미리 정의된 값들과 관련이 있다.

　SQLCODE에 관련된 C타입은 long이며 SQLSTATE에 관련된 C타입은 char[6], 즉 다섯 문자(with null 종료)의 문자열이다.<br/>

**SQL 문 내장하기**<br/>
　C에서 SQL 문은 앞에 EXEC SQL을 붙여야 한다.<br/>
　간단한 예로서, 다음의 내장형 SQL문은 Sailors 릴레이션으로 한 행을 삽입하며, 그것의 열 값들은 그곳에 포함된 호스트 언어 변수 값을 기반으로 한다.
```c
EXEC SQL
INSERT INTO Sailors VALUES (:c_sname, :c_sid, :c_rating, :c_age);
```

커서
------
　C 같은 호스트 언어에 SQL 문을 내장함에 있어 가장 중요한 문제점은 C같은 언어가 레코드 집합 추상화를 분명히 지원하지 못하는데 반하여, SQL은 레코드 집합에 대해 동작하기 때문에 임피던스 부조화가 발생한다는 것이다. 해결책은 릴레이션으로부터 한 번에 한 행씩 가져오도록 허용하는 메카니즘인 커서(curor)를 제공하는 것이다.<br/>
　어떤 릴레이션마다 혹은 어떤 SQL 질의마다 하나의 커서를 선언할 수 있다. 일단 커서가 선언되면, 그것을 **개방(open)**할 수 있고, 다음 행을 **인출(fetch)**하고, 커서를 **이동(move)**하며, 그 커서를 **폐쇠(close)**한다.<br/>

**기본 커서 정의 및 사용**<br/>
　호스트 변수 c_sid에 한 값을 배정함으로써 표시된 뱃사람의 이름과 나이를 구해보자.
```c
EXEC SQL SELECT S.sname, S.age
         INTO :c_sname, :c_age
         FROM Sailors S
         WHERE S.sid = :c_sid;
```
　INTO 절은 단일 답 행의 열 값들을 배정하도록 하므로 커서가 필요 없다. 만약 호스트 변수 c_minrating의 현재 값보다 높은 등급을 가진 모든 뱃사람들의 이름과 나이를 계산하기 위한 다음 질의를 보자.
```c
EXEC SQL DECLARE sinfo CURSOR FOR
         SELECT S.sname, S.age
         FROM Sailors S
         WHERE S.rating > :c_minrating;
```
　위 질의에서 INTO 절은 여러 행들을 취급해야 하기 때문에 부적절하므로 커서를 사용했다. 이 코드는 일단 실행되면 커서 sinfo가 정의된다. 계속해서 그 커서를 다음과 같이 개방할 수 있다.
```c
OPEN sinfo;
```
　그 커서와 연관된 SQL 질의에서 c_minrating의 값은 그 커서를 개방할 때의 이 변수 값이다.<br/>
　커서가 개방될 때, 그것은 첫 행 앞을 가리킨다. 호스트 언어 변수로 커서 sinfo의 첫 행을 읽기 위해 FETCH 명령을 사용할 수 있다.
```c
FETCH sinfo INTO :c_sname, :c_age;
```
　FECTH 문이 수행될 때, 커서는 다음 행 지점에 높이게 되고 그 행의 열 값들이 대응되는 호스트 변수들로 복사된다. 이 FECTH문을 반복 실행하면, 질의에 의해 계산된 모든 행들을 한 번에 한 행씩 읽을 수 있다. FETCH 문이 마지막 행 다음에 커서를 위치시키면, SQLSTATE는 더 이상 행이 없다는 것을 표시하기 위해, NO DATA를 나타내는 값 02000이 설정된다.<br/>
　커서를 다 사용했을 때, 그것을 폐쇠할 수 있다.
```c
CLOSE sinfo;
```

**커서의 성질**<br/>
　커서 선언의 일반형은 다음과 같다.
```c
DECLARE cursorname [INSENSITIVE] [SCROLL] CURSOR
        [WITH HOLD]
        FOR some query
        [ORDER BY order-item-list]
        [FOR READ ONLY | FOR UPDATE]
```
　커서는 **읽기 전용 커서(read only cursor)**로 선언될 수도 있고 (FOR READ ONLY), 그것이 기반 릴레이션이나 갱신 가능 뷰에 대한 커서라면 **갱신 가능 커서(updatable cursor)**로 선언될 수도 있다(FOR UPDATE).<br/>
　UPDATE나 DELETE 명령의 간단한 변화는 그 커서가 가리키는 행을 갱신하거나 삭제할 수 있다. 예를 들면, sinfo가 갱신 가능 커서이고 개방되어 있다면, 다음 문장을 수행할 수 있다.
```c
UPDATE Sailors S
SET S.rating = S.rating -1
WHERE CURRENT of sinfo;
```

　마찬가지로, 다음 문장을 수행함으로서 이 행을 삭제할 수 있다.
```c
DELETE Sailors S
WHERE CURRNET of sinfo;
```

　만약 키워드 SCROLL이 표시되면, 커서는 **스크롤 가능(scrollable)**이 되는데, 그것은 FETCH 명령의 변형이 매우 유연한 방법으로 커서를 위치시키기 위해서 사용될 수 있다는 것을 의미한다.

동적 SQL
------
　DBMS로부터 데이터를 접근할 필요가 있는 스프레드시트나 그래픽적 전위와 같은 응용을 생각해 보자. 이러한 응용은 사용자로부터 명령을 받고, 사용자가 필요한 것에 맞추며, 필요한 데이터를 검색하기 위해 적절한 SQL문을 만들어야 한다. 이러한 상황에서, 비록 사용자의 명령이 제기되면 그 응용이 필요한 SQL 문을 구성해 주는 어떤 알고리즘이 있을 지라도, 무슨 SQL 문이 실행될 필요가 있는지 미리 예측할 수 없을지도 모른다.<br/>
　SQL은 이러한 상황을 취급하기 위해 몇 가지 기능들을 제공하는데 이를 **동적 SQL(Dynamic SQL)**이라 부른다. 두 가지 주요 명령, PREPARE과 EXECUTE를 간단한 예를 통해 알아보자.
```c
char c_sqlstring[] = {"DELETE FROM Sailors WHERE rating>5"};
EXEC SQL PREPARE readytogo FROM :c_sqlstring;
EXEC SQL EXECUTE readytogo;
```
　첫 번째 문장은 C변수 c_sqlstring을 선언하고 그 값을 한 SQL 명령의 문자열 표현으로 초기화 한다. 두 번째 문장은 이 문자열이 SQL 명령으로서 파싱되고 컴파일되며, 그 실행 가능한 경과는 SQL 변수 readytogo로 바인드된다. 세 번째 문장은 이 명령을 실행한다.<br/>
　많은 상황들이 동적 SQL의 사용을 필요로 한다. 그러나, 동적 SQL 명령의 준비는 실행 시간에 발생하고 실행 시간에 부하가 됨을 주의하자. 대화형이나 내장형 SQL 명령은 컴파일 시간에 한 번만 준비될 수 있고 원하는 대로 몇 번이든 재실행될 수 있다. 따라서 동적 SQL의 사용을 중요한 상황으로 제한해야 한다.