---
title: "로스트아크 시세 조회 기능"
excerpt: "아이템 시세 수집 조회 구현"

wirter: Myeongwoo Yoon
categories:
  - BackendProjects
tags:
  - 로스트아크
  
toc: true
toc_sticky: true
use_math: true
 
date: 2025-12-12
last_modified_at: 2025-12-12
---

&ensp;LostArk Open API를 사용해 시세를 수집해 DB에 저장하는 기능을 구현하였다. 이제 이 데이터를 활용해서 프론트에서 조회할 수 있는 기능을 구현한다.

BackEnd
======

&ensp;시세 수집 기능을 구현했을 때 만들었던 package에 다음 기능을 추가로 구현한다.
* 특정 아이템 최신 시세 조회
* 기간별 시세 히스토리 조회

&ensp;먼저 최신 시세를 return하기 위해 DTO를 하나 추가한다.
```java
@Getter
@NoArgsConstructor
@AllArgsConstructor
public class MarketItemLatestPriceResponse {

    @JsonProperty("ItemId")
    private Long itemId;

    @JsonProperty("Name")
    private String name;

    @JsonProperty("Date")
    private String date;

    @JsonProperty("AvgPrice")
    private Double avgPrice;

    @JsonProperty("TradeCount")
    private Integer tradeCount;
}
```

&ensp;전에 service에 만들었던 MarketItemService의 역할을 분리한다(책임 분리 명확). 기존에 수집을 위해 만들었던 코드는 `MarketItemCollectService`로 변경하고 조회를 위한 코드는 `MarketItemQueryService`로 생성한다.

```java
@Slf4j
@Service
@RequiredArgsConstructor
public class MarketItemQueryService {

    private final MarketItemRepository marketItemRepository;
    private final MarketItemPriceHistoryRepository marketItemPriceHistoryRepository;

    // 특정 아이템 최신 시세 조회
    @Transactional
    public MarketItemLatestPriceResponse getLatestPrice(Long itemId) {
        MarketItem item = getItemOrThrow(itemId);

        MarketItemPriceHistory latestHistory = marketItemPriceHistoryRepository.findTopByMarketItem_IdOrderByPriceDateDesc(item.getId())
                .orElseThrow(() ->
                        new IllegalStateException("해당 아이템의 시세 데이터가 존재하지 않습니다."));

        return new MarketItemLatestPriceResponse(
                item.getItemId(),
                item.getName(),
                latestHistory.getPriceDate().toString(),
                latestHistory.getAvgPrice(),
                latestHistory.getTradeCount()
        );
    }

    // 기간별 시세 히스토리 조회
    @Transactional
    public List<MarketItemStatsResponse> getPriceHistory(Long itemId, LocalDate startDate, LocalDate endDate) {
        MarketItem item = getItemOrThrow(itemId);

        List<MarketItemPriceHistory> histories = marketItemPriceHistoryRepository.findByMarketItem_IdAndPriceDateBetweenOrderByPriceDate(
                item.getId(), startDate, endDate
        );

        return histories.stream()
                .map(MarketItemStatsResponse::from)
                .toList();
    }

    // 아이템 존재 여부 확인
    private MarketItem getItemOrThrow(Long itemId) {
        return marketItemRepository.findByItemId(itemId)
                .orElseThrow(() ->
                    new IllegalArgumentException("존재하지 않는 아이템입니다. itemId=" + itemId));
    }
}
```

* MarketItemLatestPriceResponse getLatestPrice(Long itemId)
  - MarketPriceHistoryRepository에 Optional<MarketItemPriceHistory> findTopByMarketItem_IdOrderByPriceDateDesc(Long itemId)를 추가한다.
  - Spring을 실행했을 때 OpenAPI에서 제공하는 ItemId를 이용해 조회하면 **"해당 아이템의 시세 데이터가 존재하지 않습니다."**가 출력되었다. 이는 ItemPriceHistory에서 item 테이블을 외래키 참조하고 있는데, 이때 itemPriceHistory의 item_id는 item의 id와 연결되어 있기 때문이었다.
  - 그래서 기존 findTopByMarketItem_IdOrderByPriceDateDesc(itemId)를 item.getId()로 수정해 해결하였다.
* List<MarketItemStatsResponse> getPriceHistory(Long itemId, LocalDate startDate, LocalDate endDate)
  - MarketPriceHistoryRepository에 List<MarketItemPriceHistory> findByMarketItem_IdAndPriceDateBetweenOrderByPriceDate(Long itemId, LocalDate startDate, LocalDate endDate)를 추가한다.
  - stream(): 리스트를 하나씩 흘려보내면서 처리할 수 있는 흐름으로 바꿔줌
    + histories.stream(): MarketItemPriceHistory들을 하나씩 꺼내서 가공하겠다는 선언
  - map(): 각 요소를 다른 형태로 변환(매핑)
    + .map(MarketItemStatsResponse::from): histories 안의 각 엔티티를 DTO로 바꾸는 작업
  - ::from: 각 history를 DTO로 바꿔주는 변환 함수
    + 이를 위해 MarketItemStatsResponse에 다음을 추가해준다.
    ```java
    public static MarketItemStatsResponse from(MarketItemPriceHistory history) {
        return new MarketItemStatsResponse(
                history.getPriceDate().toString(),
                history.getAvgPrice(),
                history.getTradeCount()
        );
    }
    ```
  - .toList(): 스트림을 리스트로 수집
* MarketItem getItemOrThrow(Long itemId): 아이템 존재 여부 확인

&ensp;이제 이 service를 사용하기위해 marketItemcontroller에 추가한다.
```java
// 특정 아이템 최신 시세 조회
    @GetMapping("/{itemId}/latest")
    public MarketItemLatestPriceResponse getLatestPrice(@PathVariable Long itemId) {
        return marketItemQueryService.getLatestPrice(itemId);
    }

    // 기간별 시세 히스토리 조회
    @GetMapping("/{itemId}/history")
    public List<MarketItemStatsResponse> getPriceHistory(@PathVariable Long itemId,
            @RequestParam
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE)
            LocalDate startDate,
            @RequestParam
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE)
            LocalDate endDate
    ) {
        return marketItemQueryService.getPriceHistory(itemId, startDate, endDate);
    }
```

&ensp;이제 다음 사항들을 테스트코드로 작성해본다.
* 정상 아이템 조회 테스트
* 날짜 범위 조회 테스트
* 데이터 없는 날짜 조회 시 처리 검증
* 잘못된 itemId 요청 시 예외 테스트

```java
@SpringBootTest
@Transactional
class MarketItemQueryServiceTest {

    @Autowired
    private MarketItemQueryService marketItemQueryService;

    @Autowired
    private MarketItemRepository marketItemRepository;

    @Autowired
    private MarketItemPriceHistoryRepository marketItemPriceHistoryRepository;

    private MarketItem item;

    @BeforeEach
    void setUp() {
        // 외부 ID = 652039050
        item = marketItemRepository.save(
                MarketItem.builder()
                        .itemId(652039050L)
                        .name("테스트 아이템")
                        .build()
        );

        marketItemPriceHistoryRepository.save(
                MarketItemPriceHistory.builder()
                        .marketItem(item)
                        .priceDate(LocalDate.of(2025, 12, 1))
                        .avgPrice(1000.0)
                        .tradeCount(10)
                        .build()
        );

        marketItemPriceHistoryRepository.save(
                MarketItemPriceHistory.builder()
                        .marketItem(item)
                        .priceDate(LocalDate.of(2025, 12, 2))
                        .avgPrice(1200.0)
                        .tradeCount(12)
                        .build()
        );
    }

    @Test
    void 정상_아이템_기간별_조회() {
        List<MarketItemStatsResponse> result =
                marketItemQueryService.getPriceHistory(
                        652039050L,
                        LocalDate.of(2025, 12, 1),
                        LocalDate.of(2025, 12, 2)
                );

        Assertions.assertThat(result).hasSize(2);
        Assertions.assertThat(result.get(0).getAvgPrice()).isEqualTo(1000.0);
        Assertions.assertThat(result.get(1).getAvgPrice()).isEqualTo(1200.0);
    }

    @Test
    void 날짜_범위로_부분_조회() {
        List<MarketItemStatsResponse> result =
                marketItemQueryService.getPriceHistory(
                        652039050L,
                        LocalDate.of(2025, 12, 2),
                        LocalDate.of(2025, 12, 2)
                );

        Assertions.assertThat(result).hasSize(1);
        Assertions.assertThat(result.get(0).getDate()).isEqualTo("2025-12-02");
    }

    @Test
    void 데이터_없는_날짜_조회시_빈리스트_반환() {
        List<MarketItemStatsResponse> result =
                marketItemQueryService.getPriceHistory(
                        652039050L,
                        LocalDate.of(2025, 11, 1),
                        LocalDate.of(2025, 11, 5)
                );

        Assertions.assertThat(result).isEmpty();
    }

    @Test
    void 존재하지_않는_아이템ID_조회시_예외발생() {
        assertThatThrownBy(() ->
                marketItemQueryService.getPriceHistory(
                        99999999L,
                        LocalDate.of(2025, 12, 1),
                        LocalDate.of(2025, 12, 2)
                )
        ).isInstanceOf(IllegalArgumentException.class);
    }

}
```

* @BeforeEach: 각 테스트 메서드 실행 직전에 특정 초기화 로직을 반복적으로 실행하도록 하는 어노테이션으로, 테스트 메서드마다 독립적인 환경을 보장하고 코드 중복을 피하기 위해 사용

대량 데이터 조회 시 성능 고려 (쿼리 최적화)
------

&ensp;시세 히스토리 데이터는 하루 단위로 지속적으로 누적되며, 장기적으로는 아이템별로 수백~수천 건 이상의 시계열 데이터가 저장된다. 프론트엔드에서 시세 변화를 차트로 시각화하기 위해서는 특정 아이템의 일정 기간 데이터를 한 번에 조회해야 하므로, 대량 데이터 환경에서도 안정적인 조회 성능을 보장할 필요가 있었다.

&ensp;시세 조회 기능에서 사용되는 쿼리는 다음과 같은 특징을 가진다.

* 특정 아이템 1개 기준 조회
* 날짜 범위 조건(startDate ~ endDate)
* 날짜 오름차순 정렬 (차트 시각화 목적)

```sql
SELECT *
FROM market_item_price_history
WHERE item_id = ?
  AND price_date BETWEEN ? AND ?
ORDER BY price_date;
```

&ensp;이와 같은 쿼리는 인덱스가 존재하지 않을 경우 데이터 증가에 따라 풀 테이블 스캔이 발생할 수 있으며, 이는 조회 성능 저하의 원인이 될 수 있다.<br/>
&ensp;특히 item_id 단일 인덱스만 사용할 경우 날짜 범위 및 정렬 과정에서 추가적인 정렬 비용이 발생할 수 있으므로, 조회 조건과 정렬 조건을 동시에 만족하는 (item_id, price_date) 기준의 복합 인덱스를 추가하였다.<br/>
&ensp;이를 통해 DB는 item_id 조건으로 먼저 검색 범위를 축소한 뒤, price_date 기준으로 정렬된 인덱스를 활용하여 추가 정렬 없이 결과를 반환할 수 있다.

```java
@Entity
@Table(
    name = "market_item_price_history",
    indexes = {
        @Index(
            name = "idx_market_item_date",
            columnList = "item_id, price_date"
        )
    }
)
public class MarketItemPriceHistory {
    ...
}
```

* item_id 조건으로 조회 범위를 즉시 축소
* price_date 기준 범위 검색(BETWEEN) 최적화
* ORDER BY price_date 정렬 비용 최소화

&ensp;본 기능은 페이지 단위 조회가 아닌 시계열 차트 시각화를 위한 데이터 조회를 목적으로 한다. 따라서 본 기능에서는 일반적인 목록 조회에 사용되는 페이징(Pageable) 방식보다는, 기간 조건 기반 조회가 요구사항과 더 부합한다고 판단하였다.

* 차트 렌더링 시 전체 기간 데이터를 한 번에 필요
* 일반적인 조회 범위는 수개월 ~ 1년 이내
* 인덱스를 활용한 조건 조회가 페이징보다 효율적

FrontEnd
======